var documenterSearchIndex = {"docs":
[{"location":"overview/software_architecture/#Software-architecture","page":"Software architecture","title":"Software architecture","text":"warning: üößüöß Under construction üößüöß\nThe architecture of Terrarium.jl is still in an early prototype stage and is the subject of ongoing discussion. This page is a non-exhaustive summary of the current working concept and will be updated accordingly if and when the architecture changes.","category":"section"},{"location":"overview/software_architecture/#Numerical-implementation","page":"Software architecture","title":"Numerical implementation","text":"Terrarium is based on the numerics and finite-volume method operators provided by Oceananigans.jl. All state variables are represented as Oceananigans Fields with computations automatically distributed using KernelAbstractions.jl. Spatial grids in Terrarium are similarly based on the corresponding Oceananigans grids, most prominently the RectilinearGrid which represents a rectangular volume divided orthogonally into smaller control volumes along the X, Y, and Z dimensions.","category":"section"},{"location":"overview/software_architecture/#The-AbstractModel-interface","page":"Software architecture","title":"The AbstractModel interface","text":"A ‚Äúmodel‚Äù in Terrarium represents a collection of parameters and process types that characterize a simulation. All models must be defined as structs that subtype AbstractModel and will typically consist of the following fields/properties:\n\nA grid that defines the discretization of the spatial domain\nAn initializer responsible for initializing state variables\nOne or more processes and/or sub-models that define the state variables and the dynamics of the system\n\nThe distinction between what constitutes a ‚Äúmodel‚Äù versus a ‚Äúprocess‚Äù should be based on whether or not there is a use case for running simulations of that model/process independently from other processes. Models should be built to be independently runnable standalone in a Simulation, while process types simply provide the concrete implementations of the physical processes to be included in a model. Since Terrarium models are composable, it should generally be trivial to convert a process into a full standalone model later (if necessary) without affecting the other model components that depend on it.\n\nAll AbstractModel and AbstractProcess types must additional provide dispatches for the following methods:\n\nvariables(::Model) returns a tuple of variable metadata declaring the state variables. Variables must be one of two types: prognostic or auxiliary (sometimes referred to as ‚Äúdiagnostic‚Äù). Prognostic variables fully characterize the state of the system at any given timestep and are updated according to their tendencies (i.e. G in the aforementioned equation). Tendencies are automatically allocated for each prognostic variable declared by the model.\ncompute_auxiliary!(state, ::Model) computes the values of all auxiliary variables (if necessary) assuming that the prognostic variables of the system in state are available for the current timestep.\ncompute_tendencies!(state, ::Model) computes the tendencies based on the current values of the prognostic and auxiliary variables stored in state.\n\nIn addition, AbstractModel  implementations must also provide dispatches for the following methods:\n\ninitialize!(state, ::Model, ::Initializer) computes any necessary initialization of the model state based on the user-supplied configuration and parameter settings. The additional initializer argument is extracted from the model and allows for alternative dispatches based on various initialization schemes for each model.\ntimestep!(state, ::Model, ::TimeStepper, Œît) updates the prognostic state variables according to the given timestepping scheme. This method can and should be implemented generically for any timestepping scheme but allows for model-specific overrides where necessary.\nget_grid(::Model) returns the spatial grid associated with the model. A default implementation is provided which assumes that the model defines a field named grid.\nget_initializer(::Model) returns the initializer for the model. A default implementation is provided which assumes that the model defines a field named initializer.","category":"section"},{"location":"overview/software_architecture/#State-variables","page":"Software architecture","title":"State variables","text":"State variables are realized as Oceananigans Fields defined over the model grid. Each variable returned by the variables method will be allocated a corresponding Field with boundary conditions and initial values specified by one or more AbstractInitializers defined on the model. This allocation occurs when creating a Simulation by calling  initialize(model). The resulting Simulation object will have a property state of type StateVariables which holds all of the Fields for each state variable defined by the model.\n\nAs an example, suppose we are implementing a new model MyModel and we want to define the necessary state variables. We do this by defining a new dispatch of the variables method:\n\nvariables(::MyModel) = (\n\tprognostic(:progvar, XYZ()),\n\tauxiliary(:auxvar, XYZ()),\n\tauxiliary(:bc, XY()),\n)\n\nThis will result in a total of four state variables being allocated when initialize(model) is called: two auxiliary variables named auxvar and bc as well as one prognostic variable named progvar along with its corresponding tendency which is created automatically. The second argument to the variable metadata constructors prognostic and auxiliary is a subtype of VarDims which specifies on which spatial dimensions the state variable should be defined. XYZ() corresponds to a 3D Field which is discretized both laterally (along spatial grid cells) and along the vertical axis. Currently, Terrarium only supports a single 3D grid representing variables defined in the soil domain, though this may change in the near future in order to accommodate multi-layer snow and canopy processes. XY() corresponds to a 2D field which is discretized along the lateral dimension only. Note that Terrarium also currently supports only 1D (vertical) dynamics so all grid cells on the X and Y axes will be assumed independent. This is equivalent to what is typically called a single column model, or column-based parameterization in atmosphere and ocean modeling. However, building on Oceananigans means that we have a clear path to relax this assumption in the future!","category":"section"},{"location":"physics/soil_energy_water/#Soil-hydrothermal-dynamics","page":"Energy and water balance","title":"Soil hydrothermal dynamics","text":"warning: Warning\nThis page is a work in progress. If you have any questions or notice any errors, please raise an issue.","category":"section"},{"location":"physics/soil_energy_water/#Heat-transfer","page":"Energy and water balance","title":"Heat transfer","text":"Heat transfer along the vertical axis perpendicular to the land surface can be represented according to the heat equation, with the upper boundary set to surface temperature and the lower boundary set to a constant positive heat flux representing heat produced by the inner earth (Lachenbruch 1986, Jaeger 1965). If both the upper and lower boundaries are assumed to be constant over time, the steady-state temperature profile takes the form of a continuous piecewise linear function increasing over depth with the slope determined by the thermal properties of the ground material. The instantaneous temperature field can then be generally represented as\n\nbeginequation\nT(zt) = T_0 + fracQ_textgeokappa_texth(z)z + Delta T(zt)\nendequation\n\nwhere T(zt) is the temperature field (K) over depth z (m) and time t (s), T_0 is the mean annual GST (K), Q_textgeo is the geothermal heat flux (W/m¬≤), and kappa_texth(z) (W/m K) is the thermal conductivity which may vary with depth depending on the material. The last term Delta T(zt) represents transient disturbances to the steady state temperature profile due to both seasonal and long-term fluctuations in the upper and lower boundary conditions of the vertical domain. Simulating the impacts of these transient changes is one of the primary objectives of most numerical permafrost and land surface models.\n\nDiffusive heat flow in a solid medium is governed by Fourier's law,\n\nbeginequation\n    mathbfj_texth cdot mathbfn_z = -kappa_texthfracpartial Tpartial z\nendequation\n\nwhere mathbfj_texth (W/m¬≤) is the diffusive heat flux vector and mathbfn_z is the upward facing normal vector along the vertical z axis.\n\nSince ground materials are often porous, i.e., there exists void space between the solid particles, it is necessary to consider the potential presence of water and/or ice in this void space, which is hereafter referred to as pore space, or simply, soil pores. The thermal effects of water and ice can be accounted for by considering not only the temperature of the material but rather the total internal energy of the elementary volume. Combining the diffusive flux with a potential advective heat flux j_z^textw due to water flow yields the energy conservation law,\n\nbeginequation\nfracpartial U(Ttheta)partial t - nabla cdot left(mathbfj_texth + mathbfj_h^textwright) - F_h(zt) = 0\nendequation\n\nwhere U(Ttheta) (J/m¬≥) is the volumetric internal energy as a function of temperature and total water/ice content theta (m¬≥/m¬≥), and F_h(zt) is an inhomogeneous heat source/sink (forcing) term.\n\nThe advective heat flux j_texth^textw can be represented as,\n\nbeginequation\nmathbfj_texth^textw = left( c_textw T + L_textsl right) mathbfj_textw rho_textw\nendequation\n\nwhere L_textsl and c_textw (J/kg) represent the specific latent heat of fusion and heat capacity of liquid water respectively. This flux term accounts for the energy transferred by the movement of water within the soil matrix. In model configurations that neglect subsurface water flow, this flux term is implicitly assumed to be zero.","category":"section"},{"location":"physics/soil_energy_water/#Energy-temperature-closure","page":"Energy and water balance","title":"Energy-temperature closure","text":"The constitutive relationship between energy and temperature plays a key role in characterizing the subsurface energy balance. This relation can be defined in integral form as\n\nbeginequation\n    U(Ttheta) = int_T_textref^T tildeC(xtheta)  dx\n    = overbraceHC(thetawthetai)leftT-T_textrefright^textSensible + overbracedensityw LHFthetaw(Tthetawi)^textLatent\nendequation\n\nwhere tildeC is referred to as the effective or apparent heat capacity and T_textref is a reference temperature. The apparent heat capacity is then defined as the derivative of the energ-temperature relation,\n\nbeginequation\ntildeC(Ttheta) = fracpartial Upartial T =\noverbraceC(theta_textwtheta) + T fracpartial Cpartial theta_textwfracpartial theta_textwpartial T^textSensible +\noverbracerho_textw L_textsl fracpartialtheta_textwpartial T^textLatent\nendequation\n\nwhere theta_textw(Ttheta) is the volumetric unfrozen water content as a function of temperature and total water/ice content is the bulk volumetric material heat capacity of the volume as a function of the unfrozen and total water contents;  rho_textw (kg/m¬≥) and L_textsl (J/kg) correspond to the density and specific latent heat of fusion of water, respectively. The grouping of terms on the right-hand side show the partitioning of energy change into sensible and latent heat. The sensible component represents the energy necessary to heat a volume of the material to a particular temperature, whereas the latent component corresponds to the energy required for the phase change of water in the volume from solid (frozen) to liquid (thawed).\n\nIn the simplest case where we neglect the effect of capillary action in the soil, the energy-temperature relation can be derived according to that of \"free\" water (i.e. unbound by the soil matrix),\n\nbeginequation\n    theta_textw(U) =\n        begincases\n            0                    U  -rho_textwL_textsltheta \n            fracUL  -rho_textwL_textsltheta leq U  0 \n            theta               U geq 0\n        endcases\nendequation\n\nwith temperature then determined by\n\nbeginequation\n    U^-1(U(Ttheta)) =\n    begincases\n    fracU(Ttheta) - rho_textwL_textslthetaC  U(Ttheta)  -rho_textwL_textsltheta \n    0  0 leq U(Ttheta) leq rho_textwL_textsltheta \n    fracU(Ttheta)C    U(Ttheta) geq 0\n    endcases\nendequation\n\nwhere C = C(theta_textwtheta) is the volumetric heat capacity (J/K/m¬≥) as a function of the unfrozen and total water content.","category":"section"},{"location":"physics/soil_energy_water/#Vertical-water-transport-in-variably-saturated-soil","page":"Energy and water balance","title":"Vertical water transport in variably saturated soil","text":"The vertical flow of water in porous media, such as soils, can be formulated as following the conservation law\n\n    phifracpartialvartheta(psi)partial t - nabla cdot textbfj_textw - F_textw(zt) = 0\n\nwhere phi is the natural porosity (or saturated water content) of the soil volume and F_textw(zt) (m/s) is an inhomogeneous source/sink (forcing) term.\n\nVertical fluxes in the soil column be represented by combining gravity-driven advection with Darcy's law\n\nbeginequation\ntextbfj_textw cdot mathbfn = -kappa_textwfracpartial left(psi + zright)partial z\nendequation\n\nwhere psi (m) is the matric potential. Substituting this equation into the aforementioned conservation law yields the widely known Richardson-Richards equation for variably saturated flow in porous media (Richards 1931).","category":"section"},{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_reference/#Core.Type-Union{Tuple{Terrarium.AbstractLandGrid}, Tuple{ModelType}} where ModelType<:Terrarium.AbstractModel","page":"API Reference","title":"Core.Type","text":"Convenience constructor for all AbstractLandModel types that allows the grid to be passed as the first positional argument.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.Fields.Field","page":"API Reference","title":"Oceananigans.Fields.Field","text":"Field(\n    grid::AbstractLandGrid,\n    dims::VarDims,\n    boundary_conditions = nothing,\n    args...;\n    kwargs...\n)\n\nAuxiliary constructor for an Oceananigans Field on grid with the given Terrarium variable dims and boundary conditions. Additional arguments are passed direclty to the Field constructor. The location of the Field is determined by VarDims defined on var.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Oceananigans.OutputReaders.FieldTimeSeries","page":"API Reference","title":"Oceananigans.OutputReaders.FieldTimeSeries","text":"FieldTimeSeries(\n    grid::AbstractLandGrid,\n    dims::VarDims,\n    times=eltype(grid)[]\n)\n\nConstruct a FieldTimeSeries on the given land grid with the given dims and times.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RingGrids.Field-Union{Tuple{LY}, Tuple{LX}, Tuple{Field{LX, LY, Nothing}, ColumnRingGrid}} where {LX, LY}","page":"API Reference","title":"RingGrids.Field","text":"Field(field, grid; fill_value)\n\n\nConverts the given Oceananigans Field to a RingGrids.Field with a ring grid matching that of the given ColumnRingGrid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.AbstractAlbedo","page":"API Reference","title":"Terrarium.AbstractAlbedo","text":"Base type for surface albedo and emissivity process implementations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractBulkWeightingScheme","page":"API Reference","title":"Terrarium.AbstractBulkWeightingScheme","text":"Base type for bulk weighting/mixing schemes that calculate weighted mixture of material properties such as conductivities or densities.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractClosureRelation","page":"API Reference","title":"Terrarium.AbstractClosureRelation","text":"abstract type AbstractClosureRelation\n\nBase type for prognostic variable closure relations for differential equations of the form:\n\nfracpartial g(u)partial t = F(u)\n\nwhere F represents the RHS tendency as a function of the state variable u, and g(u) is a closure or constitutive relation that maps u to the physical units matching the tendency. Common examples in soil hydrothermal modeling are temperature-enthalpy and saturation-pressure relations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractGroundModel","page":"API Reference","title":"Terrarium.AbstractGroundModel","text":"abstract type AbstractGroundModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for ground (e.g. soil and rock) models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractHydrologyModel","page":"API Reference","title":"Terrarium.AbstractHydrologyModel","text":"abstract type AbstractHydrologyModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for surface hydrology models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractInitializer","page":"API Reference","title":"Terrarium.AbstractInitializer","text":"Base type for model initializers. Implementations should provide a dispatch of the initialize!(state, model::M, init::I) method where M corresponds to the model type and I to the initializer. An implementation of get_field_initializers can also be provided which returns a NamedTuple of initializer functions for individual state variable fields.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractLandModel","page":"API Reference","title":"Terrarium.AbstractLandModel","text":"AbstractLandModel <: AbstractModel\n\nBase type for full land models which couple together multiple component models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractModel","page":"API Reference","title":"Terrarium.AbstractModel","text":"abstract type AbstractModel{NF, Grid<:(Terrarium.AbstractLandGrid{NF})}\n\nBase type for all model types.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractProcess","page":"API Reference","title":"Terrarium.AbstractProcess","text":"AbstractProcess\n\nBase type for all processes which define physics or parameterizations but are not standalone models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractProcessVariable","page":"API Reference","title":"Terrarium.AbstractProcessVariable","text":"Base type for state variable placeholder types with \n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractRadiativeFluxes","page":"API Reference","title":"Terrarium.AbstractRadiativeFluxes","text":"Base type for radiation budget schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSkinTemperature","page":"API Reference","title":"Terrarium.AbstractSkinTemperature","text":"Base type for skin temperature and ground heat flux schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSnowModel","page":"API Reference","title":"Terrarium.AbstractSnowModel","text":"abstract type AbstractSnowModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for snow models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilET","page":"API Reference","title":"Terrarium.AbstractSoilET","text":"Base type for soil/subsurface evapotranspiration forcing terms.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilHydraulics","page":"API Reference","title":"Terrarium.AbstractSoilHydraulics","text":"Base type for soil hydraulic properties and parameterization schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilModel","page":"API Reference","title":"Terrarium.AbstractSoilModel","text":"abstract type AbstractSoilModel{NF, GR} <: Terrarium.AbstractGroundModel{NF, GR}\n\nBase type for soil ground models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilRunoff","page":"API Reference","title":"Terrarium.AbstractSoilRunoff","text":"Base type for soil/subsurface runoff schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSurfaceEnergyBalance","page":"API Reference","title":"Terrarium.AbstractSurfaceEnergyBalance","text":"Base type for surface energy balance schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSurfaceEnergyModel","page":"API Reference","title":"Terrarium.AbstractSurfaceEnergyModel","text":"abstract type AbstractSurfaceEnergyModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for land-atmosphere energy exchange models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractTimeStepper","page":"API Reference","title":"Terrarium.AbstractTimeStepper","text":"Base type for time steppers.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractTimeStepperCache","page":"API Reference","title":"Terrarium.AbstractTimeStepperCache","text":"Base type for time-stepper state caches.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractTurbulentFluxes","page":"API Reference","title":"Terrarium.AbstractTurbulentFluxes","text":"Base type for turbulent (latent and sensible) heat fluxes at the surface.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractUnsatK","page":"API Reference","title":"Terrarium.AbstractUnsatK","text":"Base type for unsaturated hydraulic conductivity parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVariable","page":"API Reference","title":"Terrarium.AbstractVariable","text":"Base type for state variable placeholder types.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVegetationModel","page":"API Reference","title":"Terrarium.AbstractVegetationModel","text":"abstract type AbstractVegetationModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for vegetation/carbon models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVerticalFlow","page":"API Reference","title":"Terrarium.AbstractVerticalFlow","text":"Base type for implementations of soil water flow dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AnyField","page":"API Reference","title":"Terrarium.AnyField","text":"Type alias for an AbstractField with any X, Y, Z location or grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AnyFieldTimeSeries","page":"API Reference","title":"Terrarium.AnyFieldTimeSeries","text":"Type alias for a FieldTimeSeries with any X, Y, Z location or grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AuxiliaryVariable","page":"API Reference","title":"Terrarium.AuxiliaryVariable","text":"struct AuxiliaryVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units, Var<:Terrarium.Variable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}, DT<:IntervalSets.AbstractInterval} <: Terrarium.AbstractProcessVariable{name, VD<:Terrarium.VarDims}\n\nRepresents an auxiliary (a.k.a \"diagnostic\") state variable with the given name and spatial dims. Auxiliary variables are those which are diagnosed directly or indirectly from the values of one or more prognostic variables.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.BCType","page":"API Reference","title":"Terrarium.BCType","text":"Alias for Oceananigans AbstractBoundaryConditionClassification.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ColumnGrid","page":"API Reference","title":"Terrarium.ColumnGrid","text":"ColumnGrid{NF, Arch<:AbstractArchitecture, RectGrid<:OceananigansGrids.RectilinearGrid} <: AbstractLandGrid\n\nRepresents a set of laterally independent vertical columns with dimensions (x, y, z) where x is the column dimension, y=1 is constant, and z is the vertical axis.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ColumnRingGrid","page":"API Reference","title":"Terrarium.ColumnRingGrid","text":"struct ColumnRingGrid{NF, Arch, RingGrid<:RingGrids.AbstractGrid, RectGrid<:Oceananigans.Grids.RectilinearGrid, Mask<:AbstractArray} <: Terrarium.AbstractLandGrid{NF, Arch}\n\nRepresents a global (spherical) grid of independent, vertical columns where the spatial discretization in the horizontal direction is defined by a RingGrids.AbstractGrid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantAerodynamicResistance","page":"API Reference","title":"Terrarium.ConstantAerodynamicResistance","text":"struct ConstantAerodynamicResistance{NF} <: Terrarium.AbstractEvapotranspirativeResistance\n\nDummy implementation of the aerodynamic resistance that simply returns a constant value.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantAlbedo","page":"API Reference","title":"Terrarium.ConstantAlbedo","text":"struct ConstantAlbedo{NF} <: Terrarium.AbstractAlbedo\n\nProperties:\n\nalbedo::Any: Surface albedo, i.e. ratio of outgoing to incoming shortwave radiation [-]\nemissivity::Any: Surface emissivity, i.e. fraction of thermal radiation emitted from the surface [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantHydraulics","page":"API Reference","title":"Terrarium.ConstantHydraulics","text":"ConstantHydraulics{NF} <: AbstractSoilHydraulics\n\nRepresents a simple case where soil hydraulic properties are given as constant values. This is mostly provided just for testing, although it may be useful in certain cases where direct measurements of hydraulic properites are available.\n\nProperties:\n\ncond_unsat::Any: Unsaturated hydraulic conductivity formulation; defaults to cond_sat\ncond_sat::Any: Hydraulic conductivity at saturation [m/s]\nporosity::Any: Prescribed soil porosity [-]\nfield_capacity::Any: Prescribed field capacity [-]\nwilting_point::Any: Prescribed wilting point [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantSoilCarbonDensity","page":"API Reference","title":"Terrarium.ConstantSoilCarbonDensity","text":"struct ConstantSoilCarbonDensity{NF} <: Terrarium.AbstractSoilBiogeochemistry{NF}\n\nNaive implementation of soil biogeochemistry that just assumes there to be a constant organic content in all soil layers.\n\nProperties:\n\nœÅ_soc::Any: Soil organic carbon density [kg/m^3]\nœÅ_org::Any: Pure organic matter density [kg/m^3]\npor_org::Any: Natural porosity of organic material\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.DefaultInitializer","page":"API Reference","title":"Terrarium.DefaultInitializer","text":"Marker type for a no-op initializer that leaves all Fields set to their default values.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.DiagnosedRadiativeFluxes","page":"API Reference","title":"Terrarium.DiagnosedRadiativeFluxes","text":"struct DiagnosedRadiativeFluxes <: Terrarium.AbstractRadiativeFluxes\n\nComputes outgoing shortwave and longwave radiation according to separately specified schemes for the albedo, skin temperature, and atmospheric inputs.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.DiagnosedTurbulentFluxes","page":"API Reference","title":"Terrarium.DiagnosedTurbulentFluxes","text":"struct DiagnosedTurbulentFluxes{ER<:Terrarium.AbstractEvapotranspirativeResistance, LF<:Terrarium.AbstractSoilMoistureLimitingFactor} <: Terrarium.AbstractTurbulentFluxes\n\nRepresents the standard case where the turbulent (sensible and latent) heat fluxes are diagnosed from atmosphere and soil conditions.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.EnergyTemperatureClosure","page":"API Reference","title":"Terrarium.EnergyTemperatureClosure","text":"EnergyTemperatureClosure\n\nDefines the constitutive relationship between temperature and the internal energy, U, of the system, i.e:\n\nU(T) = Ttimes C(T) - L_f theta_wi (1 - F(T))\n\nwhere T is temperature, C(T) is the temperature-dependent heat capacity, L_f is the volumetric latent heat of fusion, and F(T) is the constitutive relation between temperature and the unfrozen fraction of pore water. Note that, under this formulation, zero energy corresponds to 0¬∞C with no ice, i.e. all pore water fully thawed.\n\nThe closure relation is defined as being a mapping from the conserved quantity (energy) to the continuous quantity (temperature), i.e. the inverse of U(T).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ExplicitTwoPhaseHeatConduction","page":"API Reference","title":"Terrarium.ExplicitTwoPhaseHeatConduction","text":"struct ExplicitTwoPhaseHeatConduction{ET} <: Terrarium.AbstractHeatOperator\n\nRepresents an explicit formulation of the two-phase heat conduction operator in 1D:\n\nfracpartial U(Tphi)partial t = nabla cdot kappa(T)nabla_x T(xt)\n\nwhere T is temperature [K], U is internal energy [J m‚Åª¬≥], and kappa is the thermal conductivity [W m K‚Åª¬π]. The closure field represents the temperature-energy closure U(Tphi) which relates temperature to internal energy via an arbitrary set of additional parameters phi which are determined by the model configuration.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldBCs","page":"API Reference","title":"Terrarium.FieldBCs","text":"Alias for a NamedTuple of FieldBC types where the keys correspond to field/variable names.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldInitializers","page":"API Reference","title":"Terrarium.FieldInitializers","text":"Creates a new FieldInitializers from the given keyword arguments where each argument corresponds to an initializer function or value for specific state variable defined in the model. The initializers can be any function, value, array, or Field that would be a valid input x to Oceananigans.set!(field, x). Optionally, FieldInitializers can wrap another \n\nFieldInitializers(temperature=(x,z) -> sin(2œÄ*z), saturation_water_ice=0)\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldInitializers-2","page":"API Reference","title":"Terrarium.FieldInitializers","text":"struct FieldInitializers{names, Init<:Terrarium.AbstractInitializer, FieldInits} <: Terrarium.AbstractInitializer\n\nContainer type that bundles one or more initializer functions for individual state variable fields into a single AbstractInitializer. FieldInitializers can also optionally wrap another AbstractInitializer type whose field initializers will be merged with those in vars.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldInputSource","page":"API Reference","title":"Terrarium.FieldInputSource","text":"struct FieldInputSource{NF, VD<:Terrarium.VarDims, names} <: InputSource{NF}\n\nInput source that defines input state variables with the given names which can then be directly modified by the user.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldTimeSeriesInputSource","page":"API Reference","title":"Terrarium.FieldTimeSeriesInputSource","text":"struct FieldTimeSeriesInputSource{NF, VD<:Terrarium.VarDims, names, FTS<:Tuple{Vararg{FieldTimeSeries{LX, LY, LZ, TI, K, I, D, G, NF} where {LX, LY, LZ, TI, K, I, D, G}}}} <: InputSource{NF}\n\nInput source that reads input fields from pre-specified Oceananigans FieldTimeSeries.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ForwardEuler","page":"API Reference","title":"Terrarium.ForwardEuler","text":"struct ForwardEuler{NF} <: Terrarium.AbstractTimeStepper{NF}\n\nSimple forward Euler time stepping scheme.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Heun","page":"API Reference","title":"Terrarium.Heun","text":"struct Heun{NF, Stage} <: Terrarium.AbstractTimeStepper{NF}\n\nSimple forward 2nd order Heun / improved Euler time stepping scheme.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.HomogeneousSoil","page":"API Reference","title":"Terrarium.HomogeneousSoil","text":"struct HomogeneousSoil{NF} <: Terrarium.AbstractStratigraphy{NF}\n\nRepresents a soil stratigraphy of well mixed material with homogeneous soil texture.\n\nProperties:\n\ntexture::SoilTexture: Material composition of mineral soil componnet\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ImplicitSkinTemperature","page":"API Reference","title":"Terrarium.ImplicitSkinTemperature","text":"struct ImplicitSkinTemperature{NF} <: Terrarium.AbstractSkinTemperature\n\nScheme for an implicit skin temperature T_0 satisfying:\n\nR_textnet(T_0) = H_s(T_0) + H_l(T_0) + G(T_0 T_1)\n\nwhere R_textnet is the net radiation budget, H_s is the sensible heat flux, H_l is the latent heat flux from sublimation and evapotranspiration, G is the ground heat flux, and T_1 is the ground temperature, or temperature of the uppermost subsurface (soil or snow) layer.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.InputSource","page":"API Reference","title":"Terrarium.InputSource","text":"abstract type InputSource{NF}\n\nBase type for input data sources. Implementations of InputSource are free to load data from any arbitrary backend but are required to implement the update_inputs!(fields, ::InputSource, ::Clock) method. Implementations should additionally provide a constructor as a dispatch of InputSource.\n\nThe type argument NF corresponds to the numeric type of the input data.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.InputSource-Union{Tuple{NF}, Tuple{Type{NF}, Vararg{Symbol}}} where NF","page":"API Reference","title":"Terrarium.InputSource","text":"InputSource(::Type{NF}, names::Symbol...; dims = XY())\n\nCreate a FieldInputSource with the given numeric type and input variable names.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.InputSources","page":"API Reference","title":"Terrarium.InputSources","text":"Container type for wrapping multiple InputSources.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.InputVariable","page":"API Reference","title":"Terrarium.InputVariable","text":"struct InputVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units, Var<:Terrarium.Variable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}, DT<:IntervalSets.AbstractInterval} <: Terrarium.AbstractProcessVariable{name, VD<:Terrarium.VarDims}\n\nRepresents an input (e.g. forcing) variable with the given name and spatial dims.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.InverseQuadratic","page":"API Reference","title":"Terrarium.InverseQuadratic","text":"The inverse quadratic (or \"quadratic parallel\") bulk thermal conductivity formula (Cosenza et al. 2003):\n\nk = sum_i=1^N Œ∏·µ¢sqrtk·µ¢^2\n\nCosenza, P., Gu√©rin, R., and Tabbagh, A.: Relationship between thermal conductivity and water content of soils using numerical modelling, European Journal of Soil Science, 54, 581‚Äì588, https://doi.org/10.1046/j.1365-2389.2003.00539.x, 2003.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.LUEPhotosynthesis","page":"API Reference","title":"Terrarium.LUEPhotosynthesis","text":"struct LUEPhotosynthesis{NF} <: Terrarium.AbstractPhotosynthesis\n\nPhotosynthesis implementation from PALADYN (Willeit 2016) for C3 PFTs following the general light use efficiency model described in Haxeltine and Prentice 1996.\n\nAuthors: Maha Badri and Matteo Willeit\n\nProperties:\n\nœÑ25::Any: Value of œÑ at 25¬∞C\nKc25::Any: Value of Kc at 25¬∞C\nKo25::Any: Value of Ko at 25¬∞C\nq10_œÑ::Any: q10 for temperature-sensitive parameter œÑ\nq10_Kc::Any: q10 for temperature-sensitive parameter Kc\nq10_Ko::Any: q10 for temperature-sensitive parameter Ko\nŒ±_leaf::Any: Leaf albedo in PAR range [-]\ncq::Any: Conversion factor for solar radiation at 550 nm from J/m¬≤ to mol/m¬≤ [mol/J]\nk_ext::Any: Extinction coefficient for radiation through vegetation [-]\nŒ±_a::Any: Fraction of PAR assimilated at ecosystem level, relative to leaf level [-]\nt_CO2_high::Any: Parameter, PFT specific [¬∞C]\nt_CO2_low::Any: Parameter, PFT specific [¬∞C]\nt_photos_high::Any: Parameter, PFT specific [¬∞C]\nt_photos_low::Any: Parameter, PFT specific [¬∞C]\nŒ±_C3::Any: Intrinsic quantum efficiency of CO2 uptake in C3 plants [mol/mol]\nC_mass::Any: Atomic mass of carbon [gC/mol]\nŒ∏_r::Any: Shape parameter [-]\nday_length::Any: Day length [h/day]\nsec_day::Any: Seconds per day [s/day]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.LengthQuantity","page":"API Reference","title":"Terrarium.LengthQuantity","text":"Alias for numeric Quantity with type NF and units U.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.MedlynStomatalConductance","page":"API Reference","title":"Terrarium.MedlynStomatalConductance","text":"struct MedlynStomatalConductance{NF} <: Terrarium.AbstractStomatalConductance\n\nStomatal conductance implementation from PALADYN (Willeit 2016) following the optimal stomatal conductance model (Medlyn et al. 2011).\n\nAuthors: Maha Badri and Matteo Willeit\n\nProperties:\n\ng1::Any: Parameter in optimal stomatal conductance formulation, Lin et al. 2015 [-], PFT specific\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ModelIntegrator","page":"API Reference","title":"Terrarium.ModelIntegrator","text":"struct ModelIntegrator{NF, Arch<:Oceananigans.Architectures.AbstractArchitecture, Grid<:Terrarium.AbstractLandGrid{NF, Arch<:Oceananigans.Architectures.AbstractArchitecture}, TimeStepper<:Terrarium.AbstractTimeStepper{NF}, Model<:Terrarium.AbstractModel{NF, Grid<:Terrarium.AbstractLandGrid{NF, Arch<:Oceananigans.Architectures.AbstractArchitecture}}, StateVars<:Terrarium.AbstractStateVariables, Inputs<:InputSources} <: Oceananigans.AbstractModel{TimeStepper<:Terrarium.AbstractTimeStepper{NF}, Arch<:Oceananigans.Architectures.AbstractArchitecture}\n\nRepresents a \"integrator\" for a simulation of a given model. ModelIntegrator consists of a clock, a model, and an initialized StateVariables data structure, as well as a stage for the timestepper and any relevant inputs provided by a corresponding InputProvider. The ModelIntegrator implements the Oceananigans.AbstractModel interface and can thus be treated as a \"model\" in Oceananigans Simulations and output reading/writing utilities.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Namespace","page":"API Reference","title":"Terrarium.Namespace","text":"struct Namespace{name, Vars}\n\nRepresents a new variable namespace, typically from a subcomponent of the model.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.NoFlow","page":"API Reference","title":"Terrarium.NoFlow","text":"Represents a hydrology scheme where soil water is immobile.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNAutotrophicRespiration","page":"API Reference","title":"Terrarium.PALADYNAutotrophicRespiration","text":"struct PALADYNAutotrophicRespiration{NF} <: Terrarium.AbstractAutotrophicRespiration\n\nAutotrophic respiration implementation from PALADYN (Willeit 2016).\n\nAuthors: Maha Badri and Matteo Willeit\n\nProperties:\n\ncn_sapwood::Any: Sapwood parameter\ncn_root::Any: Root parameter\naws::Any: Ratio of total to respiring stem carbon, Cox 2001, PFT specific [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNCarbonDynamics","page":"API Reference","title":"Terrarium.PALADYNCarbonDynamics","text":"struct PALADYNCarbonDynamics{NF} <: Terrarium.AbstractVegetationCarbonDynamics\n\nVegetation carbon dynamics implementation following PALADYN (Willeit 2016) but considering only the sum of the vegetation carbon pools. The subsequent splitting into Cleaf, Cstem, C_root is not implemented for now.\n\nAuthors: Maha Badri \n\nProperties:\n\nSLA::Any: Specific leaf area (Kattge et al. 2011) [m¬≤/kgC], PFT specific\nawl::Any: Allometric coefficient, modified from Cox 2001 to account for bwl=1 [kgC/m¬≤], PFT specific\nLAI_min::Any: Minimum Leaf Area Index modified from Clark et al. 2011 [m¬≤/m¬≤], PFT specific\nLAI_max::Any: Maximum Leaf Area Index modified from Clark et al. 2011 [m¬≤/m¬≤], PFT specific\nŒ≥L::Any: Leaf turnover rate (Kattge et al. 2011) [1/year], PFT specific\nŒ≥R::Any: Root turnover rate [1/year], PFT specific\nŒ≥S::Any: Stem turnover rate modified from Clark et al. 2011 [1/year], PFT specific\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNPhenology","page":"API Reference","title":"Terrarium.PALADYNPhenology","text":"struct PALADYNPhenology{NF} <: Terrarium.AbstractPhenology\n\nVegetation phenology implementation from PALADYN (Willeit 2016).\n\nAuthors: Maha Badri and Matteo Willeit\n\nProperties:\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNVegetationDynamics","page":"API Reference","title":"Terrarium.PALADYNVegetationDynamics","text":"struct PALADYNVegetationDynamics{NF} <: Terrarium.AbstractVegetationDynamics\n\nVegetation dynamics implementation following PALADYN (Willeit 2016) for a single PFT based on the Lotka‚ÄìVolterra approach.\n\nAuthors: Maha Badri \n\nProperties:\n\nŒΩ_seed::Any: Vegetation seed fraction [-]\nŒ≥v_min::Any: Minimum vegetation disturbance rate [1/year]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PhysicalConstants","page":"API Reference","title":"Terrarium.PhysicalConstants","text":"struct PhysicalConstants{NF}\n\nA collection of general physical constants that do not (usually) need to be varied in parameter calibration.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedAlbedo","page":"API Reference","title":"Terrarium.PrescribedAlbedo","text":"struct PrescribedAlbedo <: Terrarium.AbstractAlbedo\n\nProperties:\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedAtmosphere","page":"API Reference","title":"Terrarium.PrescribedAtmosphere","text":"struct PrescribedAtmosphere{NF, tracernames, Humid<:Terrarium.AbstractHumidity, Precip<:Terrarium.AbstractPrecipitation, IncomingRad<:Terrarium.AbstractIncomingRadiation, Tracers<:(NamedTuple{tracernames, <:Tuple{Vararg{TracerGas}}})} <: Terrarium.AbstractAtmosphere{Precip<:Terrarium.AbstractPrecipitation, IncomingRad<:Terrarium.AbstractIncomingRadiation, Humid<:Terrarium.AbstractHumidity}\n\nRepresents prescribed atmospheric conditions given by the following input variables:     - Air temperature     - Humidity     - Atmospheric pressure     - Windspeed     - Precipitation     - Solar radiation     - Zero or more tracer gases (defaults to CO2 only)\n\nPrecpitation and solar radiation are specified according to specialized subtypes which dictate the form of the input data; for precipitation, this defaults to TwoPhasePrecipitation, i.e. rain- and snowfall given as separate inputs, while for solar radiation, the default is LongShortWaveRadiation which partitions downwelling radiation into the common short- and long wave lengths representing solar and thermal (infrared) radiation.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedRadiativeFluxes","page":"API Reference","title":"Terrarium.PrescribedRadiativeFluxes","text":"struct PrescribedRadiativeFluxes <: Terrarium.AbstractRadiativeFluxes\n\nRepresents the simplest scheme for the radiative budget where outgoing shortwave and longwave radiation are given as input variables. Net radiation is diagnosed by summing all radiative fluxes:\n\nR_textnet = S_uparrow - S_downarrow + L_uparrow - L_downarrow\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedSkinTemperature","page":"API Reference","title":"Terrarium.PrescribedSkinTemperature","text":"struct PrescribedSkinTemperature <: Terrarium.AbstractSkinTemperature\n\nSimple scheme for prescribed skin temperatures from input variables.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedTurbulentFluxes","page":"API Reference","title":"Terrarium.PrescribedTurbulentFluxes","text":"struct PrescribedTurbulentFluxes <: Terrarium.AbstractTurbulentFluxes\n\nRepresents the simplest case where the turbulent (sensible and latent) heat fluxes are prescribed via input variables.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrognosticVariable","page":"API Reference","title":"Terrarium.PrognosticVariable","text":"struct PrognosticVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units, Var<:Terrarium.Variable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}, CL<:Union{Nothing, Terrarium.AbstractClosureRelation}, TV<:Union{Nothing, AuxiliaryVariable}, DT<:IntervalSets.AbstractInterval} <: Terrarium.AbstractProcessVariable{name, VD<:Terrarium.VarDims}\n\nRepresents a prognostic state variable with the given name and spatial dims.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.RichardsEq","page":"API Reference","title":"Terrarium.RichardsEq","text":"RichardsEq{PS} <: AbstractVerticalFlow\n\nOperator for soil hydrology corresponding to the Richardson-Richards equation for variably saturated flow in porous media.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilComposition","page":"API Reference","title":"Terrarium.SoilComposition","text":"struct SoilComposition{NF} <: Terrarium.AbstractSoilComposition\n\nRepresents the material composition of an elementary volume of soil. The volume is decomposed into the key constitutents of water, ice, air, and a mixture of organic and mineral solid material. \n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilEnergyBalance","page":"API Reference","title":"Terrarium.SoilEnergyBalance","text":"struct SoilEnergyBalance{NF, HeatOperator<:Terrarium.AbstractHeatOperator, FC<:FreezeCurves.FreezeCurve, ThermalProps<:(SoilThermalProperties{NF})} <: Terrarium.AbstractSoilEnergyBalance{NF}\n\nStandard implementation of the soil energy balance accounting for freezing and thawing of pore water/ice.\n\nProperties:\n\noperator::Terrarium.AbstractHeatOperator: Heat transport operator\nthermal_properties::SoilThermalProperties: Soil thermal properties\nfreezecurve::Val{FC} where FC<:FreezeCurves.FreezeCurve: Freeze curve type constructor\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilHeatCapacities","page":"API Reference","title":"Terrarium.SoilHeatCapacities","text":"struct SoilHeatCapacities{NF}\n\nProperties:\n\nwater::Any\nice::Any\nair::Any\nmineral::Any\norganic::Any\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilHydraulicsSURFEX","page":"API Reference","title":"Terrarium.SoilHydraulicsSURFEX","text":"struct SoilHydraulicsSURFEX{NF, UnsatK} <: Terrarium.AbstractSoilHydraulics{NF, UnsatK}\n\nSURFEX parameterization of mineral soil porosity (Masson et al. 2013).\n\nProperties:\n\ncond_unsat::Any: Unsaturated hydraulic conductivity formulation; defaults to cond_sat\ncond_sat::Any: Hydraulic conductivity at saturation [m/s]\nporosity::Any: Base porosity of soil without any sand [-]\nporosity_sand_coef::Any: Linear coeficient of porosity adjustment due to sand content [-]\nwilting_point_coef::Any: Linear coeficient of wilting point adjustment due to clay content [-]\nfield_capacity_coef::Any: Linear coeficient of field capacity adjustment due to clay content [-]\nfield_capacity_exp::Any: Exponent of field capacity adjustment due to clay content [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilHydrology","page":"API Reference","title":"Terrarium.SoilHydrology","text":"struct SoilHydrology{NF, VerticalFlow<:Terrarium.AbstractVerticalFlow, Runoff<:Terrarium.AbstractSoilRunoff, SoilET<:Terrarium.AbstractSoilET, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})} <: Terrarium.AbstractSoilHydrology{NF}\n\nProperties:\n\nvertflow::Terrarium.AbstractVerticalFlow: Soil water vertical flow operator\nrunoff::Terrarium.AbstractSoilRunoff: Soil subsurface runoff scheme\nevapotranspiration::Terrarium.AbstractSoilET: Scheme for distributing ET fluxes in the root zone\nhydraulic_properties::Terrarium.AbstractSoilHydraulics: Soil hydraulic properties parameterization\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilModel","page":"API Reference","title":"Terrarium.SoilModel","text":"struct SoilModel{NF, GridType<:(Terrarium.AbstractLandGrid{NF}), Stratigraphy<:Terrarium.AbstractStratigraphy, SoilEnergy<:Terrarium.AbstractSoilEnergyBalance, SoilHydrology<:Terrarium.AbstractSoilHydrology, Biogeochemistry<:Terrarium.AbstractSoilBiogeochemistry, Constants<:PhysicalConstants{NF}, Initializer<:Terrarium.AbstractInitializer} <: Terrarium.AbstractSoilModel{NF, GridType<:(Terrarium.AbstractLandGrid{NF})}\n\nGeneral implementation of a 1D column model of soil energy, water, and carbon transport.\n\nProperties:\n\ngrid::Terrarium.AbstractLandGrid: Spatial grid type\nstrat::Terrarium.AbstractStratigraphy: Stratigraphy of the soil\nenergy::Terrarium.AbstractSoilEnergyBalance: Soil energy balance\nhydrology::Terrarium.AbstractSoilHydrology: Soil hydrology/water balance\nbiogeochem::Terrarium.AbstractSoilBiogeochemistry: Soil biogeochemistry\nconstants::PhysicalConstants: Physical constants\ninitializer::Terrarium.AbstractInitializer: State variable initializer\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilRunoff","page":"API Reference","title":"Terrarium.SoilRunoff","text":"struct SoilRunoff{SR, IF, DR} <: Terrarium.AbstractSoilRunoff\n\nGeneric scheme for respresenting soil/subsurface runoff as a composition of three components: excess infiltration, interflow, and drainage.\n\nNot yet implemented.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilTexture","page":"API Reference","title":"Terrarium.SoilTexture","text":"SoilTexture{NF}\n\nRepresents soil texture as a fractional mixture of sand, silt, and clay.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilThermalConductivities","page":"API Reference","title":"Terrarium.SoilThermalConductivities","text":"struct SoilThermalConductivities{NF}\n\nProperties:\n\nwater::Any\nice::Any\nair::Any\nmineral::Any\norganic::Any\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilThermalProperties","page":"API Reference","title":"Terrarium.SoilThermalProperties","text":"struct SoilThermalProperties{NF, CondWeighting}\n\nProperties:\n\ncond::SoilThermalConductivities: Thermal conductivities for all constituents\ncond_bulk::Any: Thermal conductivity mixing scheme\nheatcap::SoilHeatCapacities: Thermal conductivities for all constituents\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.StateVariables","page":"API Reference","title":"Terrarium.StateVariables","text":"struct StateVariables{NF, prognames, tendnames, auxnames, inputnames, nsnames, ProgFields, TendFields, AuxFields, InputFields, Namespaces, ClockType} <: Terrarium.AbstractStateVariables\n\nContainer type for all Fields corresponding to state variables defined by a model. StateVariables partitions the fields into three categories: prognostic, tendencies, and auxiliary. Prognostic variables are those which characterize the state of the system and are assigned tendencies to be integrated by the timestepper. Auxiliary fields are additional state variables derived from the prognostic state variables but which are conditionally independent of their values at the previous time step given the current prognostic state. It is worth noting that tendencies are also treated internally as auxiliary variables; however, they are assigned their own category here since they need to be handled separately by the timestepping scheme.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SurfaceEvaporation","page":"API Reference","title":"Terrarium.SurfaceEvaporation","text":"SurfaceEvaporation <: AbstractSoilET\n\nEvapotranspiration scheme for bare soils that allocates the full latent heat flux to evaporation from the topmost soil layer.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.TracerGas","page":"API Reference","title":"Terrarium.TracerGas","text":"Generic type representing the concentration of a particular tracer gas in the atmosphere.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.TypeVal","page":"API Reference","title":"Terrarium.TypeVal","text":"Alias for Type{Val{x}}\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.UnsatKLinear","page":"API Reference","title":"Terrarium.UnsatKLinear","text":"struct UnsatKLinear{RetentionCurve<:FreezeCurves.SWRC} <: Terrarium.AbstractUnsatK\n\nSimple formulation of hydraulic conductivity as a linear function of the liquid water saturated fraction, i.e. soil.water / (soil.water + soil.ice + soil.air).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.UnsatKVanGenuchten","page":"API Reference","title":"Terrarium.UnsatKVanGenuchten","text":"struct UnsatKVanGenuchten{NF, RetentionCurve<:FreezeCurves.VanGenuchten} <: Terrarium.AbstractUnsatK\n\nFormulation of hydraulic conductivity as a function of saturated hydraulic conductivity K_sat and volumetric fractions, assumed to include those of water, ice, and air.\n\nSee van Genuchten (1980) and Westermann et al. (2023).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Variable","page":"API Reference","title":"Terrarium.Variable","text":"struct Variable{name, VD, UT} <: Terrarium.AbstractVariable{name, VD}\n\nRepresents a generic state variable with the given name and spatial dims.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Variables","page":"API Reference","title":"Terrarium.Variables","text":"struct Variables{ProgVars, TendVars, AuxVars, InputVars, Namespaces}\n\nContainer for abstract state variable definitions. Automatically sorts and merges all variables and namespaces passed into the constructor.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.VegetationModel","page":"API Reference","title":"Terrarium.VegetationModel","text":"struct VegetationModel{NF, Photosynthesis<:Terrarium.AbstractPhotosynthesis, StomatalConducatance<:Terrarium.AbstractStomatalConductance, AutotrophicRespiration<:Terrarium.AbstractAutotrophicRespiration, CarbonDynamics<:Terrarium.AbstractVegetationCarbonDynamics, VegetationDynamics<:Terrarium.AbstractVegetationDynamics, Phenology<:Terrarium.AbstractPhenology, GridType<:(Terrarium.AbstractLandGrid{NF}), Constants<:PhysicalConstants{NF}, Initializer<:Terrarium.AbstractInitializer} <: Terrarium.AbstractVegetationModel{NF, GridType<:(Terrarium.AbstractLandGrid{NF})}\n\nModel for natural (unmanaged) vegetation processes for a single plant functional type (PFT). Multiple PFTs can be later handled with a TiledVegetationModel type that composes multiple VegetationModels with different parameters for each PFT.\n\nProperties:\n\ngrid::Terrarium.AbstractLandGrid: Spatial grid type\nphotosynthesis::Terrarium.AbstractPhotosynthesis: Photosynthesis scheme\nstomatal_conductance::Terrarium.AbstractStomatalConductance: Stomatal conducantance scheme\nautotrophic_respiration::Terrarium.AbstractAutotrophicRespiration: Autotrophic respiration scheme\nphenology::Terrarium.AbstractPhenology: Phenology scheme\ncarbon_dynamics::Terrarium.AbstractVegetationCarbonDynamics: Vegetation carbon pool dynamics\nvegetation_dynamics::Terrarium.AbstractVegetationDynamics: Vegetation population density or coverage fraction dynamics\nconstants::PhysicalConstants: Physical constants\ninitializer::Terrarium.AbstractInitializer: State variable initializer\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.XY","page":"API Reference","title":"Terrarium.XY","text":"XY <: VarDims\n\nIndicator type for variables that should be assigned a 2D (lateral only) field on their associated grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.XYZ","page":"API Reference","title":"Terrarium.XYZ","text":"XYZ <: VarDims\n\nIndicator type for variables that should be assigned a 3D field on their associated grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{StateVariables}","page":"API Reference","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"Invoke fill_halo_regions! for all fields in state.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.BoundaryConditions.getbc-Union{Tuple{name}, Tuple{Terrarium.Variable{name}, Integer, Integer, Oceananigans.Grids.AbstractGrid, Any, StateVariables}} where name","page":"API Reference","title":"Oceananigans.BoundaryConditions.getbc","text":"Implementation of Oceananigans.BoundaryConditions.getbc for variable placeholders that retrieves the input Field from state and returns the value at the given index.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.Simulations.run!-Tuple{ModelIntegrator}","page":"API Reference","title":"Oceananigans.Simulations.run!","text":"run!(integrator; steps, period, Œît)\n\n\nRun the simulation for steps or a given time period with timestep size Œît (in seconds or Dates.Period).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.TimeSteppers.update_state!-Tuple{StateVariables, Terrarium.AbstractModel, InputSources}","page":"API Reference","title":"Oceananigans.TimeSteppers.update_state!","text":"update_state!(state::StateVariables, model::AbstractModel, inputs::InputSources; compute_tendencies = true)\n\nUpdate the state for the given model and inputs; this includes calling update_inputs! and fill_halo_regions! followed by compute_auxiliary! and compute_tendencies!, if compute_tendencies = true.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.AmbientCO2","page":"API Reference","title":"Terrarium.AmbientCO2","text":"Creates a TracerGas for ambient CO2 with concentration prescribed by an input variable with the given name.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.ConstantInitialSoilTemperature-Tuple{Any}","page":"API Reference","title":"Terrarium.ConstantInitialSoilTemperature","text":"Creates a constant soil temperature initializer.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.FreeDrainage-Tuple{}","page":"API Reference","title":"Terrarium.FreeDrainage","text":"Alias for PrescribedGradient representing a Neumann-type zero pressure gradient at the bottom of the soil column, thereby allowing free drainage of water.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.GeothermalHeatFlux","page":"API Reference","title":"Terrarium.GeothermalHeatFlux","text":"Alias for FluxBoundaryCondition on internal_energy with name geothermal_heat_flux representing the geothermal heat flux at the bottom boundary of the soil column.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.GroundHeatFlux","page":"API Reference","title":"Terrarium.GroundHeatFlux","text":"Alias for FluxBoundaryCondition on internal_energy with name ground_heat_flux representing the net ground heat flux at the soil surface.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.ImpermeableBoundary-Tuple{}","page":"API Reference","title":"Terrarium.ImpermeableBoundary","text":"Alias for NoFlux representing a zero-flux bottom boundary condition for water flow (prognostic variable saturation_water_ice).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.InfiltrationFlux","page":"API Reference","title":"Terrarium.InfiltrationFlux","text":"Alias for PrescribedFlux with name infiltration representing liquid water infiltration at the soil surface.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.PiecewiseLinearInitialSoilTemperature-Tuple{Vararg{Pair{<:Unitful.Quantity{NF, ùêã, U} where {NF, U<:Unitful.Units}}}}","page":"API Reference","title":"Terrarium.PiecewiseLinearInitialSoilTemperature","text":"Creates a piecwise linear temperature initializer from the given knots.\n\ninitializer = PiecewiseLinearInitialSoilTemperature(\n    0.0u\"m\" => 5.0, # always in ¬∞C!\n    0.5u\"m\" => 2.0,\n    1.0u\"m\" => 1.0,\n    10.0u\"m\" => 1.5,\n    ...\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.PrescribedBottomTemperature","page":"API Reference","title":"Terrarium.PrescribedBottomTemperature","text":"Alias for ValueBoundaryCondition on top temperature (in ¬∞C) with the given variable name.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.PrescribedSurfaceTemperature","page":"API Reference","title":"Terrarium.PrescribedSurfaceTemperature","text":"Alias for ValueBoundaryCondition on top temperature (in ¬∞C) with the given variable name.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.QuasiThermalSteadyState-Tuple{Any, Any, Any}","page":"API Reference","title":"Terrarium.QuasiThermalSteadyState","text":"Computes a linear temperature profile in quasi-steady state based on the given surface temperature, geothermal heat flux, and bulk thermal conductivity.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.TracerGases-Tuple{Vararg{TracerGas}}","page":"API Reference","title":"Terrarium.TracerGases","text":"Creates a NamedTuple from the given tracer gas types.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.adjust_saturation_profile!-Tuple{Any}","page":"API Reference","title":"Terrarium.adjust_saturation_profile!","text":"adjust_saturation_profile!(\n    state,\n    grid,\n    ::SoilHydrology{NF}\n)\n\nKernel for adjusting saturation profiles to account for oversaturation due to numerical error. This implementation scans over the saturation profiles at each lateral grid cell and redistributes excess water upward layer-by-layer until reaching the topmost layer, where any remaining excess water is added to the surface_excess_water pool.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.air_pressure-Tuple{Any, Any, Any, PrescribedAtmosphere}","page":"API Reference","title":"Terrarium.air_pressure","text":"air_pressure(i, j, state, ::PrescribedAtmosphere)\n\nRetrieve or compute the air pressure at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.air_temperature-Tuple{Any, Any, Any, PrescribedAtmosphere}","page":"API Reference","title":"Terrarium.air_temperature","text":"air_temperature(i, j, state, ::PrescribedAtmosphere)\n\nRetrieve or compute the air temperature at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.albedo","page":"API Reference","title":"Terrarium.albedo","text":"albedo(i, j, state, ::AbstractAlbedo)\n\nReturn the current albedo at the given indices.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.auxiliary-Tuple{Symbol, Terrarium.VarDims}","page":"API Reference","title":"Terrarium.auxiliary","text":"auxiliary(name, dims; units, domain, desc)\n\n\nConvenience constructor method for AuxiliaryVariable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.celsius_to_kelvin-Tuple{PhysicalConstants, Any}","page":"API Reference","title":"Terrarium.celsius_to_kelvin","text":"celsius_to_kelvin(c::PhysicalConstants, T)\n\nConvert the given temperature in ¬∞C to Kelvin based on the constant Tref.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.closure!-Tuple{Any, Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.closure!","text":"closure!(state, model::AbstractModel)\n\nApply each closure relation defined for the given model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.closurevar","page":"API Reference","title":"Terrarium.closurevar","text":"closurevar(::AbstractClosureRelation)\n\nReturn an AuxiliaryVariable corresponding to the closure variable defined by the given closure relation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_APAR-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_APAR","text":"compute_APAR(photo, swdown, LAI)\n\n\nComputes absorbed PAR limited by the fraction of PAR assimilated at ecosystem level APAR [mol/m¬≤/day], Eq. 62, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Ag-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 5}}} where NF","page":"API Reference","title":"Terrarium.compute_Ag","text":"compute_Ag(photo, c_1, c_2, APAR, Vc_max, Œ≤)\n\n\nComputes the daily gross photosynthesis Ag [gC/m¬≤/day], Eqn 2, Haxeltine & Prentice 1996\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_And-Union{Tuple{NF}, Tuple{LUEPhotosynthesis, Vararg{NF, 6}}} where NF","page":"API Reference","title":"Terrarium.compute_And","text":"compute_And(photo, c_1, c_2, APAR, Vc_max, Œ≤, Rd)\n\n\nComputes the total daytime net photosynthesis And [gC/m¬≤/day], Eqn 19, Haxeltine & Prentice 1996 + Eq. 65, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_C_veg_tend-Union{Tuple{NF}, Tuple{PALADYNCarbonDynamics{NF}, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_C_veg_tend","text":"compute_C_veg_tend(vegcarbon_dynamics, LAI_b, NPP)\n\n\nComputes the C_veg tendency based on NPP and the balanced Leaf Area Index LAI_b, Eq. 72, PALADYN (Willeit 2016) \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_JE_JC-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 4}}} where NF","page":"API Reference","title":"Terrarium.compute_JE_JC","text":"compute_JE_JC(photo, c_1, c_2, APAR, Vc_max)\n\n\nComputes the PAR-limited and the rubisco-activity-limited photosynthesis rates JE and JC [gC/m¬≤/day], Eqn 3+5, Haxeltine & Prentice 1996.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_LAI-Union{Tuple{NF}, Tuple{PALADYNPhenology{NF}, NF}} where NF","page":"API Reference","title":"Terrarium.compute_LAI","text":"compute_LAI(phenol, LAI_b)\n\n\nComputes LAI, based on the balanced Leaf Area Index LAI_b:\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_NPP-Tuple{PALADYNAutotrophicRespiration, Any, Any}","page":"API Reference","title":"Terrarium.compute_NPP","text":"compute_NPP(autoresp, GPP, Ra)\n\n\nComputes Net Primary Productivity NPP as the difference between Gross Primary Production GPP and autotrophic respiration Ra in [kgC/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_PAR-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, NF}} where NF","page":"API Reference","title":"Terrarium.compute_PAR","text":"compute_PAR(photo, swdown)\n\n\nComputes NET Photosynthetically Active Radiation PAR [mol/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Ra-Tuple{PALADYNAutotrophicRespiration, PALADYNCarbonDynamics, Vararg{Any, 5}}","page":"API Reference","title":"Terrarium.compute_Ra","text":"compute_Ra(\n    autoresp,\n    vegcarbon_dynamics,\n    T_air,\n    Rd,\n    phen,\n    C_veg,\n    GPP\n)\n\n\nComputes autotrophic respiration Ra as the sum of maintenance respiration Rm and growth respiration Rg in [kgC/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Rd-Tuple{LUEPhotosynthesis, Any, Any}","page":"API Reference","title":"Terrarium.compute_Rd","text":"compute_Rd(photo, Vc_max, Œ≤)\n\n\nComputes the daily leaf respiration Rd [gC/m¬≤/day], Eqn 10, Haxeltine & Prentice 1996 and Eq. 10 PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Rg-Union{Tuple{NF}, Tuple{PALADYNAutotrophicRespiration{NF}, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_Rg","text":"compute_Rg(autoresp, GPP, Rm)\n\n\nComputes growth respiration Rg in [kgC/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Rm-Union{Tuple{NF}, Tuple{PALADYNAutotrophicRespiration{NF}, PALADYNCarbonDynamics{NF}, Vararg{Any, 4}}} where NF","page":"API Reference","title":"Terrarium.compute_Rm","text":"compute_Rm(\n    autoresp,\n    vegcarbon_dynamics,\n    T_air,\n    Rd,\n    phen,\n    C_veg\n)\n\n\nComputes maintenance respiration Rm in [kgC/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Vc_max-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 7}}} where NF","page":"API Reference","title":"Terrarium.compute_Vc_max","text":"compute_Vc_max(\n    photo,\n    c_1,\n    APAR,\n    Kc,\n    Ko,\n    Œì_star,\n    pres_i,\n    pres_O2\n)\n\n\nComputes the maximum daily rate of net photosynthesis Vc_max [gC/m¬≤/day], following the coordination hypothesis (acclimation), see Harrison 2021 Box 2. Note: this is not the same formula in PALADYN paper, this implementaion is taken from the code\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_auxiliary!","page":"API Reference","title":"Terrarium.compute_auxiliary!","text":"compute_auxiliary!(state, model::AbstractModel)\n\nCompute updates to all auxiliary variables based on the current prognostic state of the model.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_auxiliary!-Tuple{Any, Any, Terrarium.AbstractSkinTemperature}","page":"API Reference","title":"Terrarium.compute_auxiliary!","text":"Default compute_auxiliary! for all skin temperature implementation that computes the ground heat flux from the current radiative, sensible, and latent fluxes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_c1_c2-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 6}}} where NF","page":"API Reference","title":"Terrarium.compute_c1_c2","text":"compute_c1_c2(photo, T_air, Œì_star, Kc, Ko, pres_i, pres_O2)\n\n\nComputes factor for light-limited assimilation c_1 and factor for RuBisCO-limited assimilation c_2, Eqs. C4+C5, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_f_deciduous-Union{Tuple{PALADYNPhenology{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.compute_f_deciduous","text":"compute_f_deciduous(phenol)\n\n\nComputes f_deciduous, a factor for smooth transition between evergreen and deciduous [-].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_ground_heat_flux_kernel!-Tuple{Any}","page":"API Reference","title":"Terrarium.compute_ground_heat_flux_kernel!","text":"compute_ground_heat_flux_kernel!(state, grid, ::AbstractSkinTemperature)\n\nDiagnose the ground heat flux as the residual of the net radiation budget and turbulent fluxes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_hydraulic_conductivity!-Tuple{Any}","page":"API Reference","title":"Terrarium.compute_hydraulic_conductivity!","text":"compute_hydraulic_conductivity!(\n    state,\n    grid,\n    hydrology::SoilHydrology,\n    strat::AbstractStratigraphy,\n    bgc::AbstractSoilBiogeochemistry,\n)\n\nKernel for computing the hydraulic conductivity in all grid cells and soil layers.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_phen-Union{Tuple{PALADYNPhenology{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.compute_phen","text":"compute_phen(phenol)\n\n\nComputes phen, the phenology factor [-].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_photosynthesis-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 6}}} where NF","page":"API Reference","title":"Terrarium.compute_photosynthesis","text":"compute_photosynthesis(\n    photo,\n    T_air,\n    swdown,\n    pres,\n    co2,\n    LAI,\n    Œªc\n)\n\n\nComputes Gross Primary Production GPPin [kgC/m¬≤/day] and leaf respiration Rd in [gC/m¬≤/day]\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_pres_i-Tuple{LUEPhotosynthesis, Any, Any}","page":"API Reference","title":"Terrarium.compute_pres_i","text":"compute_pres_i(photo, Œªc, pres_a)\n\n\nComputes intercellular CO2 partial pressure [Pa], Eq. 67, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_resp10-Union{Tuple{PALADYNAutotrophicRespiration{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.compute_resp10","text":"compute_resp10(autoresp)\n\n\nComputes resp10 \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_saturation_tendency!-Tuple{Any}","page":"API Reference","title":"Terrarium.compute_saturation_tendency!","text":"compute_saturation_tendency!(\n    state,\n    grid,\n    hydrology::SoilHydrology,\n    strat::AbstractStratigraphy,\n    bgc::AbstractSoilBiogeochemistry,\n)\n\nKernel for computing the tendency of the prognostic saturation_water_ice variable in all grid cells and soil layers.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_tendencies!","page":"API Reference","title":"Terrarium.compute_tendencies!","text":"compute_tendencies!(state, model::AbstractModel)\n\nCompute tendencies for all prognostic state variables for model stored in the given state. This method should be called after compute_auxiliary!.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_vpd-Union{Tuple{NF}, Tuple{NF, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_vpd","text":"compute_vpd(T_air, q_air, pres)\n\n\nComputes the vapor pressure deficit from air temperature, specific humidity, and surface pressure.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_water_table!-Tuple{Any}","page":"API Reference","title":"Terrarium.compute_water_table!","text":"compute_water_table!(\n    state,\n    grid,\n    ::SoilHydrology{NF},\n    z_faces\n) where {NF}\n\nKernel for diagnosing the water table at each grid point given the current soil saturation state. The argument z_faces should be the z-coordinates of the grid on the layer faces.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œì_star-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_Œì_star","text":"compute_Œì_star(photo, œÑ, pres_O2)\n\n\nComputes the CO2 compensation point Œì_star, Eq. C6, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œõ_loc-Union{Tuple{NF}, Tuple{PALADYNCarbonDynamics{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.compute_Œõ_loc","text":"compute_Œõ_loc(vegcarbon_dynamics, LAI_b)\n\n\nComputes the local litterfall rate Œõ_loc based on the balanced Leaf Area Index LAI_b (assuming evergreen PFTs), Eq. 75, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œ≤-Union{Tuple{LUEPhotosynthesis{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.compute_Œ≤","text":"compute_Œ≤(photo)\n\n\nComputes the soil-moisture limiting factor Œ≤, Eq. 66, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œ≥v-Tuple{PALADYNVegetationDynamics}","page":"API Reference","title":"Terrarium.compute_Œ≥v","text":"compute_Œ≥v(veg_dynamics)\n\n\nComputes the disturbance rateŒ≥v, Eq. 80, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œª_NPP-Union{Tuple{NF}, Tuple{PALADYNCarbonDynamics{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.compute_Œª_NPP","text":"compute_Œª_NPP(vegcarbon_dynamics, LAI_b)\n\n\nComputes Œª_NPP,a factor determining the partitioning of NPP between increase of vegetation carbon of the existing  vegetated area and spreading of the given PFT based on the balanced Leaf Area Index LAI_b, Eq. 74, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œªc-Union{Tuple{NF}, Tuple{MedlynStomatalConductance{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.compute_Œªc","text":"compute_Œªc(stomcond, vpd)\n\n\nComputes the ratio of leaf-internal and air CO2 concentration Œªc,  derived from the optimal stomatal conductance model (Medlyn et al. 2011), Eq. 71, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_ŒΩ_star-Tuple{PALADYNVegetationDynamics, Any}","page":"API Reference","title":"Terrarium.compute_ŒΩ_star","text":"compute_ŒΩ_star(veg_dynamics, ŒΩ)\n\n\nComputes ŒΩ_star which is the maximum between the current vegetation fraction ŒΩ and the seed fraction ŒΩ_seed [-], to ensure that a PFT is always seeded.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_ŒΩ_tend-Union{Tuple{NF}, Tuple{PALADYNVegetationDynamics, PALADYNCarbonDynamics{NF}, NF, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_ŒΩ_tend","text":"compute_ŒΩ_tend(\n    veg_dynamics,\n    vegcarbon_dynamics,\n    LAI_b,\n    C_veg,\n    ŒΩ\n)\n\n\nComputes the vegetation fraction tendency for a single PFT, Eq. 73, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.convert_dt-Tuple{Number}","page":"API Reference","title":"Terrarium.convert_dt","text":"convert_dt(Œît)\n\n\nConvert Œîts of type Period to a numeric value in seconds. Return Œît if already a number.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.darcy_flux-NTuple{6, Any}","page":"API Reference","title":"Terrarium.darcy_flux","text":"darcy_flux(i, j, k, grid, œà, K)\n\n\nKernel function for computing the Darcy flux over layer faces from the pressure head œà and hydraulic conductivity K.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.default_dt","page":"API Reference","title":"Terrarium.default_dt","text":"default_dt(timestepper::AbstractTimeStepper)\n\nGet the current timestep size for the time stepper.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.emissivity","page":"API Reference","title":"Terrarium.emissivity","text":"emissivity(i, j, state, ::AbstractAlbedo)\n\nReturn the current emissivity at the given indices.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.energy_to_temperature-Union{Tuple{NF}, Tuple{FreezeCurves.FreeWater, NF, NF, NF}} where NF","page":"API Reference","title":"Terrarium.energy_to_temperature","text":"Calculate the inverse enthalpy function given the internal energy, latent heat content, and heat capacity under the free water freezing characteristic.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.explicit_step!-Tuple{Any, Terrarium.AbstractLandGrid, Terrarium.AbstractTimeStepper, Any}","page":"API Reference","title":"Terrarium.explicit_step!","text":"explicit_step!(state, grid, timestepper, Œît)\n\n\nEvaluate an explicit update u += ‚àÇu‚àÇt*Œît for all prognostic fields and their corresponding tendencies. By default, this is implemented as a simple Euler update u += dudt*Œît which can serve as a building block for more complex, multi-stage timesteppers. Where necessary, additional dispatches of explicit_step_kernel!(field, tendency, ::AbstractLandGrid, ::TimeStepper, Œît) can be defined to implement more specialized time-stepping schemes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.explicit_step!-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}, Oceananigans.Fields.AbstractField{LX, LY, LZ}, Terrarium.AbstractLandGrid, Terrarium.AbstractTimeStepper, Any, Vararg{Any}}} where {LX, LY, LZ}","page":"API Reference","title":"Terrarium.explicit_step!","text":"Accumulate tendency*Œît in the given prognostic field. This method can be overridden by specialized timestepping schemes as needed.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.fastiterate-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{NTuple{N, Any}}}} where {F, N}","page":"API Reference","title":"Terrarium.fastiterate","text":"fastiterate(f!::F, iters::NTuple{N,Any}...) where {F,N}\n\nSame as fastmap but simply invokes f! on each argument set without constructing a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.fastmap-Union{Tuple{F}, Tuple{F, Vararg{NamedTuple}}} where F","page":"API Reference","title":"Terrarium.fastmap","text":"fastmap(f::F, iter::NamedTuple...) where {F}\n\nSame as map for NamedTuples but with guaranteed type stability. fastmap is a @generated function which unrolls calls to f into a loop-free tuple construction expression. All named tuples must have the same keys but in no particular order. The returned NamedTuple \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.fastmap-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{NTuple{N, Any}}}} where {F, N}","page":"API Reference","title":"Terrarium.fastmap","text":"fastmap(f::F, iter::NTuple{N,Any}...) where {F,N}\n\nSame as map for NTuples but with guaranteed type stability. fastmap is a @generated function which unrolls calls to f into a loop-free tuple construction expression.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.field_capacity","page":"API Reference","title":"Terrarium.field_capacity","text":"Compute the empirical field capacity of the soil.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.findfirst_z-NTuple{4, Any}","page":"API Reference","title":"Terrarium.findfirst_z","text":"findfirst_z(idx, condition_func, z_nodes, field)\n\n2D kernel function that finds the first coordinate in z_nodes where condition_func(field[i, j, k]). This implementation performs a linear scan over the z-axis and thus has time complexity O(N_z).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_closures-Tuple{Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.get_closures","text":"get_closures(model::AbstractModel)\n\nReturn all closure relations defined for the given model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_field_grid","page":"API Reference","title":"Terrarium.get_field_grid","text":"get_field_grid(grid::AbstractLandGrid)::Oceananigans.AbstractGrid\n\nReturns the underlying Oceananigans grid type for Fields defined on the given land grid.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.get_field_initializers-Tuple{FieldInitializers}","page":"API Reference","title":"Terrarium.get_field_initializers","text":"Returns the field initializers stored in init.vars merged with the field initializers defined by the inner initializer. The field initilaizers defined by the given FieldInitializers take precedence in the merge.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_field_initializers-Tuple{Terrarium.AbstractInitializer}","page":"API Reference","title":"Terrarium.get_field_initializers","text":"get_field_initializers(_)\n\n\nReturns a named tuple of Oceananigans Field initializer functions where the keys correspond to the names of the respective state variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_fields-Tuple{StateVariables, Vararg{Union{Symbol, Pair}}}","page":"API Reference","title":"Terrarium.get_fields","text":"get_fields(state::StateVariables, queries::Union{Symbol, Pair}...)\n\nRetrieves fields with names given in queries and returns them in a NamedTuple. Each argument in queries can either be a Symbol corresponding to a field/variable defined in the namespace of state or a Pair{Symbol, Tuple} where the key is the child namespace and the value is a tuple of queries from that namespace.\n\n# initialize model\nstate = initialize(model)\n# get the temperature and saturation_water_ice fields\nfields = get_fields(state, :temperature, :saturation_water_ice)\n# extract temperature as well as variables from a namespace\nnested_fields = get_fields(state, :temperature, :namespace => (:subvar1, :subvar2))\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_grid-Tuple{Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.get_grid","text":"get_grid(model::AbstractModel)::AbstractLandGrid\n\nReturn the spatial grid associated with this model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_initializer-Tuple{Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.get_initializer","text":"get_initializer(model::AbstractModel)::AbstractInitializer\n\nReturns the initializer associated with this model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_spacing-Tuple{Terrarium.AbstractVerticalSpacing}","page":"API Reference","title":"Terrarium.get_spacing","text":"get_spacing(spacing)\n\n\nReturn a Vector of vertical layer thicknesses according to the given discretization.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_swrc","page":"API Reference","title":"Terrarium.get_swrc","text":"get_swrc(::AbstractUnsatK)\n\nReturn the soil water retention curve associated with the given unsaturated hydraulic conductivity scheme.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.get_swrc-Tuple{SoilHydrology}","page":"API Reference","title":"Terrarium.get_swrc","text":"get_swrc(hydrology::SoilHydrology)\n\nReturn the soil water retention curve from the hydraulic_properties associated with the given SoilHydrology configuration.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.heatcapacity-Tuple{SoilThermalProperties, SoilComposition}","page":"API Reference","title":"Terrarium.heatcapacity","text":"heatcapacity(props, soil)\n\n\nCompute the bulk heat capacity of the given soil volume.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.hydraulic_conductivity","page":"API Reference","title":"Terrarium.hydraulic_conductivity","text":"Compute (variably saturated) hydraulic conductivity based on the given hydraulic properties, soil water retention curve (SWRC), and volumetric fractions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.initialize!","page":"API Reference","title":"Terrarium.initialize!","text":"initialize!(state, model::AbstractModel)\ninitialize!(state, model::AbstractModel, initializer::AbstractInitializer)\n\nCall initialize! on the model and its corresponding initializer. This method only needs to be implemented if initialization routines are necessary in addition to direct field/variable initializers.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.initialize!-Tuple{ModelIntegrator}","page":"API Reference","title":"Terrarium.initialize!","text":"Resets the simulation clock and calls initialize!(state, model) on the underlying model which should reset all state variables to their values as defiend by the model initializer.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize!-Union{Tuple{names}, Tuple{Any, NamedTuple{names}}} where names","page":"API Reference","title":"Terrarium.initialize!","text":"\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Tuple{Terrarium.AbstractTimeStepper, Any, Any}","page":"API Reference","title":"Terrarium.initialize","text":"initialize(::AbstractTimeStepper, model, state) where {NF}\n\nInitialize and return the time stepping state cache for the given time stepper.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Union{Tuple{NF}, Tuple{Terrarium.AbstractModel{NF, Grid} where Grid<:(Terrarium.AbstractLandGrid{NF}), Terrarium.AbstractTimeStepper, Vararg{InputSource}}} where NF","page":"API Reference","title":"Terrarium.initialize","text":"Creates and initializes a ModelIntegrator for the given model with the given clock state. This method allocates all necessary Fields for the state variables and calls initialize!(::ModelIntegrator). Note that this method is not type stable and should not be called in an Enzyme autodiff call.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.input-Tuple{Symbol, Terrarium.VarDims}","page":"API Reference","title":"Terrarium.input","text":"input(name, dims; units, domain, desc)\n\n\nConvenience constructor method for InputVariable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.invclosure!-Tuple{Any, Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.invclosure!","text":"invclosure!(state, model::AbstractModel)\n\nApply the inverse of each closure relation defined for the given model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.is_adaptive","page":"API Reference","title":"Terrarium.is_adaptive","text":"is_adaptive(timestepper::AbstractTimeStepper)\n\nReturn true if the given time stepper is adaptive, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.is_initialized","page":"API Reference","title":"Terrarium.is_initialized","text":"is_initialized(timestepper::AbstractTimeStepper)\n\nReturn true if the timestepper is initialized, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.latent_heat_flux","page":"API Reference","title":"Terrarium.latent_heat_flux","text":"latent_heat_flux(i, j, state, ::AbstractTurbulentFluxes)\n\nReturn the current latent heat flux at the given indices.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.liquid_water_fraction-Union{Tuple{NF}, Tuple{FreezeCurves.FreeWater, NF, NF, NF}} where NF","page":"API Reference","title":"Terrarium.liquid_water_fraction","text":"Calculate the unfrozen water content from the given internal energy, latent heat content, and saturation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.longwave_in-Union{Tuple{PR}, Tuple{Any, Any, Any, Terrarium.AbstractAtmosphere{PR, <:LongShortWaveRadiation}}} where PR","page":"API Reference","title":"Terrarium.longwave_in","text":"longwave_in(i, j, state, ::AbstractAtmosphere{PR, <:LongShortWaveRadiation})\n\nRetrieve or compute the incoming/downwelling longwave radiation at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.longwave_out-Tuple{DiagnosedRadiativeFluxes, PhysicalConstants, Any, Any, Any}","page":"API Reference","title":"Terrarium.longwave_out","text":"longwave_out(::DiagnosedRadiativeFluxes, constants::PhysicalConstants, surface_longwave_down, Ts, œµ)\n\nCompute outgoing longwave radiation from incoming surface_longwave_down, surface temperature Ts, and emissivity œµ.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.merge_boundary_conditions-Tuple{Vararg{NamedTuple{names, BCs} where {names, BCs<:Tuple{Vararg{Union{Oceananigans.BoundaryConditions.FieldBoundaryConditions, NamedTuple{locs, <:Tuple{Vararg{Oceananigans.BoundaryConditions.BoundaryCondition}}}} where locs}}}}}","page":"API Reference","title":"Terrarium.merge_boundary_conditions","text":"merge_boundary_conditions(bcs::FieldBCs...)\n\nRecursively merge an arbitrary number of field/variable boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.merge_duplicates-Tuple{Tuple}","page":"API Reference","title":"Terrarium.merge_duplicates","text":"merge_duplicates(values)\n\n\nFilter out duplicates from the given tuple. Note that this method is not type stable or allocation-free!\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.merge_recursive-Tuple{NamedTuple, NamedTuple, Vararg{Any}}","page":"API Reference","title":"Terrarium.merge_recursive","text":"merge_recursive(nt1::NamedTuple, nt2::NamedTuple)\n\nRecursively merge two nested named tuples. This implementation is loosely based on the one in NamedTupleTools authored by Jeffrey Sarnoff.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.min_z·µÉ·µÉ·∂†-NTuple{5, Any}","page":"API Reference","title":"Terrarium.min_z·µÉ·µÉ·∂†","text":"min_z·µÉ·µÉ·∂†(i, j, k, grid, x)\nmin_z·µÉ·µÉ·∂†(i, j, k, grid, f, args...)\n\nComputes the field or function at the vertical (z-axis) face by taking the min of the two adjacent vertical layers.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.mineral_porosity","page":"API Reference","title":"Terrarium.mineral_porosity","text":"Compute the natural porosity of the mineral soil constitutents, i.e. excluding organic material.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.namespace-Tuple{Symbol, Terrarium.Variables}","page":"API Reference","title":"Terrarium.namespace","text":"namespace(name, vars)\n\n\nConvenience constructor method for variable Namespaces.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.num_layers-Tuple{Terrarium.AbstractLandGrid}","page":"API Reference","title":"Terrarium.num_layers","text":"Return the number of vertical layers defined by the given grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.num_layers-Tuple{Terrarium.AbstractVerticalSpacing}","page":"API Reference","title":"Terrarium.num_layers","text":"num_layers(spacing)\n\n\nReturn the number of vertical layers defined by this discretization.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.organic_fraction-Tuple{Any, Any, Any, Any, ConstantSoilCarbonDensity}","page":"API Reference","title":"Terrarium.organic_fraction","text":"organic_fraction(i, j, k, state, bgc::ConstantSoilCarbonDensity)\n\nCalculate the organic solid fraction at the given indices based on the prescribed SOC and natural porosity/density of the organic material.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.organic_porosity-Tuple{Any, Any, Any, Any, ConstantSoilCarbonDensity}","page":"API Reference","title":"Terrarium.organic_porosity","text":"organic_porosity(i, j, k, state, bgc::ConstantSoilCarbonDensity)\n\nGet the prescribed natural porosity of organic soil.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.partial_pressure_CO2-Union{Tuple{NF}, Tuple{NF, NF}} where NF","page":"API Reference","title":"Terrarium.partial_pressure_CO2","text":"partial_pressure_CO2(pres, conc_co2)\n\n\nCompute partial pressure of CO2 from surface pressure and CO2 concentration in Pa.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.partial_pressure_O2-Tuple{NF} where NF","page":"API Reference","title":"Terrarium.partial_pressure_O2","text":"partial_pressure_O2(pres)\n\n\nCompute partial pressure of oxygen from surface pressure in Pa.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.piecewise_linear-Tuple{Vararg{Pair{<:Unitful.Quantity{NF, ùêã, U} where {NF, U<:Unitful.Units}}}}","page":"API Reference","title":"Terrarium.piecewise_linear","text":"piecewise_linear(knots; extrapolation)\n\n\nReturn a function f(z) that linearly interpolates between the given knots.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.porosity-Tuple{Any, Any, Any, Any, SoilHydrology, Terrarium.AbstractStratigraphy, Terrarium.AbstractSoilBiogeochemistry}","page":"API Reference","title":"Terrarium.porosity","text":"porosity(i, j, k, state, hydrology::SoilHydrology, strat::AbstractStratigraphy, bgc::AbstractSoilBiogeochemistry)\n\nReturn the porosity of the soil volume at the given indices based on the current state, hydrology, stratigraphy, and biogeochemistry configurations.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.prognostic-Tuple{Symbol, Terrarium.VarDims}","page":"API Reference","title":"Terrarium.prognostic","text":"prognostic(name, dims; units, closure, domain, desc)\n\n\nConvenience constructors for PrognosticVariable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.rainfall-Tuple{Any, Any, Any, Terrarium.AbstractAtmosphere{<:TwoPhasePrecipitation}}","page":"API Reference","title":"Terrarium.rainfall","text":"rainfall(i, j, state, ::AbstractAtmosphere{<:TwoPhasePrecipitation})\n\nRetrieve or compute the liquid precipitation (rainfall) at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.relative_to_specific_humidity-NTuple{4, Any}","page":"API Reference","title":"Terrarium.relative_to_specific_humidity","text":"relative_to_specific_humidity(r_h, pr, Ts, Tair)\n\nDerives specific humidity from measured relative humidity, air pressure, and soil/air temperatures.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.reset_tendencies!-Tuple{StateVariables}","page":"API Reference","title":"Terrarium.reset_tendencies!","text":"Reset all tendencies in state to zero.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.safediv-Union{Tuple{NF}, Tuple{NF, NF}} where NF","page":"API Reference","title":"Terrarium.safediv","text":"safediv(x, y)\n\n\nEvaluates x / (y + eps(NF)) if and only if y != zero(y); returns Inf otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.saturated_hydraulic_conductivity","page":"API Reference","title":"Terrarium.saturated_hydraulic_conductivity","text":"Compute hydraulic conductivity at saturation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.saturation_vapor_pressure-NTuple{4, Any}","page":"API Reference","title":"Terrarium.saturation_vapor_pressure","text":"saturation_vapor_pressure(T, a‚ÇÅ, a‚ÇÇ, a‚ÇÉ)\n\nAugust-Roche-Magnus equation for saturation vapor pressure at temperature T with empirical coefficients a‚ÇÅ, a‚ÇÇ, and a‚ÇÉ.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.saturation_vapor_pressure-Union{Tuple{NF}, Tuple{NF, NF}} where NF","page":"API Reference","title":"Terrarium.saturation_vapor_pressure","text":"saturation_vapor_pressure(T, Ts=T)\n\nSaturation vapor pressure at the given temperature T over a surface at temperature Ts, accounting for both frozen (Ts < 0¬∞C) and unfrozen conditions.\n\nCoefficients taken from Alduchov and Eskridge (1997).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.sensible_heat_flux","page":"API Reference","title":"Terrarium.sensible_heat_flux","text":"sensible_heat_flux(i, j, state, ::AbstractTurbulentFluxes)\n\nReturn the current sensible heat flux at the given indices.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.shortwave_in-Union{Tuple{PR}, Tuple{Any, Any, Any, Terrarium.AbstractAtmosphere{PR, <:LongShortWaveRadiation}}} where PR","page":"API Reference","title":"Terrarium.shortwave_in","text":"shortwave_in(i, j, state, ::AbstractAtmosphere{PR, <:LongShortWaveRadiation})\n\nRetrieve or compute the incoming/downwelling shortwave radiation at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.shortwave_out-Tuple{DiagnosedRadiativeFluxes, Any, Any}","page":"API Reference","title":"Terrarium.shortwave_out","text":"shortwave_out(::DiagnosedRadiativeFluxes, surface_shortwave_down, Œ±)\n\nCompute outgoing shortwave radiation from the incoming surface_shortwave_down and albedo Œ±.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.skin_temperature","page":"API Reference","title":"Terrarium.skin_temperature","text":"skin_temperature(i, j, state, ::AbstractSkinTemperature)\n\nReturn the current skin temperature at the given indices.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.snowfall-Tuple{Any, Any, Any, Terrarium.AbstractAtmosphere{<:TwoPhasePrecipitation}}","page":"API Reference","title":"Terrarium.snowfall","text":"snowfall(i, j, state, ::AbstractAtmosphere{<:TwoPhasePrecipitation})\n\nRetrieve or compute the frozen precipitation (snowfall) at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.soil_composition-Tuple{Any, Any, Any, Any, HomogeneousSoil, Terrarium.AbstractSoilHydrology, Terrarium.AbstractSoilBiogeochemistry}","page":"API Reference","title":"Terrarium.soil_composition","text":"Compute and return a SoilComposition summarizing the material composition of the soil volume at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.specific_humidity-Union{Tuple{IR}, Tuple{PR}, Tuple{Any, Any, Any, Terrarium.AbstractAtmosphere{PR, IR, <:Terrarium.SpecificHumidity}}} where {PR, IR}","page":"API Reference","title":"Terrarium.specific_humidity","text":"specific_humidity(i, j, state, ::PrescribedAtmosphere{PR, IR, <:SpecificHumidity})\n\nRetrieve or compute the specific_humidity at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.stefan_boltzmann-Tuple{PhysicalConstants, Any, Any}","page":"API Reference","title":"Terrarium.stefan_boltzmann","text":"stefan_boltzmann(c::PhysicalConstants, T, œµ)\n\nStefan-Boltzmann law M = epsilon sigma T^4 where T is the surface temperature in Kelvin and œµ is the emissivity.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.surface_humidity_at_saturation-Tuple{Any, Any, Any, Terrarium.AbstractSkinTemperature, Terrarium.AbstractAtmosphere, PhysicalConstants}","page":"API Reference","title":"Terrarium.surface_humidity_at_saturation","text":"Near-surface specific humidity at saturation, q_textsat, determined based on the skin temperature and atmospheric pressure.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.surface_net_radiation","page":"API Reference","title":"Terrarium.surface_net_radiation","text":"surface_net_radiation(i, j, state, ::AbstractRadiativeFluxes)\n\nReturn the current net radiation at the given indices.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.surface_net_radiation-Tuple{Any, Any, Any, Any, Terrarium.AbstractRadiativeFluxes}","page":"API Reference","title":"Terrarium.surface_net_radiation","text":"Return the current value of the surface_net_radiation at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.surface_net_radiation-Tuple{Terrarium.AbstractRadiativeFluxes, Vararg{Any, 4}}","page":"API Reference","title":"Terrarium.surface_net_radiation","text":"surface_net_radiation(::AbstractRadiativeFluxes, surface_shortwave_down, surface_shortwave_up, surface_longwave_down, surface_longwave_up)\n\nCompute the net radiation budget given incoming and outgoing shortwave and longwave radiation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.tendency-Tuple{Terrarium.Variable}","page":"API Reference","title":"Terrarium.tendency","text":"tendency(var)\n\n\nCreates an AuxiliaryVariable for the tendency of a prognostic variable with the given name, dimensions, and physical units. This constructor is primarily used internally by other constructors and does not usually need to be called by implementations of variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.thermalconductivity-Tuple{SoilThermalProperties, SoilComposition}","page":"API Reference","title":"Terrarium.thermalconductivity","text":"thermalconductivity(props, soil)\n\n\nCompute the bulk thermal conductivity of the given soil volume.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.timestep!","page":"API Reference","title":"Terrarium.timestep!","text":"timestep!(state, timestepper::AbstractTimeStepper, model::AbstractModel, inputs::InputSources, Œît)\n\nAdvance prognostic variables by one time step based on the current state, or by Œît units of time.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.timestep!-Tuple{ModelIntegrator}","page":"API Reference","title":"Terrarium.timestep!","text":"timestep!(integrator; finalize)\n\n\nAdvance the model forward by one timestep with optional timestep size Œît. If finalize = true, compute_auxiliary! is called after the time step in order to update the values of auxiliary/diagnostic variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.tuplejoin-Tuple{}","page":"API Reference","title":"Terrarium.tuplejoin","text":"tuplejoin()\n\n\nConcatenate one or more tuples together.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.update_inputs!-Tuple{Any, InputSource, Clock}","page":"API Reference","title":"Terrarium.update_inputs!","text":"update_inputs!(fields, _, _)\n\n\nUpdates the values of input variables stored in fields from the given input source. Default implementation simply returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.update_inputs!-Tuple{StateVariables, InputSources}","page":"API Reference","title":"Terrarium.update_inputs!","text":"Update input variables from the given input sources.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.update_skin_temperature_kernel!-Tuple{Any}","page":"API Reference","title":"Terrarium.update_skin_temperature_kernel!","text":"update_skin_temperature_kernel!(state, grid, skinT::PrognosticSkinTemperature)\n\nDiagnose the skin temperature implied by the current ground_heat_flux and ground_temperature.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.var","page":"API Reference","title":"Terrarium.var","text":"var(name, dims)\nvar(name, dims, units)\n\n\nConvenience constructor for Variable.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.vardims-Tuple{Terrarium.AbstractVariable}","page":"API Reference","title":"Terrarium.vardims","text":"vardims(var)\n\n\nRetrieve the grid dimensions on which this variable is defined.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.vardims-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, Nothing}}, Tuple{LY}, Tuple{LX}} where {LX, LY}","page":"API Reference","title":"Terrarium.vardims","text":"vardims(_)\n\n\nInfer the appropriate VarDims from the given Field.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.variables","page":"API Reference","title":"Terrarium.variables","text":"variables(model::AbstractModel)\n\nReturn a Tuple of AbstractVariables (i.e. PrognosticVariable, AuxiliaryVariable, etc.) defined by the model. For models that consist of one or more sub-models, variables may optionally be grouped into namespaces by returning a NamedTuple where the keys correspond to the group names.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.variables-Tuple{InputSource}","page":"API Reference","title":"Terrarium.variables","text":"variables(_)\n\n\nReturns a tuple of Symbols corresponding to variable names supported by this InputSource.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.variables-Tuple{Vararg{Union{Terrarium.AbstractVariable, Terrarium.Namespace}}}","page":"API Reference","title":"Terrarium.variables","text":"Alias for Variables(vars...)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.variables-Union{Tuple{SoilHydrology{NF, VerticalFlow, Runoff, SoilET, SoilHydraulics} where {VerticalFlow<:Terrarium.AbstractVerticalFlow, Runoff<:Terrarium.AbstractSoilRunoff, SoilET<:Terrarium.AbstractSoilET, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.variables","text":"State variables for SoilHydrology processes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.varname-Union{Tuple{Terrarium.AbstractVariable{name}}, Tuple{name}} where name","page":"API Reference","title":"Terrarium.varname","text":"varname(_)\n\n\nRetrieve the name of the given variable or closure. For closure relations, varname should return the name of the variable returned by the closure relation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.varunits-Tuple{Terrarium.AbstractVariable}","page":"API Reference","title":"Terrarium.varunits","text":"varunits(var)\n\n\nRetrieve the physical units for the given variable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.volumetric_fractions-Tuple{SoilComposition}","page":"API Reference","title":"Terrarium.volumetric_fractions","text":"volumetric_fractions(soil::SoilComposition)\n\nCalculates the volumetric fractions of all constituents in the given soil volume and returns them as a named tuple of the form (; water, ice, air, mineral, organic).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.wilting_point","page":"API Reference","title":"Terrarium.wilting_point","text":"Compute the empirical wilting point of the soil.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.windspeed-Tuple{Any, Any, Any, PrescribedAtmosphere}","page":"API Reference","title":"Terrarium.windspeed","text":"windspeed(i, j, state, ::PrescribedAtmosphere)\n\nRetrieve or compute the windspeed at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.workspec-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"API Reference","title":"Terrarium.workspec","text":"Returns the appropriate workspec for the given AbstractField or based on the given field locations.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.FieldBC","page":"API Reference","title":"Terrarium.FieldBC","text":"Alias for union type of FieldBoundaryConditions or a named tuple of BoundaryConditions with keys corresponding to boundary locations (i.e. top, bottom, etc.)\n\n\n\n\n\n","category":"type"},{"location":"physics/vegetation/#Vegetation","page":"Vegetation","title":"Vegetation","text":"warning: Warning\nThis page is a work in progress. If you have any questions or notice any errors, please raise an issue.\n\nComing soon!","category":"section"},{"location":"overview/mathematical_formulation/#Mathematical-formulation","page":"Mathematical formulation","title":"Mathematical formulation","text":"Terrarium.jl strictly follows a philosophy of dynamical modeling via discretized differential equations. This means that all physical processes in the model must be written as terms in a set of continuous-time equations of the form:\n\nfracpartial u(xt)partial t = G(u(xt)) + F(xt)\n\nwhere u(xt) is a field describing the prognostic state of the system, t is time, F is a focing term, and G is a (differentiable) function which computes the tendencies, i.e. the change in the prognostic state at the current time, t.\n\nIn many areas of science and engineering, this approach to modeling is fairly standard. It can be contrasted, however, with discrete-time dynamical modeling where state changes are computed according to a series of discrete update rules, mathbfD, with some fixed time resolution,\n\nmathbfu_t+1 = mathbfD(mathbfu_t)\n\nThe continuous-time formulation has three key advantages over the discrete approach:\n\nFaithfulness to realistic physical processes. Within the context of Earth system modeling, we are primarily interested in processes that operate continuously in time, not in discrete steps. Although the physics of land models may lack a well-defined ‚Äúdynamical core‚Äù of fluid dynamics like those found in atmosphere and ocean models, they are still ultimately centered around hydrological, thermodynamic, and biological processes that have continuous-time dynamics. As such, we believe that it is generally preferable to build models that follow this structure.\nFlexibility in timestepping and error control. Discrete-time formulations of dynamical systems necessarily require strong assumptions about the time-discretization of the system which often amount to a form of forward Euler with a fixed timestep size. Re-adjustment of the timestep size in mathbfD is sometimes achieved by rescaling rate parameters. However, this rescaling makes the strong assumption that the dynamics of the system scale linearly with the timescale and ignores potential feedback mechanisms and scale-dependent interactions in the dynamics. Continuous-time formulations relax this assumption and permit a much broader range of timestepping strategies that can account for nonlinearity and are thus, in our view, better suited to the simulation of coupled physical processes.\nHeterogeneous temporal resolution. Data assimilation and parameter estimation problems often necessitate the comparison of model outputs with observational time series data. These data often come at differing temporal resolutions and have irregular sample spacing due to, e.g. missing values. This can pose a problem for discrete-time models which must either (i) rescale the timestep to match the data, which has significant physical implications, or (ii) resort to temporal interpolation of the model outputs which is likely to violate the underlying physical conservation laws. Continuous-time systems do not have this problem since the timestep can always be adapted to obtain output at any set of time points.\n\nNote that one common problem in continuous-time dynamical modeling is the representation of discontinuous or instantaneous events/disruptions to the system. Such events can, however,  be handled through the use of callback functions based on the (discretized) state mathbfu. These cases should nonetheless be considered the exception rather than the rule.","category":"section"},{"location":"overview/mathematical_formulation/#Practical-implications","page":"Mathematical formulation","title":"Practical implications","text":"While the above modeling philosophy has many advantages, it also places some practical restrictions on how we code the model physics. The most important constraints are:\n\nPrognostic (i.e. time-integrated) state variables must be clearly and coherently distinguished from all other auxiliary variables derived from the prognostic state.\nPrognostic variables of the system should only be updated by the timestepper (or callback) and should not be otherwise modified by the physical processes within a single timestep. Note that this effectively rules out all classical ‚Äúbucket schemes‚Äù for soil hydrology which rely on non-physical, instantaneous routing of water between soil layers.\nFor physical coherence, tendencies must be computed only based on the current state of the system. Similarly, all non-prognostic (auxiliary) variables should be derived only from the prognostic state and/or forcings; they should not depend on non-prognostic values from previous timesteps, except in special cases where previous values are used only for computational efficiency (e.g. iterative solvers).\n\nThese restrictions can potentially be relaxed in some cases through the use of callbacks and/or nested time-stepping schemes, but the goal should always be to adhere to them as much as possible to avoid unncessary complexity.","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"We gladly welcome any and all contributions to Terrarium.jl. Building a new land model is a huge undertaking that no single developer or scientist can hope to achieve alone. Collaboration always has been and always will be key to building good geoscientific models. Terrarium is no exception to this, and its success will depend on the contributions of the broader community.\n\nThere are multiple ways in which you could consider contributing to the project:\n\nIf you have a question or an idea, raise an issue or start a discussion on the GitHub repository.\nIf you want to try implementing something, clone the repository and make a pull request. Please take note of our Software development practices below.\nIf you're not able to directly contribute yet but would like to support our work, consider sharing the GitHub repository (or this documentation) with others who you think might be interested.\n\nRegardless of how you choose to contribute, we thank you for your participation, and we look forward to working with you!","category":"section"},{"location":"contributing/#Software-development-practices","page":"Contributing","title":"Software development practices","text":"","category":"section"},{"location":"contributing/#Automated-testing-and-continuous-integration","page":"Contributing","title":"Automated testing and continuous integration","text":"Terrarium.jl adheres to software development standards for automated testing via continuous integration. We write unit tests for every function of our model. In some cases this might appear trivial, but we still want to achieve a near complete coverage of our code in the tests. The majority of the tests should cover the smallest possible units over different input arguments and types (if applicable). Unit tests should typically call the tested functions in a way that is representative for their use in the model, but try to reduce the computational complexity (e.g. by choosing very low dimensional inputs) to keep the overall CI time manageable. Additionally, we have some tests that ensure top-level functionality and stability of the model as well. Every additional proposed feature in a Pull Request has to come with unit tests. Tests verifying differentiability and GPU compatibility will also be requried.","category":"section"},{"location":"contributing/#Kernel-programming","page":"Contributing","title":"Kernel programming","text":"Terrarium.jl is a device-agnostic model that runs on CPUs and GPUs by using KernelAbstractions.jl. This means that most computations need to be implemented within kernel functions that follow KernelAbstractions‚Äô syntax. Each thread in the CPU or GPU will then compute the discretized equations for a single grid point.\n\nFor writing kernels we follow a strategy closely inspired by Oceaninanigans.jl: we want to fuse kernels as much as possible. Kernel fusion means that in practice we write very ‚Äúlarge‚Äù kernels that fuse as many operations as possible together in one kernel. Kernel fusion leads to more efficient GPU computations, especially by reducing memory demand (Wang et. al 2000). In order to still keep our code well structured and modular, our approach relies on implementing most processes as inlined functions that can be called from a GPU kernel. We have not yet found any significant limitations to this approach.\n\nHow this looks in action in Terrarium.jl you can already see in the prototype code, e.g. for the SoilEnergyBalance: There compute_tendencies! is the mandatory function for the model component, it launches exactly one kernel compute_energy_tendency!, which includes several @inline function to compute individual contributions to the energy balance such as energy_tendency, thermalconductivity and the diffusive_heat_flux.\n\nIt's also worth checking out the Simulation tips provided in the documentation for Oceananigans.","category":"section"},{"location":"contributing/#Automatic-Differentiation-with-Enzyme","page":"Contributing","title":"Automatic Differentiation with Enzyme","text":"For AD, we rely primarily on reverse mode differentiation via Enzyme.jl. In contrast to many other AD systems, Enzyme doesn‚Äôt put particularly strong restrictions on coding style. For example, Array mutations are not only allowed, they are even encouraged!\n\nThere is one thing however, that is crucial for Enzyme to work: type stability. The code absolutely has to be type stable, even in parts that are performance non-critical. Every occurrence of type instability may break differentiability with Enzyme. If this happens, we recommend first quickly checking for type instability of core function calls using @code_warntype and @inferred in unit tests. Then, if the issue is not yet apparent, debug the code using Cthulhu.jl. Cthulhu is an awesome tool to interactively inspect your code for type instabilities and it is extremely easy to run: just preempt the function that you are trying to differentiate with @descend after loading the Cthulhu package.\n\nEnzyme does, however, have some disadvantages; it is still not fully mature and bugs do occur. As of the time of writing (August 2025), this is especially the case for Julia 1.11. We currently recommend staying on Julia 1.10.10 (LTS) for the time being. Other cryptic Enzyme error messages have become rarer with time, but they do still occasionally happen. In these cases, we, along with our AD team led by Valentin in the DELTA-ESM project, are happy to offer support to the best of our abilities.","category":"section"},{"location":"notebooks/example_model_notebook/","page":"Model Interface","title":"Model Interface","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"fcd4e76c55ce3e8813db57a1a35fa44819f03b3e2ca21e674918439e79d0b45b\"\n    julia_version = \"1.11.7\"\n-->\n\n<div class=\"markdown\"><h1 id=\"A-super-basic-example-model-with-Terrarium\">A super basic example model with Terrarium</h1><p>In this example we will set up an embarrassingly simple example to demonstrate Terrarium's model interface. Our model will have 1-dimensional exponential dynamics with a constant offset</p><p class=\"tex\">$$\\frac{du}{dt} = \\alpha u + c + F(t)$$</p><p>for an arbitrary prognostic variable <span class=\"tex\">\\(u\\)</span>. For the sake of this demonstration we will treat the offset <span class=\"tex\">\\(c\\)</span> as an auxiliary/diagnostic variable even though it is constant in time. <span class=\"tex\">\\(F(t)\\)</span> is an external forcing that we apply. </p><p>We begin by defining our model <code>struct</code> that subtypes <code>Terrarium.AbstractModel</code>: </p></div>\n\n\n\n\n<pre class='language-julia'><code class='language-julia'>using Terrarium</code></pre>\n\n\n\n<pre class=\"code-output documenter-example-output\" id=\"var-Random\">TaskLocalRNG()</pre>\n\n\n<div class=\"markdown\"><p>A \"model\" in Terrarium is a subtype of <code>Terrarium.AbstractModel</code> and is a <code>struct</code> type constisting of </p><ul><li><p><code>grid</code> which defines the discretization of the spatial domain</p></li><li><p><code>initializer</code> which is responsible for initializing state variables</p></li><li><p>further fields that define processes, dynamics and submodels </p></li></ul><p>When we follow the advised naming notations of <code>grid</code> and <code>initializer</code> we inherit default methods from <code>Terrarium.AbstractModel</code> such as <code>get_grid</code> and <code>get_initializer</code>. For more complex models we might need to implement custom overrides of <code>initialize!(state, ::Model, ::Initializer)</code> to initialize model states. </p><h2 id=\"What-is-a-&quot;grid&quot;?\">What is a \"grid\"?</h2><p>The <code>grid</code> defines the spatial discretization. Our grids are based on those of Oceananigans.jl (and SpeedyWeather.jl/RingGrids.jl) in order to take advantage of their capabilities for device-agnostic parallelization.</p><p>Terrarium currently provides two grid types: </p><ul><li><p><code>ColumnGrid</code> is a set of laterally independent vertical columns with dimensions <span class=\"tex\">\\((x, y, z)\\)</span> where <span class=\"tex\">\\(x\\)</span> is the column dimension, <span class=\"tex\">\\(y=1\\)</span> is constant, and <span class=\"tex\">\\(z\\)</span> is the vertical axis, </p></li><li><p><code>ColumnRingGrid</code> represents a global (spherical) grid of independent, vertical columns where the spatial discretization in the horizontal direction is defined by a <code>RingGrids.AbstractGrid</code>. </p></li></ul><p>In both cases we need to specificy the vertical discretizataion via an <code>UniformSpacing</code>, <code>ExponentialSpacing</code> or <code>PrescribedSpacing</code>.</p><h2 id=\"Initializer-and-Boundary-Conditions\">Initializer and Boundary Conditions</h2><p>For our basic example here the default initializer (which does nothing) will suffice, and we won't have to define a custom one.</p><p>Boundary conditions are specified by passing Oceananigans <code>BoundaryCondition</code> types to <code>initialize</code>. In the case of a linear ODE, however, no boundary conditions are required.</p><h2 id=\"What&#39;s-our-grid?\">What's our <code>grid</code>?</h2><p>For our current example, we are defining a simple linear ODE without any spatial dynamics, so we can get away with just a single column with one vertical layer. We can define it like so:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>grid = ColumnGrid(CPU(), Float64, UniformSpacing(N=1))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grid\">ColumnGrid{Float64} on Oceananigans.Architectures.CPU() with\n1√ó1√ó1 RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0)  regularly spaced with Œîx=1.0\n‚îú‚îÄ‚îÄ Flat y                   \n‚îî‚îÄ‚îÄ Bounded  z ‚àà [-0.1, 0.0] variably spaced with min(Œîz)=0.1, max(Œîz)=0.1</pre>\n\n\n<div class=\"markdown\"><h2 id=\"Defining-the-model\">Defining the model</h2><p>We start by defining a <code>struct</code> for our model that inherits from <code>AbstractModel</code> and consists of three properties: the spatial <code>grid</code>, an <code>initializer</code>, and a single <code>AbstractProcess</code> defining the dynamics, which we will also implement below.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    @kwdef struct LinearDynamics{NF} &lt;: Terrarium.AbstractProcess\n        \"Exponential growth rate\"\n        alpha::NF = 0.01\n\n        \"Constant offset for exponential growth\"\n        c::NF = 0.1\n    end\n\n    @kwdef struct ExpModel{NF, Grid &lt;: Terrarium.AbstractLandGrid{NF}, Dyn, Init} &lt;: Terrarium.AbstractModel{NF, Grid}\n        \"Spatial grid on which state variables are discretized\"\n        grid::Grid\n\n        \"Linear dynamics resulting in exponential growth/decay\"\n        dynamics::Dyn = LinearDynamics()\n\n        \"Model initializer\"\n        initializer::Init = DefaultInitializer()\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h2 id=\"Defining-the-model-behaviour\">Defining the model behaviour</h2><p>Now, we want to define our intended model behaviour. For this, we need to define the following methods: </p><ul><li><p><code>variables(::Model)</code> returns a tuple of variable metadata declaring the state variables. Variables must be one of three types: <code>prognostic</code>, <code>auxiliary</code> (sometimes referred to as ‚Äúdiagnostic‚Äù), or <code>input</code>. Prognostic variables fully characterize the state of the system at any given timestep and are updated according to their tendencies (i.e. <span class=\"tex\">\\(u\\)</span> in our example). Tendencies are automatically allocated for each prognostic variable declared by the model. In this example we will treat the offset <span class=\"tex\">\\(c\\)</span> as an auxiliary variable, though we could also just include it as a constant in the tendency computations.</p></li><li><p><code>compute_auxiliary!(state, ::Model)</code> computes the values of all auxiliary variables (if necessary) assuming that the prognostic variables of the system in state are available for the current timestep.</p></li><li><p><code>compute_tendencies!(state, ::Model)</code> computes the tendencies based on the current values of the prognostic and auxiliary variables stored in state.</p></li></ul><p>So, let's define those: </p></div>\n\n<pre class='language-julia'><code class='language-julia'>Terrarium.variables(::ExpModel) = (\n    Terrarium.prognostic(:u, Terrarium.XY()),\n    Terrarium.auxiliary(:c, Terrarium.XY()),\n    Terrarium.input(:F, Terrarium.XY()),\n)</code></pre>\n\n\n\n<div class=\"markdown\"><p>Here, we defined our three variables with their names as a <code>Symbol</code> and whether they are 2D variables (<code>XY</code>) on the spatial grid or 3D variables (<code>XYZ</code>) that also vary along the vertical z-axis. Here we are considering only a simple scalar model so we choose 2D (<code>XY</code>), bearing in mind that all points in the X and Y dimensions of <code>ColumnGrid</code> are independent of each other.</p><p>We also need to define <code>compute_auxiliary!</code> and <code>compute_tendencies!</code> as discussed above. We will use here a pattern which is commonly employed within Terrarium: we unpack the process from the model and forward the method calls to more specialzied ones defined for the <code>LinearDynamics</code> process.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function Terrarium.compute_auxiliary!(state, model::ExpModel)\n    compute_auxiliary!(state, model, model.dynamics)\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>function Terrarium.compute_tendencies!(state, model::ExpModel)\n    compute_tendencies!(state, model, model.dynamics)\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Note that, when implementing models within the Terrarium module itself, the <code>Terrarium.</code> qualifier in the definition is not needed.</p><h2 id=\"Implementing-the-dynamics\">Implementing the dynamics</h2><p>Next, we define the functions that compute the actual dynamics. In order to do this, we need to know a little about how the variables we just defined are handled in our <code>StateVariables</code>. The <code>StateVariables</code> hold all prognostic and auxiliary variables, their tendencies and closures and additional inputs and forcings in seperate <code>NamedTuples</code>. Note that Terrarium also defines shortcuts such that, e.g. in our example, both <code>state.prognostic.u</code> and <code>state.u</code> would work.</p><p>With that in mind, let's define the methods:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function Terrarium.compute_auxiliary!(\n        state,\n        model::ExpModel,\n        dynamics::LinearDynamics\n    )\n    # set auxiliary variable for offset c\n    return state.auxiliary.c .= dynamics.c\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'># du/dt = u + c\nfunction Terrarium.compute_tendencies!(\n        state,\n        model::ExpModel,\n        dynamics::LinearDynamics\n    )\n    # define the dynamics; we'll use some special characters to make the equation nicer to look at :)\n    return let u = state.prognostic.u,\n            ‚àÇu‚àÇt = state.tendencies.u,\n            Œ± = dynamics.alpha,\n            # note again that here we could also just use dynamics.c instead of defining an auxiliary variable!\n            c = state.auxiliary.c\n            F = state.inputs.F\n        # Write into tendency variable ‚àÇu‚àÇt\n        ‚àÇu‚àÇt .= Œ± * u + c + F\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>These example compute functions are really the simplest possible, for more complex operations, we would need to define them via <code>KernelAbstractions</code> kernels. We will not go into further details on that in this notebook.</p><p>However, now we have everything our model needs and we can finally use it! </p><h2 id=\"Running-our-model\">Running our model</h2><p>First, we will define our initial conditions using <code>FieldInitializer</code>.</p><p><code>FieldInitializer</code> can take in functions <code>(x,z)-&gt;val</code>, arrays or values. It uses <code>Oceananigans.set!(field, x)</code>, and allows all input arguments for <code>x</code> that <code>set!</code> allows: </p></div>\n\n<pre class='language-julia'><code class='language-julia'>initializer = FieldInitializers(u = 1.0)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-initializer\">FieldInitializers{(:u,), DefaultInitializer, Tuple{Float64}}(DefaultInitializer(), (u = 1.0,))</pre>\n\n\n<div class=\"markdown\"><p>Then, we define our forcing. For that, our time-dependent forcing is loaded in from a <code>Oceananigans.FieldTimeSeries</code>. If you want to load the forcing from e.g. a netCDF file you can use the <code>RasterInputSource</code> that is based on <code>Rasters.jl</code>. In the concrete case, we'll just generate a random forcing: </p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin \n    t_F = 0:1:300\n    F = FieldTimeSeries(grid, XY(), t_F)\n    F.data .= randn(size(F));\n    input = InputSource(; F)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-F\">FieldTimeSeriesInputSource{Float64, XY{Center, Center}, (:F,), Tuple{FieldTimeSeries{Center, Center, Nothing, Oceananigans.OutputReaders.Clamp, Oceananigans.OutputReaders.InMemory{Nothing}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing, Nothing, @NamedTuple{}}}}(XY{Center, Center}(Center(), Center()), (F = 1√ó1√ó1√ó301 FieldTimeSeries{Oceananigans.OutputReaders.InMemory} located at (Center, Center, ‚ãÖ) on Oceananigans.Architectures.CPU\n‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ indices: (:, :, :)\n‚îú‚îÄ‚îÄ time_indexing: Clamp()\n‚îú‚îÄ‚îÄ backend: InMemory()\n‚îî‚îÄ‚îÄ data: 3√ó1√ó1√ó301 OffsetArray(::Array{Float64, 4}, 0:2, 1:1, 1:1, 1:301) with eltype Float64 with indices 0:2√ó1:1√ó1:1√ó1:301\n    ‚îî‚îÄ‚îÄ max=2.9704, min=-2.7185, mean=-0.000837337,))</pre>\n\n\n<div class=\"markdown\"><p>Here we constructed a 2D (<code>XY()</code>) time series on our <code>grid</code> at times <code>t_F</code> with random normal distributed data and definted our <code>InputSource</code> for our model based on it. </p></div>\n\n\n<div class=\"markdown\"><p>Then, we construct our model from the chosen <code>grid</code> and <code>initializer</code></p></div>\n\n<pre class='language-julia'><code class='language-julia'>model = ExpModel(grid; initializer)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-model\">ExpModel{Float64} on Oceananigans.Architectures.CPU()\n‚îú‚îÄ‚îÄ grid:  ColumnGrid{Float64, Oceananigans.Architectures.CPU} with dimensions (1, 1, 1)\n‚îú‚îÄ‚îÄ dynamics:  Main.var\"workspace#5\".LinearDynamics{Float64}\n‚îú‚îÄ‚îÄ initializer:  Terrarium.FieldInitializers{(:u,), Terrarium.DefaultInitializer, Tuple{Float64}}\n</pre>\n\n\n<div class=\"markdown\"><p>We now can initialize our model, i.e. we run all pre-computation, and initialize a numerical integrator for our model by passing it to <code>initialize</code> along with a suitable timestepper and our input/forcing data, which we here choose to be the second-order Heun method with a timestep of 1 second.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>integrator = initialize(model, ForwardEuler(Œît = 1.0), input)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-integrator\">Integrator of Main.var\"workspace#5\".ExpModel{Float64, Terrarium.ColumnGrid{Float64, Oceananigans.Architectures.CPU, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}}, Main.var\"workspace#5\".LinearDynamics{Float64}, Terrarium.FieldInitializers{(:u,), Terrarium.DefaultInitializer, Tuple{Float64}}} with Terrarium.ForwardEuler{Float64}\n‚îú‚îÄ‚îÄ Current time: 0.0\n‚îú‚îÄ‚îÄ StateVariables{Float64}(clock = Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Œît=Inf days), prognostic = (:u,), auxiliary = (:c,), inputs = (:F,), namespaces = ())\n</pre>\n\n\n<div class=\"markdown\"><p>We can advance our model by one step via the <code>timestep!</code> method:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>timestep!(integrator)</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>integrator.state.u</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash351687\">1√ó1√ó1 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing} reduced over dims = (3,) on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU\n‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions\n‚îÇ   ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: Nothing\n‚îî‚îÄ‚îÄ data: 3√ó1√ó1 OffsetArray(::Array{Float64, 3}, 0:2, 1:1, 1:1) with eltype Float64 with indices 0:2√ó1:1√ó1:1\n    ‚îî‚îÄ‚îÄ max=1.37315, min=1.37315, mean=1.37315</pre>\n\n\n<div class=\"markdown\"><p>or we can use <code>run!</code> for a fixed number of <code>steps</code> or over a desired <code>Dates.Period</code>:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>run!(integrator, period = Hour(1))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash506645\">Integrator of Main.var\"workspace#5\".ExpModel{Float64, Terrarium.ColumnGrid{Float64, Oceananigans.Architectures.CPU, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}}, Main.var\"workspace#5\".LinearDynamics{Float64}, Terrarium.FieldInitializers{(:u,), Terrarium.DefaultInitializer, Tuple{Float64}}} with Terrarium.ForwardEuler{Float64}\n‚îú‚îÄ‚îÄ Current time: 3601.0\n‚îú‚îÄ‚îÄ StateVariables{Float64}(clock = Clock{Float64, Float64}(time=1.000 hours, iteration=3601, last_Œît=1 second), prognostic = (:u,), auxiliary = (:c,), inputs = (:F,), namespaces = ())\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>integrator.state.u</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash351687\">1√ó1√ó1 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing} reduced over dims = (3,) on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU\n‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions\n‚îÇ   ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: Nothing\n‚îî‚îÄ‚îÄ data: 3√ó1√ó1 OffsetArray(::Array{Float64, 3}, 0:2, 1:1, 1:1) with eltype Float64 with indices 0:2√ó1:1√ó1:1\n    ‚îî‚îÄ‚îÄ max=2.37152e16, min=2.37152e16, mean=2.37152e16</pre>\n\n\n<div class=\"markdown\"><p>As you can see, in just 1 hour of simulated time, our state variable already grew from <code>1</code> to <code>4e16</code>! If that's not exponential growth, we don't know what is ;) </p></div>\n\n\n<div class=\"markdown\"><p>But wait there's more! What if we want to actually save the results?</p><p>The <code>integrator</code> data structure implements the Oceananigans model interface, so we can also use it to set up a <code>Simulation</code>:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>sim = Simulation(integrator; stop_time = 300.0, Œît = 1.0)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-sim\">Simulation of Terrarium.ModelIntegrator{Float64, Oceananigans.Architectures.CPU, Terrarium.ColumnGrid{Float64, Oceananigans.Architectures.CPU, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}}, Terrarium.ForwardEuler{Float64}, Main.var\"workspace#5\".ExpModel{Float64, Terrarium.ColumnGrid{Float64, Oceananigans.Architectures.CPU, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}}, Main.var\"workspace#5\".LinearDynamics{Float64}, Terrarium.FieldInitializers{(:u,), Terrarium.DefaultInitializer, Tuple{Float64}}}, Terrarium.StateVariables{Float64, (:u,), (:u,), (:c,), (:F,), (), Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{}, Oceananigans.TimeSteppers.Clock{Float64, Float64, Int64, Int64}}, Terrarium.InputSources{Tuple{Terrarium.FieldTimeSeriesInputSource{Float64, Terrarium.XY{Oceananigans.Grids.Center, Oceananigans.Grids.Center}, (:F,), Tuple{Oceananigans.OutputReaders.FieldTimeSeries{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Oceananigans.OutputReaders.Clamp, Oceananigans.OutputReaders.InMemory{Nothing}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing, Nothing, @NamedTuple{}}}}}}}\n‚îú‚îÄ‚îÄ Next time step: 1 second\n‚îú‚îÄ‚îÄ run_wall_time: 0 seconds\n‚îú‚îÄ‚îÄ run_wall_time / iteration: 0 seconds\n‚îú‚îÄ‚îÄ stop_time: 5 minutes\n‚îú‚îÄ‚îÄ stop_iteration: Inf\n‚îú‚îÄ‚îÄ wall_time_limit: Inf\n‚îú‚îÄ‚îÄ minimum_relative_step: 0.0\n‚îú‚îÄ‚îÄ callbacks: OrderedDict with 3 entries:\n‚îÇ   ‚îú‚îÄ‚îÄ stop_time_exceeded =&gt; Callback of stop_time_exceeded on IterationInterval(1)\n‚îÇ   ‚îú‚îÄ‚îÄ stop_iteration_exceeded =&gt; Callback of stop_iteration_exceeded on IterationInterval(1)\n‚îÇ   ‚îî‚îÄ‚îÄ wall_time_limit_exceeded =&gt; Callback of wall_time_limit_exceeded on IterationInterval(1)\n‚îî‚îÄ‚îÄ output_writers: OrderedDict with no entries</pre>\n\n\n<div class=\"markdown\"><p>We can then add an output writer to the simulation,</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    # We need to import some types from Oceananigans here for output handling\n    using Oceananigans: TimeInterval, JLD2Writer\n    using Oceananigans.Units: seconds\n\n    # Reset the integrator to its initial state\n    Terrarium.initialize!(integrator)\n\n    output_file = tempname()\n    sim.output_writers[:snapshots] = JLD2Writer(\n        integrator,\n        (u = integrator.state.u,);\n        filename = output_file,\n        overwrite_existing = true,\n        schedule = TimeInterval(10seconds)\n    )\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-output_file\">JLD2Writer scheduled on TimeInterval(10 seconds):\n‚îú‚îÄ‚îÄ filepath: ../../../../../../../tmp/jl_K3E3YDGb0d.jld2\n‚îú‚îÄ‚îÄ 1 outputs: u\n‚îú‚îÄ‚îÄ array_type: Array{Float32}\n‚îú‚îÄ‚îÄ including: [:grid]\n‚îú‚îÄ‚îÄ file_splitting: NoFileSplitting\n‚îî‚îÄ‚îÄ file size: 19.9 KiB</pre>\n\n\n<div class=\"markdown\"><p>and finally <code>run!</code> it!</p></div>\n\n<pre class='language-julia'><code class='language-julia'>run!(sim)</code></pre>\n\n\n\n\n\n\n<div class=\"markdown\"><p>Then load the output data and plot the results:</p></div>\n\n<pre class='language-julia'><code class='language-julia'># Load output into field time series\nfts = FieldTimeSeries(output_file, \"u\")</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-fts\">1√ó1√ó1√ó31 FieldTimeSeries{Oceananigans.OutputReaders.InMemory} located at (Center, Center, ‚ãÖ) of u at /tmp/jl_K3E3YDGb0d.jld2\n‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ indices: (:, :, :)\n‚îú‚îÄ‚îÄ time_indexing: Linear()\n‚îú‚îÄ‚îÄ backend: InMemory()\n‚îú‚îÄ‚îÄ path: /tmp/jl_K3E3YDGb0d.jld2\n‚îú‚îÄ‚îÄ name: u\n‚îî‚îÄ‚îÄ data: 3√ó1√ó1√ó31 OffsetArray(::Array{Float64, 4}, 0:2, 1:1, 1:1, 1:31) with eltype Float64 with indices 0:2√ó1:1√ó1:1√ó1:31\n    ‚îî‚îÄ‚îÄ max=129.87, min=-2.59872, mean=33.6325</pre>\n\n<pre class='language-julia'><code class='language-julia'>plot(1:length(fts), [fts[i][1, 1, 1] for i in 1:length(fts)])</code></pre>\n<img height=\"450\" src=\"data:image/png;base64, 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EBipEgAAAIAxesvJh+any9ZnJPbrbMtrjp8aGKkSAAAAgDF6+wtn5Gt3PpSfL9+Qp/KJucdk/3FtgZEqAQAAABijttZGbnjbC3PuN36R/16yLk+mrbWRj519dP7X/zgsMBolAAAAALvB5K72/Pgdf5Brf/NorvzVity1YmO29vbnkAmdOeOIA/OuFx2eIyePD4xWCQAAAMBu0mhpybmzD8m5sw8J7C4lAAAAAFCxkgrdeuutWbduXV7/+tdnpDZt2pRf//rXWbduXaZMmZITTzwx48aNy0itWLEi9913X7Zt25YZM2Zk9uzZaWlpCQAAAADPrpLK9PT05LWvfW127NiR17/+9Xkq27Ztywc/+MF89atfzfbt2zNswoQJueiii3LJJZekra0tO7Ns2bJceOGFuemmmzI4OJhhM2bMyMc+9rGcf/75AQAAAODZU1KZq666Khs3bsz48ePzVHp6enLmmWdmwYIFGTZ58uSsWbMmmzZtyqWXXpp77rkn1113XRqNRp5oyZIleeELX5h169ZlSCkl++67b9avX5/ly5fnzW9+cx555JF84AMfCAAAAADPjpKK3Hjjjbn44oszUn/zN3+TBQsWZMiFF16YD3/4w5k2bVoWL16cD33oQ/nud7+b733ve7n88stz8cUX54nOP//8rFu3Lo1GI1dccUX++I//OF1dXfnFL36RCy64IIsWLcpf/dVf5WUve1me//znBwAAAIBnXsmz7POf/3zuuuuuzJ8/PwsXLsxIrVu3LpdffnmGnH322fnc5z6XRqORIUcccUSuvPLKvPjFL84vf/nLfPzjH8873vGOtLW1ZdgPf/jD/PznP8+QSy+9NH/xF3+RYaeeemq+//3v5wUveEE2btyYf/iHf8g111wTAAAAAJ55Jc+yv/3bv82qVasyWjfccEO2bduWIR/72MfSaDTyeOPGjct73vOevOUtb8kjjzyS2267LWeccUaGXX311RkyZcqUvO9978sTPe95z8sb3vCGfOUrX8kNN9yQ7du3Z9y4cQEAAADgmVXyLPv0pz+d7du3Z9h1112X66+/Pk/l5ptvzpDp06dn1qxZeTJnn312Wltb09/fn1tuuSVnnHFGht18880Z8opXvCJtbW15MnPnzs1XvvKVdHd357bbbstZZ50VAAAAAJ5ZJc+y8847L4+3bNmyXH/99Xkqv/vd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DgAAAADPjpImtmjRogyZNWtWPvWpT2VXurq68ng9PT1529velv7+/kycODF33HFHjjnmmAzp6+vLH/3RH+WGG27Id77znZx//vmZN29eAAAAAHjmlTSxJUuWZMjJJ5+cl73sZRmNK6+8MitWrMiQK6+8Msccc0yGtbW15aqrrsqsWbOydOnSXHbZZZk3b14AAAAAeOaVNLFFixZlyJFHHpnRuu666zLk6KOPztlnn50n6urqyrnnnptPfOIT+elPf5o1a9Zk8uTJAQAAAOCZVdKkBgYGsnTp0gw56qijMlrz58+8g85tAAAgAElEQVTPkD/8wz/MzrzmNa/JJz7xiQwMDOS2227L6173ugAAAADwzCppUsuXL09PT0+GHHHEEfna176WH//4x3nggQdyyCGH5IQTTsirXvWqnHLKKXmiVatWZcOGDRly/PHHZ2de8IIXpKWlJYODg/n9738fAAAAAJ55JU1q0aJFGTZv3rwsXbo0j3fNNdfkkksuyUUXXZRLL70048ePz7CHHnooww499NDsTHt7eyZPnpzVq1dn+fLlAQAAAOCZV9KkFi9enGFLly7N6aefnjlz5mTatGn53e9+l2uvvTYrV67MZz7zmTzyyCO55pprMmzLli0Z1tXVlV3p6urK6tWrs3nz5oxUS0tLRmP58uV5OtauXZve3t709vamvb09AHuzlStXZmBgIP39/WltbQ3A3mpgYCArV65MS0tLBgYGArA36+vry5o1a9LW1pbe3t7QvEqa1KJFizKklJJvfvObedOb3pTH++hHP5rzzz8/N954Y/7t3/4t119/febNm5ch27dvz7COjo7sSkdHR4Zs27YtAAAAADzzSprUu971rrzxjW/M/vvvn6OOOipPdMABB+RrX/tajjzyyGzevDlXXHFF5s2blyGdnZ0Z1tvbm13p6enJkPb29ozU4OBgRqKlpSVDZsyYkaejo6MjPT09Oeigg9LR0RGAvVlra2v6+/szbdq0tLa2BmBvNTAwkEajkUajkUMPPTQAe7Pe3t60tbWlvb09U6dODc2rpEnNnDkzM2fOzK5MnTo1c+fOzbe//e3cc889GTZ+/PgM27p1a3Zl27ZtGdLV1RUAAIDa/erhjbnx/tVZvmF7SqORoyaPz7zjp2b6xHEBaFYle7ijjz46Qx599NFs3Lgx++23X6ZNm5Zhjzzy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\" style=\"object-fit: contain; height: auto;\" width=\"600\"/>\n\n\n<div class=\"markdown\"><p>Well that's it. We defined and ran a simple exponential model with external forcing following the Terrarium <code>AbstractModel</code> interface! Stay tuned for more!</p></div>\n\n<!-- PlutoStaticHTML.End -->","category":"section"},{"location":"#Terrarium.jl","page":"Home","title":"Terrarium.jl","text":"Terrarium.jl is a new and upcoming land model that aims to support hybrid physics- and data-driven land modeling across multiple spatial and temporal scales. We envision Terrarium to be part of a new generation of Earth system component models that combine modularity, interactivity, GPU-compability and auto-differentiability (AD) for seamless integration of process-based and data-driven model components in both global and regional scale simulations.\n\nTerrarium is being developed alongside SpeedyWeather.jl and Oceananigans.jl as the land component of a new, user-friendly, and fully GPU/AD-compatible Earth System Model in the Julia programming language.\n\nwarning: üößüöß Under construction üößüöß\nThis is an early prototype of our model and is not production-ready. Expect things to change rapidly and break often. If you share our vision for a new paradigm of Earth system modeling and would like to get involved in the project, don‚Äôt hesitate to reach out by creating an issue on GitHub issues or sending us an email. We are always happy to welcome new collaborators!","category":"section"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"Pages = [\n    \"overview/mathematical_formulation.md\",\n    \"overview/software_architecture.md\",\n    \"api_reference.md\",\n]\nDepth = 3","category":"section"}]
}
