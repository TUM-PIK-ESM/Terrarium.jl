var documenterSearchIndex = {"docs":
[{"location":"overview/software_architecture/#Software-architecture","page":"Software architecture","title":"Software architecture","text":"warning: üößüöß Under construction üößüöß\nThe architecture of Terrarium.jl is still in an early prototype stage and is the subject of ongoing discussion. This page is a non-exhaustive summary of the current working concept and will be updated accordingly if and when the architecture changes.","category":"section"},{"location":"overview/software_architecture/#Numerical-implementation","page":"Software architecture","title":"Numerical implementation","text":"Terrarium is based on the numerics and finite-volume method operators provided by Oceananigans.jl. All state variables are represented as Oceananigans Fields with computations automatically distributed using KernelAbstractions.jl. Spatial grids in Terrarium are similarly based on the corresponding Oceananigans grids, most prominently the RectilinearGrid which represents a rectangular volume divided orthogonally into smaller control volumes along the X, Y, and Z dimensions.","category":"section"},{"location":"overview/software_architecture/#The-AbstractModel-interface","page":"Software architecture","title":"The AbstractModel interface","text":"A ‚Äúmodel‚Äù in Terrarium represents a collection of parameters and process types that characterize a simulation. All models must be defined as structs that subtype AbstractModel and will typically consist of the following fields/properties:\n\nA grid that defines the discretization of the spatial domain\nAn initializer responsible for initializing state variables\nOne or more processes and/or sub-models that define the state variables and the dynamics of the system\n\nThe distinction between what constitutes a ‚Äúmodel‚Äù versus a ‚Äúprocess‚Äù should be based on whether or not there is a use case for running simulations of that model/process independently from other processes. Models should be built to be independently runnable standalone in a Simulation, while process types simply provide the concrete implementations of the physical processes to be included in a model. Since Terrarium models are composable, it should generally be trivial to convert a process into a full standalone model later (if necessary) without affecting the other model components that depend on it.\n\nAll AbstractModel and AbstractProcess types must additional provide dispatches for the following methods:\n\nvariables(::Model) returns a tuple of variable metadata declaring the state variables. Variables must be one of two types: prognostic or auxiliary (sometimes referred to as ‚Äúdiagnostic‚Äù). Prognostic variables fully characterize the state of the system at any given timestep and are updated according to their tendencies (i.e. G in the aforementioned equation). Tendencies are automatically allocated for each prognostic variable declared by the model.\ncompute_auxiliary!(state, ::Model) computes the values of all auxiliary variables (if necessary) assuming that the prognostic variables of the system in state are available for the current timestep.\ncompute_tendencies!(state, ::Model) computes the tendencies based on the current values of the prognostic and auxiliary variables stored in state.\n\nIn addition, AbstractModel  implementations must also provide dispatches for the following methods:\n\ninitialize!(state, ::Model, ::Initializer) computes any necessary initialization of the model state based on the user-supplied configuration and parameter settings. The additional initializer argument is extracted from the model and allows for alternative dispatches based on various initialization schemes for each model.\ntimestep!(state, ::Model, ::TimeStepper, Œît) updates the prognostic state variables according to the given timestepping scheme. This method can and should be implemented generically for any timestepping scheme but allows for model-specific overrides where necessary.\nget_grid(::Model) returns the spatial grid associated with the model. A default implementation is provided which assumes that the model defines a field named grid.\nget_initializer(::Model) returns the initializer for the model. A default implementation is provided which assumes that the model defines a field named initializer.","category":"section"},{"location":"overview/software_architecture/#State-variables","page":"Software architecture","title":"State variables","text":"State variables are realized as Oceananigans Fields defined over the model grid. Each variable returned by the variables method will be allocated a corresponding Field with boundary conditions and initial values specified by one or more AbstractInitializers defined on the model. This allocation occurs when creating a Simulation by calling  initialize(model). The resulting Simulation object will have a property state of type StateVariables which holds all of the Fields for each state variable defined by the model.\n\nAs an example, suppose we are implementing a new model MyModel and we want to define the necessary state variables. We do this by defining a new dispatch of the variables method:\n\nvariables(::MyModel) = (\n\tprognostic(:progvar, XYZ()),\n\tauxiliary(:auxvar, XYZ()),\n\tauxiliary(:bc, XY()),\n)\n\nThis will result in a total of four state variables being allocated when initialize(model) is called: two auxiliary variables named auxvar and bc as well as one prognostic variable named progvar along with its corresponding tendency which is created automatically. The second argument to the variable metadata constructors prognostic and auxiliary is a subtype of VarDims which specifies on which spatial dimensions the state variable should be defined. XYZ() corresponds to a 3D Field which is discretized both laterally (along spatial grid cells) and along the vertical axis. Currently, Terrarium only supports a single 3D grid representing variables defined in the soil domain, though this may change in the near future in order to accommodate multi-layer snow and canopy processes. XY() corresponds to a 2D field which is discretized along the lateral dimension only. Note that Terrarium also currently supports only 1D (vertical) dynamics so all grid cells on the X and Y axes will be assumed independent. This is equivalent to what is typically called a single column model, or column-based parameterization in atmosphere and ocean modeling. However, building on Oceananigans means that we have a clear path to relax this assumption in the future!","category":"section"},{"location":"physics/soil_energy_water/#Soil-hydrothermal-dynamics","page":"Energy and water balance","title":"Soil hydrothermal dynamics","text":"warning: Warning\nThis page is a work in progress. If you have any questions or notice any errors, please raise an issue.","category":"section"},{"location":"physics/soil_energy_water/#Heat-transfer","page":"Energy and water balance","title":"Heat transfer","text":"Heat transfer along the vertical axis perpendicular to the land surface can be represented according to the heat equation, with the upper boundary set to surface temperature and the lower boundary set to a constant positive heat flux representing heat produced by the inner earth (Lachenbruch 1986, Jaeger 1965). If both the upper and lower boundaries are assumed to be constant over time, the steady-state temperature profile takes the form of a continuous piecewise linear function increasing over depth with the slope determined by the thermal properties of the ground material. The instantaneous temperature field can then be generally represented as\n\nbeginequation\nT(zt) = T_0 + fracQ_textgeokappa_texth(z)z + Delta T(zt)\nendequation\n\nwhere T(zt) is the temperature field (K) over depth z (m) and time t (s), T_0 is the mean annual GST (K), Q_textgeo is the geothermal heat flux (W/m¬≤), and kappa_texth(z) (W/m K) is the thermal conductivity which may vary with depth depending on the material. The last term Delta T(zt) represents transient disturbances to the steady state temperature profile due to both seasonal and long-term fluctuations in the upper and lower boundary conditions of the vertical domain. Simulating the impacts of these transient changes is one of the primary objectives of most numerical permafrost and land surface models.\n\nDiffusive heat flow in a solid medium is governed by Fourier's law,\n\nbeginequation\n    mathbfj_texth cdot mathbfn_z = -kappa_texthfracpartial Tpartial z\nendequation\n\nwhere mathbfj_texth (W/m¬≤) is the diffusive heat flux vector and mathbfn_z is the upward facing normal vector along the vertical z axis.\n\nSince ground materials are often porous, i.e., there exists void space between the solid particles, it is necessary to consider the potential presence of water and/or ice in this void space, which is hereafter referred to as pore space, or simply, soil pores. The thermal effects of water and ice can be accounted for by considering not only the temperature of the material but rather the total internal energy of the elementary volume. Combining the diffusive flux with a potential advective heat flux j_z^textw due to water flow yields the energy conservation law,\n\nbeginequation\nfracpartial U(Ttheta)partial t - nabla cdot left(mathbfj_texth + mathbfj_h^textwright) - F_h(zt) = 0\nendequation\n\nwhere U(Ttheta) (J/m¬≥) is the volumetric internal energy as a function of temperature and total water/ice content theta (m¬≥/m¬≥), and F_h(zt) is an inhomogeneous heat source/sink (forcing) term.\n\nThe advective heat flux j_texth^textw can be represented as,\n\nbeginequation\nmathbfj_texth^textw = left( c_textw T + L_textsl right) mathbfj_textw rho_textw\nendequation\n\nwhere L_textsl and c_textw (J/kg) represent the specific latent heat of fusion and heat capacity of liquid water respectively. This flux term accounts for the energy transferred by the movement of water within the soil matrix. In model configurations that neglect subsurface water flow, this flux term is implicitly assumed to be zero.","category":"section"},{"location":"physics/soil_energy_water/#Energy-temperature-closure","page":"Energy and water balance","title":"Energy-temperature closure","text":"The constitutive relationship between energy and temperature plays a key role in characterizing the subsurface energy balance. This relation can be defined in integral form as\n\nbeginequation\n    U(Ttheta) = int_T_textref^T tildeC(xtheta)  dx\n    = overbraceHC(thetawthetai)leftT-T_textrefright^textSensible + overbracedensityw LHFthetaw(Tthetawi)^textLatent\nendequation\n\nwhere tildeC is referred to as the effective or apparent heat capacity and T_textref is a reference temperature. The apparent heat capacity is then defined as the derivative of the energ-temperature relation,\n\nbeginequation\ntildeC(Ttheta) = fracpartial Upartial T =\noverbraceC(theta_textwtheta) + T fracpartial Cpartial theta_textwfracpartial theta_textwpartial T^textSensible +\noverbracerho_textw L_textsl fracpartialtheta_textwpartial T^textLatent\nendequation\n\nwhere theta_textw(Ttheta) is the volumetric unfrozen water content as a function of temperature and total water/ice content is the bulk volumetric material heat capacity of the volume as a function of the unfrozen and total water contents;  rho_textw (kg/m¬≥) and L_textsl (J/kg) correspond to the density and specific latent heat of fusion of water, respectively. The grouping of terms on the right-hand side show the partitioning of energy change into sensible and latent heat. The sensible component represents the energy necessary to heat a volume of the material to a particular temperature, whereas the latent component corresponds to the energy required for the phase change of water in the volume from solid (frozen) to liquid (thawed).\n\nIn the simplest case where we neglect the effect of capillary action in the soil, the energy-temperature relation can be derived according to that of \"free\" water (i.e. unbound by the soil matrix),\n\nbeginequation\n    theta_textw(U) =\n        begincases\n            0                    U  -rho_textwL_textsltheta \n            fracUL  -rho_textwL_textsltheta leq U  0 \n            theta               U geq 0\n        endcases\nendequation\n\nwith temperature then determined by\n\nbeginequation\n    U^-1(U(Ttheta)) =\n    begincases\n    fracU(Ttheta) - rho_textwL_textslthetaC  U(Ttheta)  -rho_textwL_textsltheta \n    0  0 leq U(Ttheta) leq rho_textwL_textsltheta \n    fracU(Ttheta)C    U(Ttheta) geq 0\n    endcases\nendequation\n\nwhere C = C(theta_textwtheta) is the volumetric heat capacity (J/K/m¬≥) as a function of the unfrozen and total water content.","category":"section"},{"location":"physics/soil_energy_water/#Vertical-water-transport-in-variably-saturated-soil","page":"Energy and water balance","title":"Vertical water transport in variably saturated soil","text":"The vertical flow of water in porous media, such as soils, can be formulated as following the conservation law\n\n    phifracpartialvartheta(psi)partial t - nabla cdot textbfj_textw - F_textw(zt) = 0\n\nwhere phi is the natural porosity (or saturated water content) of the soil volume and F_textw(zt) (m/s) is an inhomogeneous source/sink (forcing) term.\n\nVertical fluxes in the soil column be represented by combining gravity-driven advection with Darcy's law\n\nbeginequation\ntextbfj_textw cdot mathbfn = -kappa_textwfracpartial left(psi + zright)partial z\nendequation\n\nwhere psi (m) is the matric potential. Substituting this equation into the aforementioned conservation law yields the widely known Richardson-Richards equation for variably saturated flow in porous media (Richards 1931).","category":"section"},{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_reference/#Core.Type-Union{Tuple{Model}, Tuple{Terrarium.AbstractLandGrid, Vararg{Any}}} where Model<:Terrarium.AbstractModel","page":"API Reference","title":"Core.Type","text":"Convenience constructor for all AbstractModel types that allows the grid to be passed as the first positional argument.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.Fields.Field","page":"API Reference","title":"Oceananigans.Fields.Field","text":"Field(\n    grid::AbstractLandGrid,\n    dims::VarDims,\n    boundary_conditions = nothing,\n    args...;\n    kwargs...\n)\n\nAuxiliary constructor for an Oceananigans Field on grid with the given Terrarium variable dims and boundary conditions. Additional arguments are passed direclty to the Field constructor. The location of the Field is determined by VarDims defined on var.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Oceananigans.OutputReaders.FieldTimeSeries","page":"API Reference","title":"Oceananigans.OutputReaders.FieldTimeSeries","text":"FieldTimeSeries(\n    grid::AbstractLandGrid,\n    dims::VarDims,\n    times=eltype(grid)[]\n)\n\nConstruct a FieldTimeSeries on the given land grid with the given dims and times.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RingGrids.Field-Union{Tuple{LY}, Tuple{LX}, Tuple{Field{LX, LY, Nothing}, ColumnRingGrid}} where {LX, LY}","page":"API Reference","title":"RingGrids.Field","text":"Field(field, grid; fill_value)\n\n\nConverts the given Oceananigans Field to a RingGrids.Field with a ring grid matching that of the given ColumnRingGrid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.AbstractAlbedo","page":"API Reference","title":"Terrarium.AbstractAlbedo","text":"Base type for surface albedo and emissivity parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractAtmosphere","page":"API Reference","title":"Terrarium.AbstractAtmosphere","text":"abstract type AbstractAtmosphere{NF, PR<:Terrarium.AbstractPrecipitation, IR<:Terrarium.AbstractIncomingRadiation, HM<:Terrarium.AbstractHumidity, AD<:Terrarium.AbstractAerodynamics{NF}} <: Terrarium.AbstractProcess{NF}\n\nBase type for representations of the atmosphere that provide meterological state variables such as air temperature and pressure, humidity, precipitation, incoming solar radiation, tracer gas concentrations, wind speed, and near-surface aerodynamics.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractAutotrophicRespiration","page":"API Reference","title":"Terrarium.AbstractAutotrophicRespiration","text":"abstract type AbstractAutotrophicRespiration{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for autotrophic respiration schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractBulkWeightingScheme","page":"API Reference","title":"Terrarium.AbstractBulkWeightingScheme","text":"Base type for bulk weighting/mixing schemes that calculate weighted mixture of material properties such as conductivities or densities.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractCanopyInterception","page":"API Reference","title":"Terrarium.AbstractCanopyInterception","text":"Base type for canopy interception process implementations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractClosureRelation","page":"API Reference","title":"Terrarium.AbstractClosureRelation","text":"abstract type AbstractClosureRelation\n\nBase type for prognostic variable closure relations for differential equations of the form:\n\nfracpartial g(u)partial t = F(u)\n\nwhere F represents the RHS tendency as a function of the state variable u, and g(u) is a closure or constitutive relation that maps u to the physical units matching the tendency. Common examples in soil hydrothermal modeling are temperature-enthalpy and saturation-pressure relations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractCoupledProcesses","page":"API Reference","title":"Terrarium.AbstractCoupledProcesses","text":"abstract type AbstractCoupledProcesses{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for AbstractProces implementations that define a coupling interface for (typically two or more) sub-processes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractEvapotranspiration","page":"API Reference","title":"Terrarium.AbstractEvapotranspiration","text":"Base type for evapotranspiration processes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractGround","page":"API Reference","title":"Terrarium.AbstractGround","text":"abstract type AbstractGround{NF} <: Terrarium.AbstractCoupledProcesses{NF}\n\nBase type for coupled ground processes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractGroundEvaporationResistanceFactor","page":"API Reference","title":"Terrarium.AbstractGroundEvaporationResistanceFactor","text":"Base type for evaporation resistance parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractGroundModel","page":"API Reference","title":"Terrarium.AbstractGroundModel","text":"abstract type AbstractGroundModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for ground (e.g. soil and rock) models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractHeatOperator","page":"API Reference","title":"Terrarium.AbstractHeatOperator","text":"abstract type AbstractHeatOperator\n\nBase type for formulations of the heat transfer operator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractHydrologyModel","page":"API Reference","title":"Terrarium.AbstractHydrologyModel","text":"abstract type AbstractHydrologyModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for surface hydrology models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractInitializer","page":"API Reference","title":"Terrarium.AbstractInitializer","text":"Base type for model initializers. Implementations should provide a dispatch of the initialize!(state, model::M, init::I) method where M corresponds to the model type and I to the initializer. An implementation of get_field_initializers can also be provided which returns a NamedTuple of initializer functions for individual state variable fields.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractLandModel","page":"API Reference","title":"Terrarium.AbstractLandModel","text":"AbstractLandModel <: AbstractModel\n\nBase type for full land models which couple together multiple component models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractModel","page":"API Reference","title":"Terrarium.AbstractModel","text":"abstract type AbstractModel{NF, Grid<:(Terrarium.AbstractLandGrid{NF})}\n\nBase type for all Terrarium \"models\". Models are standalone representations of a system that consist of\n\n(i) a spatial grid characterizing the model domain, (ii) zero or more AbstractProcesses defining the dynamics, and (iii) an AbstractInitializer responsible for defining the initial state of the model.\n\nImplementations of AbstractModel are required to implement, at minimum, three methods:\n\nvariables which declares the state variables requried by the model,\ncompute_auxiliary! which is responsible for computing all auxiliary (non-prognostic) variables,\ncompute_tendencies! which is responsible for computing the tendencies of all prognostic variables.\n\nNote that a default implementation of variables is provided which automatically collects all variables declared by AbstractProcesses defined as fields (properties) of structs that subtype AbstractModel.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractPhenology","page":"API Reference","title":"Terrarium.AbstractPhenology","text":"abstract type AbstractPhenology{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for vegetation phenology schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractPhotosynthesis","page":"API Reference","title":"Terrarium.AbstractPhotosynthesis","text":"abstract type AbstractPhotosynthesis{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for photosyntheis schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractPlantAvailableWater","page":"API Reference","title":"Terrarium.AbstractPlantAvailableWater","text":"abstract type AbstractPlantAvailableWater{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for processes that comptue the plant available water fraction in each soil layer.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractProcess","page":"API Reference","title":"Terrarium.AbstractProcess","text":"abstract type AbstractProcess{NF}\n\nBase type for all \"processes\". Implementations of AbstractProcess define equations, state variables, and parameterizations which characterize the dynamics of a system at for any given transient state. Note that processes should be largely agnostic to the details regarding spatial and temporal discretization of the model; i.e. they should not require specification of a specific grid or time stepping scheme but rather should be able to operate on any given set of Fields and parameters representing the state of a model at any point in time. Note that process types may also wrap/orchestrate one or more other process types.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractProcessVariable","page":"API Reference","title":"Terrarium.AbstractProcessVariable","text":"Baste type for process state variables with specific intents, e.g. prognostic, auxiliary, or input.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractRadiativeFluxes","page":"API Reference","title":"Terrarium.AbstractRadiativeFluxes","text":"abstract type AbstractRadiativeFluxes{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for radiative flux parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractRootDistribution","page":"API Reference","title":"Terrarium.AbstractRootDistribution","text":"abstract type AbstractRootDistribution{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for vegetation root distribution schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSkinTemperature","page":"API Reference","title":"Terrarium.AbstractSkinTemperature","text":"Base type for skin temperature and ground heat flux schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSnowModel","page":"API Reference","title":"Terrarium.AbstractSnowModel","text":"abstract type AbstractSnowModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for snow models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoil","page":"API Reference","title":"Terrarium.AbstractSoil","text":"abstract type AbstractSoil{NF} <: Terrarium.AbstractGround{NF}\n\nBase type for coupled soil processes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilEnergyClosure","page":"API Reference","title":"Terrarium.AbstractSoilEnergyClosure","text":"abstract type AbstractSoilEnergyClosure <: Terrarium.AbstractClosureRelation\n\nBase type for closure relations between energy and temperature in soil volumes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilHydraulics","page":"API Reference","title":"Terrarium.AbstractSoilHydraulics","text":"abstract type AbstractSoilHydraulics{NF, RC<:SWRC, UnsatK<:Terrarium.AbstractUnsatK}\n\nBase type for soil hydraulic properties and parameterization schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilModel","page":"API Reference","title":"Terrarium.AbstractSoilModel","text":"abstract type AbstractSoilModel{NF, GR} <: Terrarium.AbstractGroundModel{NF, GR}\n\nBase type for soil ground models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilPorosity","page":"API Reference","title":"Terrarium.AbstractSoilPorosity","text":"abstract type AbstractSoilPorosity{NF}\n\nBase type for parameterizations of soil porosity.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilTexture","page":"API Reference","title":"Terrarium.AbstractSoilTexture","text":"abstract type AbstractSoilTexture{NF}\n\nBase type for mineral soil texture parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSoilWaterClosure","page":"API Reference","title":"Terrarium.AbstractSoilWaterClosure","text":"abstract type AbstractSoilWaterClosure <: Terrarium.AbstractClosureRelation\n\nBase type for closure relations between water saturation and potential in soil volumes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractStomatalConductance","page":"API Reference","title":"Terrarium.AbstractStomatalConductance","text":"abstract type AbstractStomatalConductance{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for stomatal conductance schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractStratigraphy","page":"API Reference","title":"Terrarium.AbstractStratigraphy","text":"abstract type AbstractStratigraphy{NF}\n\nBase type for soil stratigraphy parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSurfaceEnergyBalance","page":"API Reference","title":"Terrarium.AbstractSurfaceEnergyBalance","text":"Base type for surface energy balance schemes which couple together the relevant processes for radiative and turbulent surface energy fluxes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSurfaceEnergyModel","page":"API Reference","title":"Terrarium.AbstractSurfaceEnergyModel","text":"abstract type AbstractSurfaceEnergyModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for land-atmosphere energy exchange models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSurfaceHydrology","page":"API Reference","title":"Terrarium.AbstractSurfaceHydrology","text":"Base type for coupled surface hydrology processes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractSurfaceRunoff","page":"API Reference","title":"Terrarium.AbstractSurfaceRunoff","text":"Base type for surface runoff processes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractTimeStepper","page":"API Reference","title":"Terrarium.AbstractTimeStepper","text":"Base type for time steppers.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractTimeStepperCache","page":"API Reference","title":"Terrarium.AbstractTimeStepperCache","text":"Base type for time-stepper state caches.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractTurbulentFluxes","page":"API Reference","title":"Terrarium.AbstractTurbulentFluxes","text":"Base type for turbulent (latent and sensible) heat flux parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractUnsatK","page":"API Reference","title":"Terrarium.AbstractUnsatK","text":"abstract type AbstractUnsatK{NF}\n\nBase type for unsaturated hydraulic conductivity parameterizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVariable","page":"API Reference","title":"Terrarium.AbstractVariable","text":"Base type for state variable placeholder types.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVegetationCarbonDynamics","page":"API Reference","title":"Terrarium.AbstractVegetationCarbonDynamics","text":"abstract type AbstractVegetationCarbonDynamics{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for vegetation carbon dynamics schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVegetationDynamics","page":"API Reference","title":"Terrarium.AbstractVegetationDynamics","text":"abstract type AbstractVegetationDynamics{NF} <: Terrarium.AbstractProcess{NF}\n\nBase type for vegetation dynamics schemes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVegetationModel","page":"API Reference","title":"Terrarium.AbstractVegetationModel","text":"abstract type AbstractVegetationModel{NF, GR} <: Terrarium.AbstractModel{NF, GR}\n\nBase type for vegetation models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVerticalFlow","page":"API Reference","title":"Terrarium.AbstractVerticalFlow","text":"Base type for implementations of soil water flow dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AbstractVerticalSpacing","page":"API Reference","title":"Terrarium.AbstractVerticalSpacing","text":"abstract type AbstractVerticalSpacing{NF}\n\nBase type for vertical discretizations.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AnyField","page":"API Reference","title":"Terrarium.AnyField","text":"Type alias for an AbstractField with any X, Y, Z location or grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AnyFieldTimeSeries","page":"API Reference","title":"Terrarium.AnyFieldTimeSeries","text":"Type alias for a FieldTimeSeries with any X, Y, Z location or grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.AuxiliaryVariable","page":"API Reference","title":"Terrarium.AuxiliaryVariable","text":"struct AuxiliaryVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units, Var<:Terrarium.Variable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}, DT<:IntervalSets.AbstractInterval, FC<:Union{Nothing, Function}} <: Terrarium.AbstractProcessVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}\n\nRepresents an auxiliary (a.k.a \"diagnostic\") state variable with the given name and spatial dims. Auxiliary variables are those which are diagnosed directly or indirectly from the values of one or more prognostic variables.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.BCType","page":"API Reference","title":"Terrarium.BCType","text":"Alias for Oceananigans AbstractBoundaryConditionClassification.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ColumnGrid","page":"API Reference","title":"Terrarium.ColumnGrid","text":"ColumnGrid{NF, Arch<:AbstractArchitecture, RectGrid<:Oceananigans.Grids.RectilinearGrid} <: AbstractLandGrid\n\nRepresents a set of laterally independent vertical columns with dimensions (x, y, z) where x is the column dimension, y=1 is constant, and z is the vertical axis.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ColumnRingGrid","page":"API Reference","title":"Terrarium.ColumnRingGrid","text":"struct ColumnRingGrid{NF, Arch, RingGrid<:RingGrids.AbstractGrid, RectGrid<:Oceananigans.Grids.RectilinearGrid, Mask<:AbstractArray} <: Terrarium.AbstractColumnGrid{NF, Arch}\n\nRepresents a global (spherical) grid of independent, vertical columns where the spatial discretization in the horizontal direction is defined by a RingGrids.AbstractGrid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantAerodynamics","page":"API Reference","title":"Terrarium.ConstantAerodynamics","text":"struct ConstantAerodynamics{NF} <: Terrarium.AbstractAerodynamics{NF}\n\nDummy implementation of aerodynamics that simply returns constant values for all drag coefficients.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantAlbedo","page":"API Reference","title":"Terrarium.ConstantAlbedo","text":"struct ConstantAlbedo{NF} <: Terrarium.AbstractAlbedo{NF}\n\nProperties:\n\nalbedo::Any: Surface albedo, i.e. ratio of outgoing to incoming shortwave radiation [-]\nemissivity::Any: Surface emissivity, i.e. fraction of thermal radiation emitted from the surface [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantInitialSoilTemperature","page":"API Reference","title":"Terrarium.ConstantInitialSoilTemperature","text":"struct ConstantInitialSoilTemperature{NF} <: Terrarium.AbstractInitializer{NF}\n\nInitializer for soil/ground temperature that sets the temperature profile to a constant value.\n\nProperties:\n\nT‚ÇÄ::Any\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantInitialSoilTemperature-Union{Tuple{Type{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.ConstantInitialSoilTemperature","text":"Creates a constant soil temperature initializer.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.ConstantSoilCarbonDensity","page":"API Reference","title":"Terrarium.ConstantSoilCarbonDensity","text":"struct ConstantSoilCarbonDensity{NF} <: Terrarium.AbstractSoilBiogeochemistry{NF}\n\nNaive implementation of soil biogeochemistry that just assumes there to be a constant organic content in all soil layers.\n\nProperties:\n\nœÅ_soc::Any: Soil organic carbon density [kg/m^3]\nœÅ_org::Any: Pure organic matter density [kg/m^3]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantSoilHydraulics","page":"API Reference","title":"Terrarium.ConstantSoilHydraulics","text":"struct ConstantSoilHydraulics{NF, RC, UnsatK<:Terrarium.AbstractUnsatK{NF}} <: Terrarium.AbstractSoilHydraulics{NF, RC, UnsatK<:Terrarium.AbstractUnsatK{NF}}\n\nRepresents a simple case where soil hydraulic properties are given as constant values. This is mostly provided just for testing, although it may be useful in certain cases where direct measurements of hydraulic properites are available.\n\nProperties:\n\nswrc::Any: Soil water retention curve\nunsat_hydraulic_cond::Terrarium.AbstractUnsatK: Unsaturated hydraulic conductivity formulation; defaults to sat_hydraulic_cond\nsat_hydraulic_cond::Any: Hydraulic conductivity at saturation [m/s]\nfield_capacity::Any: Prescribed field capacity [-]\nwilting_point::Any: Prescribed wilting point [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ConstantSoilPorosity","page":"API Reference","title":"Terrarium.ConstantSoilPorosity","text":"struct ConstantSoilPorosity{NF} <: Terrarium.AbstractSoilPorosity{NF}\n\nParameterization of soil porosity that simply specifies constant values for the mineral and organic components.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.DefaultInitializer","page":"API Reference","title":"Terrarium.DefaultInitializer","text":"Marker type for a no-op initializer that leaves all Fields set to their default values.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.DiagnosedRadiativeFluxes","page":"API Reference","title":"Terrarium.DiagnosedRadiativeFluxes","text":"struct DiagnosedRadiativeFluxes{NF} <: Terrarium.AbstractRadiativeFluxes{NF}\n\nComputes outgoing shortwave and longwave radiation according to separately specified schemes for the albedo, skin temperature, and atmospheric inputs.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.DiagnosedTurbulentFluxes","page":"API Reference","title":"Terrarium.DiagnosedTurbulentFluxes","text":"struct DiagnosedTurbulentFluxes{NF} <: Terrarium.AbstractTurbulentFluxes{NF}\n\nRepresents the standard case where the turbulent (sensible and latent) heat fluxes are diagnosed from atmosphere and soil conditions.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.DirectSurfaceRunoff","page":"API Reference","title":"Terrarium.DirectSurfaceRunoff","text":"struct DirectSurfaceRunoff{NF} <: Terrarium.AbstractSurfaceRunoff{NF}\n\nSimple surface runoff scheme that computes runoff as\n\nR = P + D - I\n\nwhere P is precipitation reaching the ground, D is drainage from accumualted excess water at the surface, and I is infiltration into the soil.\n\nProperties:\n\nœÑ_r: Surface water removal timescale\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ExplicitTwoPhaseHeatConduction","page":"API Reference","title":"Terrarium.ExplicitTwoPhaseHeatConduction","text":"struct ExplicitTwoPhaseHeatConduction <: Terrarium.AbstractHeatOperator\n\nRepresents an explicit formulation of the two-phase heat conduction operator in 1D:\n\nfracpartial U(Tphi)partial t = nabla cdot kappa(T)nabla_x T(xt)\n\nwhere T is temperature [K], U is internal energy [J m‚Åª¬≥], and kappa is the thermal conductivity [W m K‚Åª¬π].\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ExponentialSpacing","page":"API Reference","title":"Terrarium.ExponentialSpacing","text":"struct ExponentialSpacing{NF, ST<:Union{Nothing, Integer}} <: Terrarium.AbstractVerticalSpacing{NF}\n\nVariably-spaced vertical discretization with N layers increasing quasi-exponentially in thickness from Œîz_min at the top (surface) to Œîz_max at the bottom. The integer property sig determines to what significant digit each layer thickness should be rounded.\n\nProperties:\n\nŒîz_min::Any: Minimum layer thickness at the surface\nŒîz_max::Any: Maximum layer thickness at the bottom\nN::Int64: Number of layers\nsig::Union{Nothing, Integer}: Number of significant digits for rounding or nothing\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldBCs","page":"API Reference","title":"Terrarium.FieldBCs","text":"Alias for a NamedTuple of FieldBC types where the keys correspond to field/variable names.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldCapacityLimitedPAW","page":"API Reference","title":"Terrarium.FieldCapacityLimitedPAW","text":"struct FieldCapacityLimitedPAW{NF} <: Terrarium.AbstractPlantAvailableWater{NF}\n\nImplementation of vegetation water availability (a.k.a \"plant available water\") that computes the wilting fraction\n\nW_i = min(fractheta_textwi - theta_textwpitheta_textfci - theta_textwpi 1)\n\nwhere theta_textwi is the volumetric water content of the i'th soil layer, theta_textfci is the \"field capacity\", and theta_textwpi is the \"wilting point\". The water availability\n\nProperties:\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldInputSource","page":"API Reference","title":"Terrarium.FieldInputSource","text":"struct FieldInputSource{NF, VD<:Terrarium.VarDims, names} <: InputSource{NF}\n\nInput source that defines input state variables with the given names which can then be directly modified by the user.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldTimeSeriesInputSource","page":"API Reference","title":"Terrarium.FieldTimeSeriesInputSource","text":"struct FieldTimeSeriesInputSource{NF, VD<:Terrarium.VarDims, names, FTS<:Tuple{Vararg{FieldTimeSeries{LX, LY, LZ, TI, K, I, D, G, NF} where {LX, LY, LZ, TI, K, I, D, G}}}} <: InputSource{NF}\n\nInput source that reads input fields from pre-specified Oceananigans FieldTimeSeries.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ForwardEuler","page":"API Reference","title":"Terrarium.ForwardEuler","text":"struct ForwardEuler{NF} <: Terrarium.AbstractTimeStepper{NF}\n\nSimple forward Euler time stepping scheme.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.GroundEvaporation","page":"API Reference","title":"Terrarium.GroundEvaporation","text":"GroundEvaporation{NF, GR} <: AbstractEvapotranspiration\n\nEvaporation scheme for bare ground that calculates the humidity flux as\n\nE = beta fracDelta qr_a\n\nwhere Œîq is the vapor pressure deficit in terms of specific humidity, r‚Çê is aerodynamic resistance, and Œ≤ is an evaporation limiting factor.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Heun","page":"API Reference","title":"Terrarium.Heun","text":"struct Heun{NF, Stage} <: Terrarium.AbstractTimeStepper{NF}\n\nSimple forward 2nd order Heun / improved Euler time stepping scheme.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.HomogeneousStratigraphy","page":"API Reference","title":"Terrarium.HomogeneousStratigraphy","text":"struct HomogeneousStratigraphy{NF, SoilPorosity<:Terrarium.AbstractSoilPorosity{NF}} <: Terrarium.AbstractStratigraphy{NF}\n\nRepresents a soil stratigraphy of well mixed material with homogeneous soil texture.\n\nProperties:\n\ntexture::SoilTexture: Material composition of mineral soil component\nporosity::Terrarium.AbstractSoilPorosity: Parameterization of soil porosity\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ImplicitSkinTemperature","page":"API Reference","title":"Terrarium.ImplicitSkinTemperature","text":"struct ImplicitSkinTemperature{NF} <: Terrarium.AbstractSkinTemperature{NF}\n\nScheme for an implicit skin temperature T_0 satisfying:\n\nR_textnet(T_0) = H_s(T_0) + H_l(T_0) + G(T_0 T_1)\n\nwhere R_textnet is the net radiation budget, H_s is the sensible heat flux, H_l is the latent heat flux from sublimation and evapotranspiration, G is the ground heat flux, and T_1 is the ground temperature, or temperature of the uppermost subsurface (soil or snow) layer.\n\nProperties:\n\nŒ∫‚Çõ: Assumed thermal conductivity at the surface [W m‚Åª¬π K‚Åª¬π]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.InputSource","page":"API Reference","title":"Terrarium.InputSource","text":"abstract type InputSource{NF}\n\nBase type for input data sources. Implementations of InputSource are free to load data from any arbitrary backend but are required to implement the update_inputs!(fields, ::InputSource, ::Clock) method. Implementations should additionally provide a constructor as a dispatch of InputSource.\n\nThe type argument NF corresponds to the numeric type of the input data.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.InputSource-Union{Tuple{NF}, Tuple{Type{NF}, Vararg{Symbol}}} where NF","page":"API Reference","title":"Terrarium.InputSource","text":"InputSource(::Type{NF}, names::Symbol...; dims = XY())\n\nCreate a FieldInputSource with the given numeric type and input variable names.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.InputSources","page":"API Reference","title":"Terrarium.InputSources","text":"Container type for wrapping multiple InputSources.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.InputVariable","page":"API Reference","title":"Terrarium.InputVariable","text":"struct InputVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units, Var<:Terrarium.Variable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}, DT<:IntervalSets.AbstractInterval, Def<:Union{Nothing, Function, Number}} <: Terrarium.AbstractProcessVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}\n\nRepresents an input (e.g. forcing) variable with the given name and spatial dims.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.InverseQuadratic","page":"API Reference","title":"Terrarium.InverseQuadratic","text":"The inverse quadratic (or \"quadratic parallel\") bulk thermal conductivity formula (Cosenza et al. 2003):\n\nk = sum_i=1^N Œ∏·µ¢sqrtk·µ¢^2\n\nCosenza, P., Gu√©rin, R., and Tabbagh, A.: Relationship between thermal conductivity and water content of soils using numerical modelling, European Journal of Soil Science, 54, 581‚Äì588, https://doi.org/10.1046/j.1365-2389.2003.00539.x, 2003.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.LUEPhotosynthesis","page":"API Reference","title":"Terrarium.LUEPhotosynthesis","text":"struct LUEPhotosynthesis{NF} <: Terrarium.AbstractPhotosynthesis{NF}\n\nPhotosynthesis implementation from PALADYN (Willeit 2016) for C3 PFTs following the general light use efficiency model described in Haxeltine and Prentice 1996.\n\nAuthors: Maha Badri and Matteo Willeit\n\nProperties:\n\nœÑ25::Any: Value of œÑ at 25¬∞C\nKc25::Any: Value of Kc at 25¬∞C\nKo25::Any: Value of Ko at 25¬∞C\nq10_œÑ::Any: q10 for temperature-sensitive parameter œÑ\nq10_Kc::Any: q10 for temperature-sensitive parameter Kc\nq10_Ko::Any: q10 for temperature-sensitive parameter Ko\nŒ±_leaf::Any: Leaf albedo in PAR range [-]\ncq::Any: Conversion factor for solar radiation at 550 nm from J/m¬≤ to mol/m¬≤ [mol/J]\nk_ext::Any: Extinction coefficient for radiation through vegetation [-]\nŒ±_a::Any: Fraction of PAR assimilated at ecosystem level, relative to leaf level [-]\nt_CO2_high::Any: Parameter, PFT specific [¬∞C]\nt_CO2_low::Any: Parameter, PFT specific [¬∞C]\nt_photos_high::Any: Parameter, PFT specific [¬∞C]\nt_photos_low::Any: Parameter, PFT specific [¬∞C]\nŒ±_C3::Any: Intrinsic quantum efficiency of CO2 uptake in C3 plants [mol/mol]\nC_mass::Any: Atomic mass of carbon [gC/mol]\nŒ∏_r::Any: Shape parameter [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.LengthQuantity","page":"API Reference","title":"Terrarium.LengthQuantity","text":"Alias for numeric Quantity with type NF and units U.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.MedlynStomatalConductance","page":"API Reference","title":"Terrarium.MedlynStomatalConductance","text":"struct MedlynStomatalConductance{NF} <: Terrarium.AbstractStomatalConductance{NF}\n\nStomatal conductance implementation from PALADYN (Willeit 2016) following the optimal stomatal conductance model (Medlyn et al. 2011).\n\nAuthors: Maha Badri and Matteo Willeit\n\nProperties:\n\ng‚ÇÅ::Any: Parameter in optimal stomatal conductance formulation representing the quasi-linear     relationship between conductance and net assimilation, Lin et al. 2015 [-], PFT specific\ng_min::Any: Minimum stomatal condutance parameter [mm s‚Åª¬π]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.MineralOrganic","page":"API Reference","title":"Terrarium.MineralOrganic","text":"struct MineralOrganic{NF} <: Terrarium.AbstractSoilMatrix{NF}\n\nSoil matrix consisting of a simple, homogeneous mixture of mineral and organic material.\n\nProperties:\n\ntexture::SoilTexture: Mineral soil texture\norganic::Any: Organic soil fraction\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.MineralOrganicSoil","page":"API Reference","title":"Terrarium.MineralOrganicSoil","text":"Alias for SoilVolume{T, MineralOrganic{T}}\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ModelIntegrator","page":"API Reference","title":"Terrarium.ModelIntegrator","text":"struct ModelIntegrator{NF, Arch<:Oceananigans.Architectures.AbstractArchitecture, Grid<:Terrarium.AbstractLandGrid{NF, Arch<:Oceananigans.Architectures.AbstractArchitecture}, TimeStepper<:Terrarium.AbstractTimeStepper{NF}, Model<:Terrarium.AbstractModel{NF, Grid<:Terrarium.AbstractLandGrid{NF, Arch<:Oceananigans.Architectures.AbstractArchitecture}}, StateVars<:Terrarium.AbstractStateVariables, Inits<:NamedTuple, Inputs<:InputSources} <: Oceananigans.AbstractModel{TimeStepper<:Terrarium.AbstractTimeStepper{NF}, Arch<:Oceananigans.Architectures.AbstractArchitecture}\n\nRepresents a \"integrator\" for a simulation of a given model. ModelIntegrator consists of a clock, a model, and an initialized StateVariables data structure, as well as a stage for the timestepper and any relevant inputs provided by a corresponding InputProvider. The ModelIntegrator implements the Oceananigans.AbstractModel interface and can thus be treated as a \"model\" in Oceananigans Simulations and output reading/writing utilities.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Namespace","page":"API Reference","title":"Terrarium.Namespace","text":"struct Namespace{name, Vars}\n\nRepresents a new variable namespace, typically from a subcomponent of the model.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.NoFlow","page":"API Reference","title":"Terrarium.NoFlow","text":"Represents a hydrology scheme where soil water is immobile.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNAutotrophicRespiration","page":"API Reference","title":"Terrarium.PALADYNAutotrophicRespiration","text":"struct PALADYNAutotrophicRespiration{NF} <: Terrarium.AbstractAutotrophicRespiration{NF}\n\nAutotrophic respiration implementation from PALADYN (Willeit 2016).\n\nAuthors: Maha Badri and Matteo Willeit\n\nProperties:\n\ncn_sapwood::Any: Sapwood parameter\ncn_root::Any: Root parameter\naws::Any: Ratio of total to respiring stem carbon, Cox 2001, PFT specific [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNCanopyEvapotranspiration","page":"API Reference","title":"Terrarium.PALADYNCanopyEvapotranspiration","text":"struct PALADYNCanopyEvapotranspiration{NF, GR<:Terrarium.AbstractGroundEvaporationResistanceFactor} <: Terrarium.AbstractEvapotranspiration{NF}\n\nCanopy evapotranspiration scheme from PALADYN (Willeit 2016) that includes a canopy evaporation term based on the saturation fraction of canopy water defined by the canopy hydrology scheme.\n\nE_g = beta fracDelta qr_a \nE_c = f_textcan fracDelta qr_a \nT_c = fracDelta qr_a + r_s \n\nProperties:\n\nC_can: Drag coefficient for the traansfer of heat and water between the ground and canopy\nground_resistance: Parameterization for ground resistance to evaporation/sublimation\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNCanopyInterception","page":"API Reference","title":"Terrarium.PALADYNCanopyInterception","text":"struct PALADYNCanopyInterception{NF} <: Terrarium.AbstractCanopyInterception{NF}\n\nCanopy interception and storage implementation following PALADYN (Willeit 2016) considering only liquid water (no snow).\n\nProperties:\n\nŒ±_int: Canopy water interception factor for tree PFTs\nk_ext: Extinction coefficient for radiation through vegetation [-]\nw_can_max: Canopy interception capacity parameter, Verseghy 1991 [kg/m¬≤]\nœÑ_w: Canopy water removal timescale [s]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNCarbonDynamics","page":"API Reference","title":"Terrarium.PALADYNCarbonDynamics","text":"struct PALADYNCarbonDynamics{NF} <: Terrarium.AbstractVegetationCarbonDynamics{NF}\n\nVegetation carbon dynamics implementation following PALADYN (Willeit 2016) but considering only the sum of the vegetation carbon pools. The subsequent splitting into Cleaf, Cstem, C_root is not implemented for now.\n\nAuthors: Maha Badri\n\nProperties:\n\nSLA::Any: Specific leaf area (Kattge et al. 2011) [m¬≤/kgC], PFT specific\nawl::Any: Allometric coefficient, modified from Cox 2001 to account for bwl=1 [kgC/m¬≤], PFT specific\nLAI_min::Any: Minimum Leaf Area Index modified from Clark et al. 2011 [m¬≤/m¬≤], PFT specific\nLAI_max::Any: Maximum Leaf Area Index modified from Clark et al. 2011 [m¬≤/m¬≤], PFT specific\nŒ≥L::Any: Leaf turnover rate (Kattge et al. 2011) [1/year], PFT specific\nŒ≥R::Any: Root turnover rate [1/year], PFT specific\nŒ≥S::Any: Stem turnover rate modified from Clark et al. 2011 [1/year], PFT specific\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNPhenology","page":"API Reference","title":"Terrarium.PALADYNPhenology","text":"struct PALADYNPhenology{NF} <: Terrarium.AbstractPhenology{NF}\n\nVegetation phenology implementation from PALADYN (Willeit 2016).\n\nAuthors: Maha Badri and Matteo Willeit\n\nProperties:\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PALADYNVegetationDynamics","page":"API Reference","title":"Terrarium.PALADYNVegetationDynamics","text":"struct PALADYNVegetationDynamics{NF} <: Terrarium.AbstractVegetationDynamics{NF}\n\nVegetation dynamics implementation following PALADYN (Willeit 2016) for a single PFT based on the Lotka‚ÄìVolterra approach.\n\nAuthors: Maha Badri \n\nProperties:\n\nŒΩ_seed::Any: Vegetation seed fraction [-]\nŒ≥v_min::Any: Minimum vegetation disturbance rate [1/year]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PhysicalConstants","page":"API Reference","title":"Terrarium.PhysicalConstants","text":"struct PhysicalConstants{NF}\n\nA collection of general physical constants that do not (usually) need to be varied in parameter calibration.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PiecewiseLinearInitialSoilTemperature","page":"API Reference","title":"Terrarium.PiecewiseLinearInitialSoilTemperature","text":"struct PiecewiseLinearInitialSoilTemperature{NF, N}\n\nRepresents a piecewise linear temperature initializer specified from the given knots.\n\ninitializer = PiecewiseLinearInitialSoilTemperature(\n    0.0u\"m\" => 5.0, # always in ¬∞C!\n    0.5u\"m\" => 2.0,\n    1.0u\"m\" => 1.0,\n    10.0u\"m\" => 1.5,\n    ...\n)\n\nProperties:\n\nknots::NTuple{N, NF} where {NF, N}\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedAlbedo","page":"API Reference","title":"Terrarium.PrescribedAlbedo","text":"struct PrescribedAlbedo{NF} <: Terrarium.AbstractAlbedo{NF}\n\nProperties:\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedAtmosphere","page":"API Reference","title":"Terrarium.PrescribedAtmosphere","text":"struct PrescribedAtmosphere{NF, tracernames, Precip<:Terrarium.AbstractPrecipitation, IncomingRad<:Terrarium.AbstractIncomingRadiation, Humidity<:Terrarium.AbstractHumidity, Aerodynamics<:Terrarium.AbstractAerodynamics, Tracers<:(NamedTuple{tracernames, <:Tuple{Vararg{TracerGas}}})} <: Terrarium.AbstractAtmosphere{NF, Precip<:Terrarium.AbstractPrecipitation, IncomingRad<:Terrarium.AbstractIncomingRadiation, Humidity<:Terrarium.AbstractHumidity, Aerodynamics<:Terrarium.AbstractAerodynamics}\n\nRepresents prescribed atmospheric conditions given by the following input variables:     - Air temperature     - Humidity     - Atmospheric pressure     - Windspeed     - Precipitation     - Solar radiation     - Zero or more tracer gases (defaults to CO2 only)\n\nPrecpitation and solar radiation are specified according to specialized subtypes which dictate the form of the input data; for precipitation, this defaults to RainSnow, i.e. rain- and snowfall given as separate inputs, while for solar radiation, the default is LongShortWaveRadiation which partitions downwelling radiation into the common short- and long wave lengths representing solar and thermal (infrared) radiation.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedRadiativeFluxes","page":"API Reference","title":"Terrarium.PrescribedRadiativeFluxes","text":"struct PrescribedRadiativeFluxes{NF} <: Terrarium.AbstractRadiativeFluxes{NF}\n\nRepresents the simplest scheme for the radiative budget where outgoing shortwave and longwave radiation are given as input variables. Net radiation is diagnosed by summing all radiative fluxes:\n\nR_textnet = S_uparrow - S_downarrow + L_uparrow - L_downarrow\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedSkinTemperature","page":"API Reference","title":"Terrarium.PrescribedSkinTemperature","text":"struct PrescribedSkinTemperature{NF} <: Terrarium.AbstractSkinTemperature{NF}\n\nSimple scheme for prescribed skin temperatures from input variables.\n\nProperties:\n\nŒ∫‚Çõ: Assumed thermal conductivity at the surface [W m‚Åª¬π K‚Åª¬π]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedSpacing","page":"API Reference","title":"Terrarium.PrescribedSpacing","text":"struct PrescribedSpacing{NF} <: Terrarium.AbstractVerticalSpacing{NF}\n\nVertical discretization with prescribed thicknesses for each layer. The number of layers is equal to the length of the given vector.\n\nProperties:\n\nŒîz::Vector\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrescribedTurbulentFluxes","page":"API Reference","title":"Terrarium.PrescribedTurbulentFluxes","text":"struct PrescribedTurbulentFluxes{NF} <: Terrarium.AbstractTurbulentFluxes{NF}\n\nRepresents the simplest case where the turbulent (sensible and latent) heat fluxes are prescribed via input variables.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.PrognosticVariable","page":"API Reference","title":"Terrarium.PrognosticVariable","text":"struct PrognosticVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units, Var<:Terrarium.Variable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}, CL<:Union{Nothing, Terrarium.AbstractClosureRelation}, TV<:Union{Nothing, AuxiliaryVariable}, DT<:IntervalSets.AbstractInterval} <: Terrarium.AbstractProcessVariable{name, VD<:Terrarium.VarDims, UT<:Unitful.Units}\n\nRepresents a prognostic state variable with the given name and spatial dims.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.QuasiThermalSteadyState","page":"API Reference","title":"Terrarium.QuasiThermalSteadyState","text":"struct QuasiThermalSteadyState{NF} <: Terrarium.AbstractInitializer{NF}\n\nInitializer that sets soil/ground temperature to a thermal quasi-steady state based on the given surface temperature, geothermal heat flux, and bulk (constant) thermal conductivity. Note that this is not a true thermal steady state, which would require iterative calculation of the thermal conductivity from the soil properties and initial temperature profile.\n\nProperties:\n\nT‚ÇÄ::Any\nQgeo::Any\nk_eff::Any\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.RichardsEq","page":"API Reference","title":"Terrarium.RichardsEq","text":"RichardsEq{PS} <: AbstractVerticalFlow\n\nSoilHydrology flow operator implementing the mixed saturation-pressure form of the Richardson-Richards equation:\n\nphi(z) fracpartial s_mathrmwi(Psi(zt))partial t = n+nabla cdot bigl(K(s_mathrmwi T)  n+nabla (psi_m + 1)bigr)\n\nwhich describes the vertical movement of water according to gravity-driven percolation and capillary-driven diffusion.\n\nState variables defined by the Richards' formulation of SoilHydrology:\n\nsaturation_water_ice: saturation level of water and ice in the pore space.\nsurface_excess_water: excess water at the soil surface (m^3/m^2).\nhydraulic_conductivity: hydraulic conductivity at cell centers (m/s).\nwater_table`: elevation of the water table (m).\nliquid_water_fraction: fraction of unfrozen liquid water in the pore space (dimensionless).\n\nSee also SoilSaturationPressureClosure and AbstractSoilHydraulics for details regarding the closure relating saturtion and pressure head.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SaturationWaterTable","page":"API Reference","title":"Terrarium.SaturationWaterTable","text":"struct SaturationWaterTable{NF} <: Terrarium.AbstractInitializer{NF}\n\nSimple initialization scheme for soil/ground saturation that sets the initial water table at the given depth and the saturation level in all layers in the vadose (unsaturated) to a constant value.\n\nProperties:\n\nvadose_zone_saturation::Any\nwater_table_depth::Any\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilEnergyBalance","page":"API Reference","title":"Terrarium.SoilEnergyBalance","text":"struct SoilEnergyBalance{NF, HeatOperator<:Terrarium.AbstractHeatOperator, EnergyClosure<:Terrarium.AbstractSoilEnergyClosure, ThermalProps<:(SoilThermalProperties{NF})} <: Terrarium.AbstractSoilEnergyBalance{NF}\n\nStandard implementation of the soil energy balance accounting for freezing and thawing of pore water/ice. The closure field represents the temperature-energy closure U(Tphi) which relates temperature to internal energy via an arbitrary set of additional parameters phi which are determined by the model configuration.\n\nProperties:\n\noperator::Terrarium.AbstractHeatOperator: Heat transport operator\nclosure::Terrarium.AbstractSoilEnergyClosure: Closure relating energy and temperature\nthermal_properties::SoilThermalProperties: Soil thermal properties\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilEnergyTemperatureClosure","page":"API Reference","title":"Terrarium.SoilEnergyTemperatureClosure","text":"struct SoilEnergyTemperatureClosure <: Terrarium.AbstractSoilEnergyClosure\n\nDefines the constitutive relationship between the the internal energy and temperature of a soil volume, i.e.\n\nU(T) = Ttimes C(T) - L_f theta_wi (1 - F(T))\n\nwhere T is temperature, C(T) is the temperature-dependent heat capacity, L_f is the volumetric latent heat of fusion, and F(T) is the constitutive relation between temperature and the unfrozen fraction of pore water. Note that, under this formulation, zero energy corresponds to 0¬∞C with no ice, i.e. all pore water fully thawed.\n\nThe closure relation is defined as being a mapping from the conserved quantity (energy) to the continuous quantity (temperature), i.e. the inverse of U(T).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilEnergyWaterCarbon","page":"API Reference","title":"Terrarium.SoilEnergyWaterCarbon","text":"struct SoilEnergyWaterCarbon{NF, Stratigraphy<:Terrarium.AbstractStratigraphy{NF}, Energy<:Terrarium.AbstractSoilEnergyBalance{NF}, Hydrology<:Terrarium.AbstractSoilHydrology{NF}, Biogeochemistry<:Terrarium.AbstractSoilBiogeochemistry{NF}} <: Terrarium.AbstractSoil{NF}\n\nCoupled process type that encapsulates the coupling of soil energy, water, and carbon dynamics. The stratigraphy parameterization determines how the vertical layering of the soil is parameterized.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilHeatCapacities","page":"API Reference","title":"Terrarium.SoilHeatCapacities","text":"struct SoilHeatCapacities{NF}\n\nProperties:\n\nwater::Any\nice::Any\nair::Any\nmineral::Any\norganic::Any\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilHydraulicsSURFEX","page":"API Reference","title":"Terrarium.SoilHydraulicsSURFEX","text":"struct SoilHydraulicsSURFEX{NF, RC, UnsatK<:Terrarium.AbstractUnsatK{NF}} <: Terrarium.AbstractSoilHydraulics{NF, RC, UnsatK<:Terrarium.AbstractUnsatK{NF}}\n\nSoil hydraulics parameterization that includes the SURFEX (Masson et al. 2013) formulation of field capacity and wilting point as a function of soil texture.\n\nProperties:\n\nswrc::Any: Soil water retention curve\nunsat_hydraulic_cond::Terrarium.AbstractUnsatK: Unsaturated hydraulic conductivity formulation; defaults to sat_hydraulic_cond\nsat_hydraulic_cond::Any: Hydraulic conductivity at saturation [m/s]\nwilting_point_coef::Any: Linear coeficient of wilting point adjustment due to clay content [-]\nfield_capacity_coef::Any: Linear coeficient of field capacity adjustment due to clay content [-]\nfield_capacity_exp::Any: Exponent of field capacity adjustment due to clay content [-]\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilHydrology","page":"API Reference","title":"Terrarium.SoilHydrology","text":"struct SoilHydrology{NF, VerticalFlow<:Terrarium.AbstractVerticalFlow, SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF}), VWCForcing<:Union{Nothing, Oceananigans.Forcings.ContinuousForcing{LX, LY, LZ, P} where {P, LX, LY, LZ}, Oceananigans.Forcings.DiscreteForcing}} <: Terrarium.AbstractSoilHydrology{NF}\n\nProperties:\n\nvertflow::Terrarium.AbstractVerticalFlow: Soil water vertical flow operator\nclosure::Terrarium.AbstractSoilWaterClosure: Closure relation for mapping between saturation water potential (hydraulic head)\nhydraulic_properties::Terrarium.AbstractSoilHydraulics: Soil hydraulic properties parameterization\nvwc_forcing::Union{Nothing, Oceananigans.Forcings.ContinuousForcing{LX, LY, LZ, P} where {P, LX, LY, LZ}, Oceananigans.Forcings.DiscreteForcing}: Forcing for soil moisture (volumetric water content)\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilInitializer","page":"API Reference","title":"Terrarium.SoilInitializer","text":"struct SoilInitializer{NF, EnergyInit<:Terrarium.AbstractInitializer{NF}, HydrologyInit<:Terrarium.AbstractInitializer{NF}, BGCInit<:Terrarium.AbstractInitializer{NF}} <: Terrarium.AbstractInitializer{NF}\n\nInitializer for coupled soil energy/hydrology/biogeochemistry models.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilModel","page":"API Reference","title":"Terrarium.SoilModel","text":"struct SoilModel{NF, GridType<:(Terrarium.AbstractLandGrid{NF}), Soil<:Terrarium.AbstractSoil{NF}, Constants<:PhysicalConstants{NF}, Initializer<:Terrarium.AbstractInitializer} <: Terrarium.AbstractSoilModel{NF, GridType<:(Terrarium.AbstractLandGrid{NF})}\n\nGeneral implementation of a 1D column model of soil energy, water, and carbon transport.\n\nProperties:\n\ngrid::Terrarium.AbstractLandGrid: Spatial grid type\nsoil::Terrarium.AbstractSoil: Soil processes\nconstants::PhysicalConstants: Physical constants\ninitializer::Terrarium.AbstractInitializer: State variable initializer\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilMoistureResistanceFactor","page":"API Reference","title":"Terrarium.SoilMoistureResistanceFactor","text":"SoilMoistureResistanceFactor <: AbstractGroundEvaporationResistanceFactor\n\nImplements the soil moisture limiting resistance factor of Lee and Pielke (1992),\n\nbeta = begincases\nfrac14 left(1 - cosleft(œÄ fractheta_1theta_textfc right)right)  theta_1  theta_textfc \n1  textotherwise\nendcases\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilPorositySURFEX","page":"API Reference","title":"Terrarium.SoilPorositySURFEX","text":"struct SoilPorositySURFEX{NF} <: Terrarium.AbstractSoilPorosity{NF}\n\nSURFEX parameterization of mineral soil porosity (Masson et al. 2013).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilSaturationPressureClosure","page":"API Reference","title":"Terrarium.SoilSaturationPressureClosure","text":"struct SoilSaturationPressureClosure <: Terrarium.AbstractSoilWaterClosure\n\nRepresents a closure relating saturation of water/ice in soil pores to a corresponding pressure (or hydraulic) head. Note that here \"pressure head\" is defined to be synonymous with hydraulic head, i.e. including all both elevation and hydrostatic pressure contributions. This relation is typically described by soil property-dependent soil-water retention curve (SWRC) which is here defined in implementations of AbstractSoilHydraulics.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilTexture","page":"API Reference","title":"Terrarium.SoilTexture","text":"struct SoilTexture{NF} <: Terrarium.AbstractSoilTexture{NF}\n\nRepresents soil texture as a fractional mixture of sand, silt, and clay. Accepts values \n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilThermalConductivities","page":"API Reference","title":"Terrarium.SoilThermalConductivities","text":"struct SoilThermalConductivities{NF}\n\nProperties:\n\nwater::Any\nice::Any\nair::Any\nmineral::Any\norganic::Any\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilThermalProperties","page":"API Reference","title":"Terrarium.SoilThermalProperties","text":"struct SoilThermalProperties{NF, FC, CondBulk}\n\nProperties:\n\nconductivities::SoilThermalConductivities: Thermal conductivities for all constituents\nbulk_conductivity::Any: Method for computing bulk thermal conductivity from constituents\nheat_capacities::SoilHeatCapacities: Thermal conductivities for all constituents\nfreezecurve::Any: Freezing characteristic curve needed for energy-temperature closure\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SoilVolume","page":"API Reference","title":"Terrarium.SoilVolume","text":"struct SoilVolume{NF, Solid<:Terrarium.AbstractSoilMatrix{NF}}\n\nRepresents the material composition of an elementary volume of soil. The volume is decomposed into the key constitutents of water, ice, air, and a mixture of organic and mineral solid material.\n\nProperties:\n\nporosity: Natural porosity or void space of the soil\nsaturation: Fraction of the soil pores occupied by water or ice\nliquid: Liquid (unfrozen) fraction of pore water\nsolid: Parameterization of the solid phase (matrix) of the soil\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.StateVariables","page":"API Reference","title":"Terrarium.StateVariables","text":"struct StateVariables{NF, prognames, closurenames, auxnames, inputnames, nsnames, ProgFields, TendFields, AuxFields, InputFields, Namespaces, ClockType} <: Terrarium.AbstractStateVariables\n\nContainer type for all Fields corresponding to state variables defined by a model. StateVariables partitions the fields into three categories: prognostic, tendencies, and auxiliary. Prognostic variables are those which characterize the state of the system and are assigned tendencies to be integrated by the timestepper. Auxiliary fields are additional state variables derived from the prognostic state variables but which are conditionally independent of their values at the previous time step given the current prognostic state. It is worth noting that tendencies are also treated internally as auxiliary variables; however, they are assigned their own category here since they need to be handled separately by the timestepping scheme.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.StaticExponentialRootDistribution","page":"API Reference","title":"Terrarium.StaticExponentialRootDistribution","text":"struct StaticExponentialRootDistribution{NF} <: Terrarium.AbstractRootDistribution{NF}\n\nStatic vegetation root distribution implementation in PALADYN (Willeit 2016) based on the scheme proposed by Zeng (2001). The PDF of the root distribution is modeled as\n\nfracpartial Rpartial z = frac12 left( a exp(a z) + b exp(b z) right)\n\nwhich is then integrated over the soil column and normalized to sum to unity. Note that this is effectively the average of two exponential distributions with rates a and b, both with units m‚Åª¬π. The resulting CDF of this distribution determines the root distribution.\n\nProperties:\n\na: First empirical rate parameter for root distribution\nb: Second empirical rate parameter for root distribution\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SurfaceEnergyBalance","page":"API Reference","title":"Terrarium.SurfaceEnergyBalance","text":"struct SurfaceEnergyBalance{NF, SkinTemperature<:Terrarium.AbstractSkinTemperature{NF}, TurbulentFluxes<:Terrarium.AbstractTurbulentFluxes{NF}, RadiativeFluxes<:Terrarium.AbstractRadiativeFluxes{NF}, Albedo<:Terrarium.AbstractAlbedo{NF}} <: Terrarium.AbstractSurfaceEnergyBalance{NF}\n\nStandard implementation of the surface energy balance (SEB) that computes the radiative, turbulent, and ground energy fluxes at the surface. The SEB is also responsible for defining and solving the so-called skin temperature (effective emission temperature of the land surface) as well as the albedo.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SurfaceEnergyModel","page":"API Reference","title":"Terrarium.SurfaceEnergyModel","text":"struct SurfaceEnergyModel{NF, GridType<:(Terrarium.AbstractLandGrid{NF}), SEB<:Terrarium.AbstractSurfaceEnergyBalance, Atmosphere<:Terrarium.AbstractAtmosphere, Initializer<:Terrarium.AbstractInitializer} <: Terrarium.AbstractSurfaceEnergyModel{NF, GridType<:(Terrarium.AbstractLandGrid{NF})}\n\nSimple model wrapper for the SurfaceEnergyBalance that couples it with an AbstractAtmosphere to provide meteorological inputs. This model type is mostly intended for testing but could also be used for simple energy balance calculations from prescribed meteorological and ground temperature conditions.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.SurfaceHydrology","page":"API Reference","title":"Terrarium.SurfaceHydrology","text":"struct SurfaceHydrology{NF, CanopyInterception<:Terrarium.AbstractCanopyInterception{NF}, Evapotranspiration<:Terrarium.AbstractEvapotranspiration{NF}, SurfaceRunoff<:Terrarium.AbstractSurfaceRunoff{NF}} <: Terrarium.AbstractSurfaceHydrology{NF}\n\nProperties:\n\ncanopy_interception: Canopy hydrology scheme\nevapotranspiration: Canopy evapotranspiration scheme\nsurface_runoff: Surface runoff scheme\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.TracerGas","page":"API Reference","title":"Terrarium.TracerGas","text":"Generic type representing the concentration of a particular tracer gas in the atmosphere.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.UniformSpacing","page":"API Reference","title":"Terrarium.UniformSpacing","text":"struct UniformSpacing{NF} <: Terrarium.AbstractVerticalSpacing{NF}\n\nUniform vertical discretization with N layers of size Œîz.\n\nProperties:\n\nŒîz::Any\nN::Int64\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.UnsatKLinear","page":"API Reference","title":"Terrarium.UnsatKLinear","text":"struct UnsatKLinear{NF} <: Terrarium.AbstractUnsatK{NF}\n\nSimple formulation of hydraulic conductivity as a linear function of the liquid water saturated fraction, i.e. soil.water / (soil.water + soil.ice + soil.air).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.UnsatKVanGenuchten","page":"API Reference","title":"Terrarium.UnsatKVanGenuchten","text":"struct UnsatKVanGenuchten{NF} <: Terrarium.AbstractUnsatK{NF}\n\nFormulation of hydraulic conductivity as a function of saturated hydraulic conductivity K_sat and volumetric fractions, assumed to include those of water, ice, and air.\n\nSee van Genuchten (1980) and Westermann et al. (2023).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.ValType","page":"API Reference","title":"Terrarium.ValType","text":"Alias for Type{Val{x}}\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Variable","page":"API Reference","title":"Terrarium.Variable","text":"struct Variable{name, VD, UT} <: Terrarium.AbstractVariable{name, VD, UT}\n\nRepresents metadata for a generic state variable with the given name and spatial dims.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Variables","page":"API Reference","title":"Terrarium.Variables","text":"struct Variables{ProgVars, TendVars, AuxVars, InputVars, Namespaces}\n\nContainer for abstract state variable definitions. Automatically collates and merges all variables and namespaces passed into the constructor.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.VegetationCarbon","page":"API Reference","title":"Terrarium.VegetationCarbon","text":"struct VegetationCarbon{NF, Photosynthesis<:Terrarium.AbstractPhotosynthesis{NF}, StomatalConducatance<:Terrarium.AbstractStomatalConductance{NF}, AutotrophicRespiration<:Terrarium.AbstractAutotrophicRespiration{NF}, Phenology<:Terrarium.AbstractPhenology{NF}, CarbonDynamics<:Terrarium.AbstractVegetationCarbonDynamics{NF}, VegetationDynamics<:Union{Nothing, Terrarium.AbstractVegetationDynamics}, RootDistribution<:Union{Nothing, Terrarium.AbstractRootDistribution}} <: Terrarium.AbstractVegetation{NF}\n\nRepresents a generic coupling of vegetation carbon processes.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.VegetationModel","page":"API Reference","title":"Terrarium.VegetationModel","text":"struct VegetationModel{NF, Vegetation<:Terrarium.AbstractVegetation{NF}, Atmosphere<:(Terrarium.AbstractAtmosphere{NF, PR, IR, HM, AD} where {PR<:Terrarium.AbstractPrecipitation, IR<:Terrarium.AbstractIncomingRadiation, HM<:Terrarium.AbstractHumidity, AD<:Terrarium.AbstractAerodynamics{NF}}), GridType<:(Terrarium.AbstractLandGrid{NF}), Constants<:PhysicalConstants{NF}, Initializer<:Terrarium.AbstractInitializer} <: Terrarium.AbstractVegetationModel{NF, GridType<:(Terrarium.AbstractLandGrid{NF})}\n\nModel for natural (unmanaged) vegetation processes for a single plant functional type (PFT). Multiple PFTs can be later handled with a TiledVegetationModel type that composes multiple VegetationModels with different parameters for each PFT.\n\nProperties:\n\ngrid::Terrarium.AbstractLandGrid: Spatial grid type\natmosphere::Terrarium.AbstractAtmosphere: Atmospheric input configuration\nvegetation::Terrarium.AbstractVegetation: Vegetation processes\nconstants::PhysicalConstants: Physical constants\ninitializer::Terrarium.AbstractInitializer: State variable initializer\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.XY","page":"API Reference","title":"Terrarium.XY","text":"XY <: VarDims\n\nIndicator type for variables that should be assigned a 2D (lateral only) field on their associated grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.XYZ","page":"API Reference","title":"Terrarium.XYZ","text":"XYZ <: VarDims\n\nIndicator type for variables that should be assigned a 3D field on their associated grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Adapt.adapt-Union{Tuple{NF}, Tuple{Terrarium.NumberFormatAdaptor{NF}, Any}} where NF<:Number","page":"API Reference","title":"Adapt.adapt","text":"Adapt.adapt(::NumberFormatAdaptor{NF}, obj) where {NF<:Number}\n\nAdaptor that reconstructs arbitrary data structures with all numeric values converted to the specified number format NF.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.merge-Tuple{Vararg{Terrarium.Variables}}","page":"API Reference","title":"Base.merge","text":"Merges all of the given Variables containers into a single container.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.BoundaryConditions.compute_z_bcs!-Tuple{Any, Any, Terrarium.AbstractLandGrid, Any}","page":"API Reference","title":"Oceananigans.BoundaryConditions.compute_z_bcs!","text":"Convenience alias for Oceananigans.BoundaryConditions.compute_z_bcs! that adds flux BCs for progvar to its corresponding tendency.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.BoundaryConditions.fill_halo_regions!-Tuple{StateVariables}","page":"API Reference","title":"Oceananigans.BoundaryConditions.fill_halo_regions!","text":"Invoke fill_halo_regions! for all prognostic Fields in state.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.BoundaryConditions.getbc-Union{Tuple{name}, Tuple{Terrarium.Variable{name}, Integer, Integer, Oceananigans.Grids.AbstractGrid, Any, StateVariables}} where name","page":"API Reference","title":"Oceananigans.BoundaryConditions.getbc","text":"Implementation of Oceananigans.BoundaryConditions.getbc for variable placeholders that retrieves the input Field from state and returns the value at the given index.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.Simulations.run!-Tuple{ModelIntegrator}","page":"API Reference","title":"Oceananigans.Simulations.run!","text":"run!(integrator; steps, period, Œît)\n\n\nRun the simulation for steps or a given time period with timestep size Œît (in seconds or Dates.Period).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.TimeSteppers.reset!-Tuple{StateVariables}","page":"API Reference","title":"Oceananigans.TimeSteppers.reset!","text":"Reset all Fields in state to zero.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Oceananigans.TimeSteppers.update_state!-Tuple{StateVariables, Terrarium.AbstractModel, InputSources}","page":"API Reference","title":"Oceananigans.TimeSteppers.update_state!","text":"update_state!(state::StateVariables, model::AbstractModel, inputs::InputSources; compute_tendencies = true)\n\nUpdate the state for the given model and inputs; this includes calling update_inputs! and fill_halo_regions! followed by compute_auxiliary! and compute_tendencies!, if compute_tendencies = true.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.AmbientCO2","page":"API Reference","title":"Terrarium.AmbientCO2","text":"Creates a TracerGas for ambient CO2 with concentration prescribed by an input variable with the given name.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.FreeDrainage-Tuple{}","page":"API Reference","title":"Terrarium.FreeDrainage","text":"Alias for PrescribedGradient representing a Neumann-type zero pressure gradient at the bottom of the soil column, thereby allowing free drainage of water.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.GeothermalHeatFlux","page":"API Reference","title":"Terrarium.GeothermalHeatFlux","text":"Alias for FluxBoundaryCondition on internal_energy with name geothermal_heat_flux representing the geothermal heat flux at the bottom boundary of the soil column.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.GroundHeatFlux","page":"API Reference","title":"Terrarium.GroundHeatFlux","text":"Alias for FluxBoundaryCondition on internal_energy with name ground_heat_flux representing the net ground heat flux at the soil surface.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.ImpermeableBoundary-Tuple{}","page":"API Reference","title":"Terrarium.ImpermeableBoundary","text":"Alias for NoFlux representing a zero-flux bottom boundary condition for water flow (prognostic variable saturation_water_ice).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.InfiltrationFlux","page":"API Reference","title":"Terrarium.InfiltrationFlux","text":"Alias for PrescribedFlux with name infiltration representing liquid water infiltration at the soil surface.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.PrescribedBottomTemperature","page":"API Reference","title":"Terrarium.PrescribedBottomTemperature","text":"Alias for ValueBoundaryCondition on top temperature (in ¬∞C) with the given variable name.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.PrescribedSurfaceTemperature","page":"API Reference","title":"Terrarium.PrescribedSurfaceTemperature","text":"Alias for ValueBoundaryCondition on top temperature (in ¬∞C) with the given variable name.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.TracerGases-Tuple{Vararg{TracerGas}}","page":"API Reference","title":"Terrarium.TracerGases","text":"Creates a NamedTuple from the given tracer gas types.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.adjust_saturation_profile!-Union{Tuple{NF}, Tuple{Any, Any, Any, Any, SoilHydrology{NF, VerticalFlow, SaturationClosure, SoilHydraulics} where {VerticalFlow<:Terrarium.AbstractVerticalFlow, SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}}} where NF","page":"API Reference","title":"Terrarium.adjust_saturation_profile!","text":"adjust_saturation_profile!(\n    out,\n    i,\n    j,\n    grid,\n    _::SoilHydrology{NF, VerticalFlow, SaturationClosure, SoilHydraulics} where {VerticalFlow<:Terrarium.AbstractVerticalFlow, SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}\n) -> Any\n\n\nKernel function that adjusts saturation profiles to account for oversaturation and undersaturation arising due to numerical error. This implementation scans over the saturation profiles at each lateral grid cell and redistributes excess water upward layer-by-layer until reaching the topmost layer, where any remaining excess water is added to the surface_excess_water pool.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.aerodynamic_resistance-Tuple{Any, Any, Any, Any, PrescribedAtmosphere}","page":"API Reference","title":"Terrarium.aerodynamic_resistance","text":"aerodynamic_resistance(i, j, grid, fields, atmos::PrescribedAtmosphere)\n\nCompute the aerodynamic resistance (inverse conductance) at grid cell i, j.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.aerodynamic_resistance-Tuple{Any, Any, Any, Any, Terrarium.AbstractAtmosphere, PALADYNCanopyEvapotranspiration}","page":"API Reference","title":"Terrarium.aerodynamic_resistance","text":"aerodynamic_resistance(\n    i,\n    j,\n    grid,\n    fields,\n    atmos::Terrarium.AbstractAtmosphere,\n    evtr::PALADYNCanopyEvapotranspiration\n) -> Any\n\n\nCompute the aerodynamic resistance between the ground and canopy as a function of LAI and SAI.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.air_pressure-Tuple{Any, Any, Any, Any, PrescribedAtmosphere}","page":"API Reference","title":"Terrarium.air_pressure","text":"air_pressure(i, j, grid, fields, ::PrescribedAtmosphere)\n\nRetrieve or compute the air pressure at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.air_temperature-Tuple{Any, Any, Any, Any, PrescribedAtmosphere}","page":"API Reference","title":"Terrarium.air_temperature","text":"air_temperature(i, j, grid, fields, ::PrescribedAtmosphere)\n\nRetrieve or compute the air temperature at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.albedo-Tuple{Any, Any, Any, Any, Terrarium.AbstractAlbedo}","page":"API Reference","title":"Terrarium.albedo","text":"albedo(i, j, grid, fields, ::AbstractAlbedo)\n\nReturn the current albedo at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.auxiliary","page":"API Reference","title":"Terrarium.auxiliary","text":"auxiliary(name, dims; ...)\nauxiliary(name, dims, ctor; ...)\nauxiliary(name, dims, ctor, params; units, domain, desc)\n\n\nConvenience constructor method for AuxiliaryVariable.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.auxiliary_fields-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Terrarium.auxiliary_fields","text":"auxiliary_fields(state, components)\n\n\nRetrieves all Fields from state corresponding to auxiliary variables defined on the given components.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.auxiliary_variables-Tuple{Any}","page":"API Reference","title":"Terrarium.auxiliary_variables","text":"Helper method that selects only auxiliary variables declared on obj.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.canopy_water","page":"API Reference","title":"Terrarium.canopy_water","text":"canopy_water(i, j, grid, fields, ::AbstractCanopyInterception)\n\nCompute or retrieve the current canopy water storage [kg/m^2].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.celsius_to_kelvin-Tuple{PhysicalConstants, Any}","page":"API Reference","title":"Terrarium.celsius_to_kelvin","text":"celsius_to_kelvin(c::PhysicalConstants, T)\n\nConvert the given temperature in ¬∞C to Kelvin based on the constant Tref.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.check_duplicates-Tuple{Vararg{Union{Terrarium.AbstractVariable, Terrarium.Namespace}}}","page":"API Reference","title":"Terrarium.check_duplicates","text":"Check for variables/namespaces with duplicate names and raise an error if duplicates are detected.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.closure!-Tuple{Any, Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.closure!","text":"closure!(state, model::AbstractModel)\n\nApply all closure relations defined for the given model.\n\nclosure!(state, grid, [closure,] process, args...)\n\nApply the closure for process with the given grid and additional implementation-specific args. If closure is not specified, it is automatically inferred from first(closures(process)).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.closure!-Union{Tuple{NF}, Tuple{Any, Any, SoilSaturationPressureClosure, SoilHydrology{NF, RichardsEq, SaturationClosure, SoilHydraulics} where {SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}, Terrarium.AbstractSoil, Vararg{Any}}} where NF","page":"API Reference","title":"Terrarium.closure!","text":"closure!(\n    state,\n    grid,\n    closure::SoilSaturationPressureClosure,\n    hydrology::SoilHydrology{NF, RichardsEq, SaturationClosure, SoilHydraulics} where {SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})},\n    soil::Terrarium.AbstractSoil,\n    args...\n)\n\n\nComputes pressure_head Œ® = œàm + œàz + œàh from the current saturation_water_ice state.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.closure_fields-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Terrarium.closure_fields","text":"closure_fields(state, components)\n\n\nRetrieves all Fields from state corresponding to closure variables defined on the given components.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.closure_variables-Tuple{Any}","page":"API Reference","title":"Terrarium.closure_variables","text":"Helper method that selects only closure (auxiliary) variables declared on obj.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.closures-Tuple{Terrarium.AbstractProcess}","page":"API Reference","title":"Terrarium.closures","text":"closures(process::AbstractProcess)\n\nReturn a tuple of AbstractClosureRelations defined by the given processes type. Note that this is a type-stable, @generated function that is compiled for each argument type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_APAR-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_APAR","text":"compute_APAR(photo, swdown, LAI)\n\n\nComputes absorbed PAR limited by the fraction of PAR assimilated at ecosystem level APAR [mol/m¬≤/s], Eq. 62, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Ag-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 5}}} where NF","page":"API Reference","title":"Terrarium.compute_Ag","text":"compute_Ag(photo, c_1, c_2, APAR, Vc_max, Œ≤)\n\n\nComputes the gross photosynthesis rate Ag [gC/m¬≤/s], Eqn 2, Haxeltine & Prentice 1996\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_C_veg_tend-Union{Tuple{NF}, Tuple{PALADYNCarbonDynamics{NF}, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_C_veg_tend","text":"compute_C_veg_tend(vegcarbon_dynamics, LAI_b, NPP)\n\n\nComputes the C_veg tendency based on NPP and the balanced Leaf Area Index LAI_b, Eq. 72, PALADYN (Willeit 2016) \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_GPP-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, NF}} where NF","page":"API Reference","title":"Terrarium.compute_GPP","text":"compute_GPP(_, An)\n\n\nCompute the Gross Primary Production [kgC/m¬≤/s].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_JE_JC-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 4}}} where NF","page":"API Reference","title":"Terrarium.compute_JE_JC","text":"compute_JE_JC(photo, c_1, c_2, APAR, Vc_max)\n\n\nComputes the PAR-limited and the rubisco-activity-limited photosynthesis rates JE and JC [gC/m¬≤/s], Eqn 3+5, Haxeltine & Prentice 1996.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_LAI-Union{Tuple{NF}, Tuple{PALADYNPhenology{NF}, NF}} where NF","page":"API Reference","title":"Terrarium.compute_LAI","text":"compute_LAI(phenol, LAI_b)\n\n\nComputes LAI, based on the balanced Leaf Area Index LAI_b:\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_NPP-Tuple{PALADYNAutotrophicRespiration, Any, Any}","page":"API Reference","title":"Terrarium.compute_NPP","text":"compute_NPP(autoresp, GPP, Ra)\n\n\nComputes Net Primary Productivity NPP as the difference between Gross Primary Production GPP and autotrophic respiration Ra in [kgC/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_PAR-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, NF}} where NF","page":"API Reference","title":"Terrarium.compute_PAR","text":"compute_PAR(photo, swdown)\n\n\nComputes NET Photosynthetically Active Radiation PAR [mol/m¬≤/s].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Ra-Tuple{PALADYNAutotrophicRespiration, PALADYNCarbonDynamics, Vararg{Any, 6}}","page":"API Reference","title":"Terrarium.compute_Ra","text":"compute_Ra(\n    autoresp,\n    vegcarbon_dynamics,\n    T_air,\n    T_soil,\n    Rd,\n    phen,\n    C_veg,\n    GPP\n)\n\n\nComputes autotrophic respiration Ra as the sum of maintenance respiration Rm and growth respiration Rg in [kgC/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Rd-Tuple{LUEPhotosynthesis, Any, Any}","page":"API Reference","title":"Terrarium.compute_Rd","text":"compute_Rd(photo, Vc_max, Œ≤)\n\n\nComputes the leaf respiration rate Rd [gC/m¬≤/s], Eqn 10, Haxeltine & Prentice 1996 and Eq. 10 PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Rg-Union{Tuple{NF}, Tuple{PALADYNAutotrophicRespiration{NF}, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_Rg","text":"compute_Rg(autoresp, GPP, Rm)\n\n\nComputes growth respiration Rg in [kgC/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Rm-Union{Tuple{NF}, Tuple{PALADYNAutotrophicRespiration{NF}, PALADYNCarbonDynamics{NF}, Vararg{Any, 5}}} where NF","page":"API Reference","title":"Terrarium.compute_Rm","text":"compute_Rm(\n    autoresp,\n    vegcarbon_dynamics,\n    T_air,\n    T_soil,\n    Rd,\n    phen,\n    C_veg\n)\n\n\nComputes maintenance respiration Rm in [kgC/m¬≤/day].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Vc_max-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 7}}} where NF","page":"API Reference","title":"Terrarium.compute_Vc_max","text":"compute_Vc_max(\n    photo,\n    c_1,\n    PAR,\n    Kc,\n    Ko,\n    Œì_star,\n    pres_i,\n    pres_O2\n)\n\n\nComputes the maximum rate of net photosynthesis Vc_max [gC/m¬≤/s], following the coordination hypothesis (acclimation), see Harrison 2021 Box 2. Note: this is not the same formula in PALADYN paper, this implementaion is taken from the code\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_autotrophic_respiration","page":"API Reference","title":"Terrarium.compute_autotrophic_respiration","text":"compute_autotrophic_respiration(\n    i, j, grid, fields,\n    autoresp::AbstractAutotrophicRespiration,\n    vegcarbon::AbstractVegetationCarbonDynamics,\n    atmos::AbstractAtmosphere,\n    args...\n)\n\nCell-level autotrophic respiration computation. Implementations should compute autotrophic respiration and related diagnostics (e.g. NPP) for the given cell.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_autotrophic_respiration-Tuple{Any, Any, Any, Any, PALADYNAutotrophicRespiration, PALADYNCarbonDynamics, Terrarium.AbstractAtmosphere}","page":"API Reference","title":"Terrarium.compute_autotrophic_respiration","text":"compute_autotrophic_respiration(\n    i,\n    j,\n    grid,\n    fields,\n    autoresp::PALADYNAutotrophicRespiration,\n    vegcarbon_dynamics::PALADYNCarbonDynamics,\n    atmos::Terrarium.AbstractAtmosphere\n) -> Tuple{Any, Any}\n\n\nCompute autotrophic respiration following the scheme of PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_auxiliary!","page":"API Reference","title":"Terrarium.compute_auxiliary!","text":"compute_auxiliary!(state, model::AbstractModel)\n\nCompute updates to all auxiliary variables based on the current prognostic state of the model.\n\ncompute_auxiliary!(state, grid, process::AbstractProcess, args...)\n\nCompute all auxiliary state variables for the given process on grid. Implementations of AbstractProcess may define additional args that correspond to different process coupling interfaces.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_c1_c2-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 6}}} where NF","page":"API Reference","title":"Terrarium.compute_c1_c2","text":"compute_c1_c2(photo, T_air, Œì_star, Kc, Ko, pres_i, pres_O2)\n\n\nComputes factor for light-limited assimilation c_1 and factor for RuBisCO-limited assimilation c_2, Eqs. C4+C5, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_canopy_interception-Union{Tuple{NF}, Tuple{PALADYNCanopyInterception{NF}, Any, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_canopy_interception","text":"compute_canopy_interception(\n    canopy_interception::PALADYNCanopyInterception{NF},\n    precip,\n    LAI,\n    SAI\n) -> Any\n\n\nCompute I_can, the canopy rain interception, following Eq. 42, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_canopy_saturation_fraction-Union{Tuple{NF}, Tuple{PALADYNCanopyInterception{NF}, Any, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_canopy_saturation_fraction","text":"compute_canopy_saturation_fraction(\n    canopy_interception::PALADYNCanopyInterception{NF},\n    w_can,\n    LAI,\n    SAI\n) -> Any\n\n\nCompute the canopy saturation fraction as w_can / w_can_max.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_canopy_water_removal-Union{Tuple{NF}, Tuple{PALADYNCanopyInterception{NF}, PhysicalConstants{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.compute_canopy_water_removal","text":"compute_canopy_water_removal(\n    canopy_interception::PALADYNCanopyInterception{NF},\n    constants::PhysicalConstants{NF},\n    w_can\n) -> Any\n\n\nCompute the canopy water removal rate as w_can / œÅw / œÑw.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_energy_tendency","page":"API Reference","title":"Terrarium.compute_energy_tendency","text":"compute_energy_tendency(i, j, k, grid, ::SoilEnergyBalance, args...)\n\nCompute the internal energy tendency ‚àÇU‚àÇt at index i, j, k.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_evaporation_canopy-Tuple{PALADYNCanopyEvapotranspiration, Any, Any, Any}","page":"API Reference","title":"Terrarium.compute_evaporation_canopy","text":"compute_evaporation_canopy(\n    _::PALADYNCanopyEvapotranspiration,\n    Œîq,\n    f_can,\n    r‚Çê\n) -> Any\n\n\nCompute evaporation of water intercepted by the canopy from humidity gradient Œîq, canopy saturation fraction f_can, and aerodynamic resistance r‚Çê.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_evaporation_ground-Tuple{PALADYNCanopyEvapotranspiration, Vararg{Any, 4}}","page":"API Reference","title":"Terrarium.compute_evaporation_ground","text":"compute_evaporation_ground(\n    _::PALADYNCanopyEvapotranspiration,\n    Œîq,\n    Œ≤,\n    r‚Çê,\n    r‚Çë\n) -> Any\n\n\nCompute potential evaporation from the ground below the canopy, following Eq. 5, PALADYN (Willeit 2016); Œîq is the humidity gradient, Œ≤ is the ground evaporation resistance factor, r‚Çê is aerodynamic resistance, and r‚Çë is aerodynamic resistance between the ground and canopy.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_evapotranspiration!","page":"API Reference","title":"Terrarium.compute_evapotranspiration!","text":"Compute transpiration, evaporation_ground, and evaporation_canopy fluxes on grid for the given scheme evtr and process dependencies.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_f_deciduous-Union{Tuple{PALADYNPhenology{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.compute_f_deciduous","text":"compute_f_deciduous(phenol)\n\n\nComputes f_deciduous, a factor for smooth transition between evergreen and deciduous [-].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_f_temp-Union{Tuple{NF}, Tuple{PALADYNAutotrophicRespiration{NF}, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_f_temp","text":"compute_f_temp(autoresp, T_air, T_soil)\n\n\nComputes temperature factors f_temp_air and f_temp_soil for autotrophic respiration.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_ground_heat_flux-Tuple{Terrarium.AbstractSkinTemperature, Any, Any, Any}","page":"API Reference","title":"Terrarium.compute_ground_heat_flux","text":"compute_ground_heat_flux(\n    _::Terrarium.AbstractSkinTemperature,\n    R_net,\n    H_s,\n    H_l\n) -> Any\n\n\nCompute the ground heat flux as the residual of the net radiation R_net and the sensible H_s and latent H_l heat flux.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_humidity_vpd","page":"API Reference","title":"Terrarium.compute_humidity_vpd","text":"compute_humidity_vpd(\n    i,\n    j,\n    grid,\n    fields,\n    atmos::Terrarium.AbstractAtmosphere,\n    c::PhysicalConstants\n) -> Any\ncompute_humidity_vpd(\n    i,\n    j,\n    grid,\n    fields,\n    atmos::Terrarium.AbstractAtmosphere,\n    c::PhysicalConstants,\n    Ts\n) -> Any\n\n\nComputes the specific humidity (vapor pressure) deficit over a surface at temperature Ts from the current atmospheric fields.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_hydraulics!-Tuple{Any, Any, Any, Any, Any, Any, SoilHydrology, Terrarium.AbstractStratigraphy, Terrarium.AbstractSoilBiogeochemistry}","page":"API Reference","title":"Terrarium.compute_hydraulics!","text":"compute_hydraulics!(\n    out,\n    i,\n    j,\n    k,\n    grid,\n    fields,\n    hydrology::SoilHydrology,\n    strat::Terrarium.AbstractStratigraphy,\n    bgc::Terrarium.AbstractSoilBiogeochemistry\n) -> Any\n\n\nKernel function that computes soil hydraulics and unsaturated hydraulic conductivity.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_infiltration-Union{Tuple{NF}, Tuple{DirectSurfaceRunoff{NF}, Any, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_infiltration","text":"compute_infiltration(\n    runoff::DirectSurfaceRunoff{NF},\n    influx,\n    sat_top,\n    max_infil\n) -> Any\n\n\nCompute infiltration from the given influx (water available for infiltration), saturation of the uppermost soil layer sat_top, and the maximum allowed infiltration max_infil.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_latent_heat_flux-Tuple{Any, Any, Any, Any, DiagnosedTurbulentFluxes, Terrarium.AbstractEvapotranspiration, PhysicalConstants}","page":"API Reference","title":"Terrarium.compute_latent_heat_flux","text":"compute_latent_heat_flux(\n    i,\n    j,\n    grid,\n    fields,\n    tur::DiagnosedTurbulentFluxes,\n    evtr::Terrarium.AbstractEvapotranspiration,\n    constants::PhysicalConstants\n) -> Any\n\n\nCompute the latent heat flux at i, j based on the given evapotranspiration scheme. This implementation derives the latent heat flux from the surface_humidity_flux defined by evtr which is assumed to be already computed.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_latent_heat_flux-Tuple{Any, Any, Any, Any, DiagnosedTurbulentFluxes, Terrarium.AbstractSkinTemperature, Terrarium.AbstractAtmosphere, PhysicalConstants}","page":"API Reference","title":"Terrarium.compute_latent_heat_flux","text":"compute_latent_heat_flux(\n    i,\n    j,\n    grid,\n    fields,\n    tur::DiagnosedTurbulentFluxes,\n    skinT::Terrarium.AbstractSkinTemperature,\n    atmos::Terrarium.AbstractAtmosphere,\n    constants::PhysicalConstants\n) -> Any\n\n\nCompute the bare ground latent heat flux at i, j based on the current skin temperature and atmospheric conditions. This imlementation assumes that evaporation is the only contributor to the latent heat flux.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_latent_heat_flux-Tuple{DiagnosedTurbulentFluxes, Any, Any, Any}","page":"API Reference","title":"Terrarium.compute_latent_heat_flux","text":"compute_latent_heat_flux(\n    _::DiagnosedTurbulentFluxes,\n    Q_h,\n    œÅ‚Çê,\n    Lsl\n) -> Any\n\n\nCompute the latent heat flux as a function of the humidity flux Q_h [m/s], the density œÅ‚Çê [kg/m¬≥] of air, and the specific latent heat of fusion Lsl [J/kg].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_longwave_up-Tuple{DiagnosedRadiativeFluxes, PhysicalConstants, Any, Any, Any}","page":"API Reference","title":"Terrarium.compute_longwave_up","text":"compute_longwave_up(::DiagnosedRadiativeFluxes, constants::PhysicalConstants, surface_longwave_down, Ts, œµ)\n\nCompute outgoing longwave radiation from incoming surface_longwave_down, surface temperature Ts, and emissivity œµ.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_phen-Union{Tuple{PALADYNPhenology{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.compute_phen","text":"compute_phen(phenol)\n\n\nComputes phen, the phenology factor [-].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_phenology","page":"API Reference","title":"Terrarium.compute_phenology","text":"compute_phenology(i, j, grid, fields, phenol::AbstractPhenology)\n\nCell-level phenology computation. Implementations return phenology factors and derived LAI at the given index i, j.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_photosynthesis","page":"API Reference","title":"Terrarium.compute_photosynthesis","text":"compute_photosynthesis(i, j, grid, fields, photo::AbstractPhotosynthesis, atmos::AbstractAtmosphere)\n\nCell-level photosynthesis computation. Implementations compute leaf respiration and net assimilation for a single horizontal cell and return the pair (Rd, An, GPP) or similar outputs as required by the photosynthesis scheme.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_photosynthesis-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, Vararg{NF, 7}}} where NF","page":"API Reference","title":"Terrarium.compute_photosynthesis","text":"compute_photosynthesis(\n    photo,\n    T_air,\n    swdown,\n    pres,\n    co2,\n    LAI,\n    Œªc,\n    Œ≤\n)\n\n\nComputes Gross Primary Production GPPin [kgC/m¬≤/day] and leaf respiration Rd in [gC/m¬≤/day]\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_plant_available_water","page":"API Reference","title":"Terrarium.compute_plant_available_water","text":"compute_plant_available_water(\n    i, j, k, grid, fields,\n    paw::AbstractPlantAvailableWater,\n    soil::AbstractSoil\n)\n\nComptue the plant-available water fraction for grid cell i, j and soil layer k.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_precip_ground-Union{Tuple{NF}, Tuple{PALADYNCanopyInterception{NF}, Any, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_precip_ground","text":"compute_precip_ground(_, precip, I_can, R_can)\n\n\nCompute precip_ground, the rate of rain reaching the ground, following a modified version of Eq. 44, PALADYN (Willeit 2016). Instead of subtracting the tendency, we just directly subtract interception and add the removal rate R_can.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_pres_i-Tuple{LUEPhotosynthesis, Any, Any}","page":"API Reference","title":"Terrarium.compute_pres_i","text":"compute_pres_i(photo, Œªc, pres_a)\n\n\nComputes intercellular CO2 partial pressure [Pa], Eq. 67, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_resp10-Union{Tuple{PALADYNAutotrophicRespiration{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.compute_resp10","text":"compute_resp10(autoresp)\n\n\nComputes resp10 \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_saturation_tendency!-Tuple{Any, Any, Any, Any, Any, Any, Any, SoilHydrology, Terrarium.AbstractStratigraphy, Terrarium.AbstractSoilBiogeochemistry, PhysicalConstants, Union{Nothing, Terrarium.AbstractEvapotranspiration}}","page":"API Reference","title":"Terrarium.compute_saturation_tendency!","text":"compute_saturation_tendency!(\n    saturation_water_ice_tendency,\n    i,\n    j,\n    k,\n    grid,\n    clock,\n    fields,\n    hydrology::SoilHydrology,\n    strat::Terrarium.AbstractStratigraphy,\n    bgc::Terrarium.AbstractSoilBiogeochemistry,\n    constants::PhysicalConstants,\n    evtr::Union{Nothing, Terrarium.AbstractEvapotranspiration}\n) -> Any\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_sensible_heat_flux-Tuple{Any, Any, Any, Any, DiagnosedTurbulentFluxes, Terrarium.AbstractSkinTemperature, Terrarium.AbstractAtmosphere, PhysicalConstants}","page":"API Reference","title":"Terrarium.compute_sensible_heat_flux","text":"compute_sensible_heat_flux(\n    i,\n    j,\n    grid,\n    fields,\n    tur::DiagnosedTurbulentFluxes,\n    skinT::Terrarium.AbstractSkinTemperature,\n    atmos::Terrarium.AbstractAtmosphere,\n    constants::PhysicalConstants\n) -> Any\n\n\nCompute the sensible heat flux at i, j based on the current skin temperature and atmospheric conditions.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_sensible_heat_flux-Tuple{DiagnosedTurbulentFluxes, Any, Any, Any}","page":"API Reference","title":"Terrarium.compute_sensible_heat_flux","text":"compute_sensible_heat_flux(\n    _::DiagnosedTurbulentFluxes,\n    Q_T,\n    œÅ‚Çê,\n    c‚Çê\n) -> Any\n\n\nCompute the sensible heat flux as a function of the bulk aerodynamic temperature gradient Q_T [K m/s] and the density œÅ‚Çê [kg/m¬≥] and specific heat capacity c‚Çê [J/kg K] of air.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_shortwave_up-Tuple{DiagnosedRadiativeFluxes, Any, Any}","page":"API Reference","title":"Terrarium.compute_shortwave_up","text":"compute_shortwave_up(::DiagnosedRadiativeFluxes, surface_shortwave_down, Œ±)\n\nCompute outgoing shortwave radiation from the incoming surface_shortwave_down and albedo Œ±.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_skin_temperature-Tuple{ImplicitSkinTemperature, Any, Any, Any}","page":"API Reference","title":"Terrarium.compute_skin_temperature","text":"compute_skin_temperature(\n    skinT::ImplicitSkinTemperature,\n    Tg,\n    G,\n    Œîz\n) -> Any\n\n\nCompute the implicit update of the skin temperature from the given ground surface temperature Tg, ground heat flux G, and distance Œîz.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_stomatal_conductance","page":"API Reference","title":"Terrarium.compute_stomatal_conductance","text":"compute_stomatal_conductance(\n    i, j, grid, fields,\n    stomcond::AbstractStomatalConductance,\n    photo::AbstractPhotosynthesis,\n    atmos::AbstractAtmosphere,\n    constants::PhysicalConstants,\n    args...\n)\n\nCell-level stomatal conductance computation. Returns stomatal/canopy conductance and internal CO‚ÇÇ ratio for the specified cell.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_surface_drainage-Union{Tuple{NF}, Tuple{DirectSurfaceRunoff{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.compute_surface_drainage","text":"compute_surface_drainage(\n    runoff::DirectSurfaceRunoff{NF},\n    surface_excess_water\n) -> Any\n\n\nCompute surface drainage flux from the current surface_excess_water resevoir state.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_surface_energy_fluxes!","page":"API Reference","title":"Terrarium.compute_surface_energy_fluxes!","text":"compute_surface_energy_fluxes!(\n    state,\n    grid,\n    seb::SurfaceEnergyBalance,\n    atmos::Terrarium.AbstractAtmosphere,\n    constants::PhysicalConstants\n)\ncompute_surface_energy_fluxes!(\n    state,\n    grid,\n    seb::SurfaceEnergyBalance,\n    atmos::Terrarium.AbstractAtmosphere,\n    constants::PhysicalConstants,\n    hydrology::Union{Nothing, Terrarium.AbstractSurfaceHydrology},\n    args...\n)\n\n\nCompute the surface energy fluxes on grid based on the current atmospheric state.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_surface_energy_fluxes!-2","page":"API Reference","title":"Terrarium.compute_surface_energy_fluxes!","text":"compute_surface_energy_fluxes!(\n    out,\n    i,\n    j,\n    grid,\n    fields,\n    seb::SurfaceEnergyBalance,\n    atmos::Terrarium.AbstractAtmosphere,\n    constants::PhysicalConstants\n) -> Any\ncompute_surface_energy_fluxes!(\n    out,\n    i,\n    j,\n    grid,\n    fields,\n    seb::SurfaceEnergyBalance,\n    atmos::Terrarium.AbstractAtmosphere,\n    constants::PhysicalConstants,\n    evtr::Union{Nothing, Terrarium.AbstractEvapotranspiration},\n    args...\n) -> Any\n\n\nFused kernel function that computes the radiative and turbulent fluxes, as well as the ground heat flux.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_surface_energy_fluxes!-3","page":"API Reference","title":"Terrarium.compute_surface_energy_fluxes!","text":"compute_surface_energy_fluxes!(state, grid, ::AbstractSurfaceEnergyBalance, args...)\n\nCompute the surface energy fluxes and skin temperature from the current state and grid. The required args are implementation dependent.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_surface_excess_water_tendency!-Tuple{Any, Any, Any, Any, Any, Any, Any, SoilHydrology, Union{Nothing, Terrarium.AbstractSurfaceRunoff}}","page":"API Reference","title":"Terrarium.compute_surface_excess_water_tendency!","text":"compute_surface_excess_water_tendency!(\n    surface_excess_water_tendency,\n    i,\n    j,\n    k,\n    grid,\n    clock,\n    fields,\n    hydrology::SoilHydrology,\n    runoff::Union{Nothing, Terrarium.AbstractSurfaceRunoff}\n) -> Any\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_surface_excess_water_tendency-Tuple{Any, Any, Any, Any, Any, Any, SoilHydrology, Union{Nothing, Terrarium.AbstractSurfaceRunoff}}","page":"API Reference","title":"Terrarium.compute_surface_excess_water_tendency","text":"compute_surface_excess_water_tendency(\n    i,\n    j,\n    k,\n    grid,\n    clock,\n    fields,\n    hydrology::SoilHydrology,\n    runoff::Union{Nothing, Terrarium.AbstractSurfaceRunoff}\n) -> Any\n\n\nKernel function for computing the tendency of the prognostic surface_excess_water variable in all grid cells.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_surface_net_radiation-Tuple{Terrarium.AbstractRadiativeFluxes, Vararg{Any, 4}}","page":"API Reference","title":"Terrarium.compute_surface_net_radiation","text":"Compute the net radiation budget given incoming and outgoing shortwave and longwave radiation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_surface_runoff-Tuple{DirectSurfaceRunoff, Any, Any, Any}","page":"API Reference","title":"Terrarium.compute_surface_runoff","text":"compute_surface_runoff(\n    runoff::DirectSurfaceRunoff,\n    precip_ground,\n    surface_drainage,\n    infil\n) -> Any\n\n\nCompute surface runoff as precipitation + surface_drainage - infiltration.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_tendencies!","page":"API Reference","title":"Terrarium.compute_tendencies!","text":"compute_tendencies!(state, model::AbstractModel)\n\nCompute tendencies for all prognostic state variables for model stored in the given state. This method should be called after compute_auxiliary!.\n\ncompute_tendencies!(state, grid, process::AbstractProcess, args...)\n\nCompute the tendencies of all prognostic state variables for the given process on grid. Implementations of AbstractProcess may define additional args that correspond to different process coupling interfaces.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_thermal_conductivity","page":"API Reference","title":"Terrarium.compute_thermal_conductivity","text":"compute_thermal_conductivity(i, j, k, grid, ::SoilEnergyBalance, args...)\n\nCompute the thermal conductivity at index i, j, k.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_thermal_conductivity-Tuple{SoilThermalProperties, SoilVolume}","page":"API Reference","title":"Terrarium.compute_thermal_conductivity","text":"compute_thermal_conductivity(props, soil)\n\n\nCompute the bulk thermal conductivity of the given soil volume.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_transpiration-Union{Tuple{NF}, Tuple{PALADYNCanopyEvapotranspiration{NF}, Any, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_transpiration","text":"compute_transpiration(\n    _::PALADYNCanopyEvapotranspiration{NF},\n    Œîq,\n    r‚Çê,\n    gw_can\n) -> Any\n\n\nCompute potential transpiration from the given humidity gradient, aerodynamic resistance r‚Çê and stomatal conductance gw_can.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_veg_carbon_tendency","page":"API Reference","title":"Terrarium.compute_veg_carbon_tendency","text":"compute_veg_carbon_tendency(i, j, grid, fields, vegcarbon::AbstractVegetationCarbonDynamics)\n\nCell-level vegetation-carbon tendency computation. Implementations compute the tendency for the total vegetation carbon pool at the given index i, j.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_volumetric_water_content_tendency-Union{Tuple{NF}, Tuple{Any, Any, Any, Any, Any, Any, SoilHydrology{NF, RichardsEq, SaturationClosure, SoilHydraulics} where {SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}, PhysicalConstants, Union{Nothing, Terrarium.AbstractEvapotranspiration}}} where NF","page":"API Reference","title":"Terrarium.compute_volumetric_water_content_tendency","text":"compute_volumetric_water_content_tendency(\n    i,\n    j,\n    k,\n    grid,\n    clock,\n    fields,\n    hydrology,\n    constants,\n    evapotranspiration\n)\n\n\nCompute the volumetric water content (VWC) tendency at grid cell i, j k according to the Richardson-Richards equation. Note that the VWC tendency is not scaled by the porosity and is thus not the same as the saturation tendency.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_volumetric_water_content_tendency-Union{Tuple{NF}, Tuple{Any, Any, Any, Any, Any, Any, SoilHydrology{NF, VerticalFlow, SaturationClosure, SoilHydraulics} where {VerticalFlow<:Terrarium.AbstractVerticalFlow, SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}, PhysicalConstants, Union{Nothing, Terrarium.AbstractEvapotranspiration}}} where NF","page":"API Reference","title":"Terrarium.compute_volumetric_water_content_tendency","text":"compute_volumetric_water_content_tendency(\n    i,\n    j,\n    k,\n    grid,\n    clock,\n    fields,\n    hydrology::SoilHydrology{NF, VerticalFlow, SaturationClosure, SoilHydraulics} where {VerticalFlow<:Terrarium.AbstractVerticalFlow, SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})},\n    constants::PhysicalConstants,\n    evtr::Union{Nothing, Terrarium.AbstractEvapotranspiration}\n) -> Any\n\n\nCompute the volumetric water content (VWC) tendency at grid cell i, j k f. Note that the VWC tendency is not scaled by the porosity and is thus not the same as the saturation tendency.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_vpd","page":"API Reference","title":"Terrarium.compute_vpd","text":"compute_vpd(\n    i,\n    j,\n    grid,\n    fields,\n    atmos::Terrarium.AbstractAtmosphere,\n    c::PhysicalConstants\n) -> Any\ncompute_vpd(\n    i,\n    j,\n    grid,\n    fields,\n    atmos::Terrarium.AbstractAtmosphere,\n    c::PhysicalConstants,\n    Ts\n) -> Any\n\n\nComputes the vapor pressure deficit over a surface at temperature Ts from the current atmospheric fields.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_vpd-Union{Tuple{NF}, Tuple{PhysicalConstants{NF}, Any, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_vpd","text":"compute_vpd(c, pres, q_air, T)\n\n\nComputes the vapor pressure deficit over a surface at temperature T from the given surface pressure pres and specific humidity of air q_air.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_w_can_tendency-Union{Tuple{NF}, Tuple{PALADYNCanopyInterception{NF}, Any, Any, Any}} where NF","page":"API Reference","title":"Terrarium.compute_w_can_tendency","text":"compute_w_can_tendency(\n    _::PALADYNCanopyInterception{NF},\n    I_can,\n    E_can,\n    R_can\n) -> Any\n\n\nCompute the w_can tendency and removal rate following Eq. 41, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_water_table!-Union{Tuple{NF}, Tuple{Any, Any, Any, Any, Any, SoilHydrology{NF, VerticalFlow, SaturationClosure, SoilHydraulics} where {VerticalFlow<:Terrarium.AbstractVerticalFlow, SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}}} where NF","page":"API Reference","title":"Terrarium.compute_water_table!","text":"compute_water_table!(\n    water_table,\n    i,\n    j,\n    grid,\n    sat,\n    _::SoilHydrology{NF, VerticalFlow, SaturationClosure, SoilHydraulics} where {VerticalFlow<:Terrarium.AbstractVerticalFlow, SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}\n) -> Any\n\n\nKernel function that diagnoses the water table at grid cell i, j given the current soil saturation profile.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œì_star-Union{Tuple{NF}, Tuple{LUEPhotosynthesis{NF}, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_Œì_star","text":"compute_Œì_star(photo, œÑ, pres_O2)\n\n\nComputes the CO2 compensation point Œì_star, Eq. C6, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œõ_loc-Union{Tuple{NF}, Tuple{PALADYNCarbonDynamics{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.compute_Œõ_loc","text":"compute_Œõ_loc(vegcarbon_dynamics, LAI_b)\n\n\nComputes the local litterfall rate Œõ_loc based on the balanced Leaf Area Index LAI_b (assuming evergreen PFTs), Eq. 75, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œ≥v-Tuple{PALADYNVegetationDynamics}","page":"API Reference","title":"Terrarium.compute_Œ≥v","text":"compute_Œ≥v(veg_dynamics)\n\n\nComputes the disturbance rateŒ≥v, Eq. 80, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œª_NPP-Union{Tuple{NF}, Tuple{PALADYNCarbonDynamics{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.compute_Œª_NPP","text":"compute_Œª_NPP(vegcarbon_dynamics, LAI_b)\n\n\nComputes Œª_NPP,a factor determining the partitioning of NPP between increase of vegetation carbon of the existing  vegetated area and spreading of the given PFT based on the balanced Leaf Area Index LAI_b, Eq. 74, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_Œªc-Union{Tuple{NF}, Tuple{MedlynStomatalConductance{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.compute_Œªc","text":"compute_Œªc(stomcond, vpd)\n\n\nComputes the ratio of leaf-internal and air CO2 concentration Œªc,  derived from the optimal stomatal conductance model (Medlyn et al. 2011), Eq. 71, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_ŒΩ_star-Tuple{PALADYNVegetationDynamics, Any}","page":"API Reference","title":"Terrarium.compute_ŒΩ_star","text":"compute_ŒΩ_star(veg_dynamics, ŒΩ)\n\n\nComputes ŒΩ_star which is the maximum between the current vegetation fraction ŒΩ and the seed fraction ŒΩ_seed [-], to ensure that a PFT is always seeded.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.compute_ŒΩ_tendency","page":"API Reference","title":"Terrarium.compute_ŒΩ_tendency","text":"compute_ŒΩ_tendency(\n    i, j, grid, fields,\n    veg_dynamics::AbstractVegetationDynamics,\n    vegcarbon::AbstractVegetationCarbonDynamics\n)\n\nCell-level vegetation-fraction tendency computation used by vegetation dynamics. Implementations compute the local tendency value for ŒΩ at the given index i, j.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.compute_ŒΩ_tendency-Union{Tuple{NF}, Tuple{PALADYNVegetationDynamics, PALADYNCarbonDynamics{NF}, NF, NF, NF}} where NF","page":"API Reference","title":"Terrarium.compute_ŒΩ_tendency","text":"compute_ŒΩ_tendency(\n    veg_dynamics,\n    vegcarbon_dynamics,\n    LAI_b,\n    C_veg,\n    ŒΩ\n)\n\n\nComputes the vegetation fraction tendency for a single PFT, Eq. 73, PALADYN (Willeit 2016).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.convert_dt-Tuple{Number}","page":"API Reference","title":"Terrarium.convert_dt","text":"convert_dt(Œît)\n\n\nConvert Œîts of type Period to a numeric value in seconds. Return Œît if already a number.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.darcy_flux-NTuple{6, Any}","page":"API Reference","title":"Terrarium.darcy_flux","text":"darcy_flux(i, j, k, grid, œà, K)\n\n\nKernel function for computing the Darcy flux over layer faces from the pressure head œà and hydraulic conductivity K.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.daytime_length-Union{Tuple{PR}, Tuple{NF}, Tuple{Any, Any, Any, Any, Terrarium.AbstractAtmosphere{NF, PR, var\"#s147\", HM, AD} where {var\"#s147\"<:LongShortWaveRadiation, HM<:Terrarium.AbstractHumidity, AD<:Terrarium.AbstractAerodynamics{NF}}}} where {NF, PR}","page":"API Reference","title":"Terrarium.daytime_length","text":"daytime_length(i, j, grid, fields, ::AbstractAtmosphere{PR, <:LongShortWaveRadiation})\n\nRetrieve the length of the day (in hours) at grid cell i, j. Defaults to a constant 12 hours if no input is provided.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.debug!-Tuple{Bool}","page":"API Reference","title":"Terrarium.debug!","text":"debug!(debug::Bool)\n\nEnable or disable global debug mode for Terrarium. Debug mode \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.debughook!-Tuple","page":"API Reference","title":"Terrarium.debughook!","text":"debughook!(args)\n\n\nProvides a \"hook\" for handling debug calls from relevant callsites. Default implementations for Field and NamedTuple (assumed to be of Fields) simply forward to nancheck!.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.debugsite!-Tuple","page":"API Reference","title":"Terrarium.debugsite!","text":"debugsite!(args)\n\n\nUtility method that forwards args to debughook! if and only if debug mode is enabled. Debug mode is set by the global variable DEBUG which can be toggled by the user facing API debug!.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.deduplicate-Tuple{Tuple}","page":"API Reference","title":"Terrarium.deduplicate","text":"deduplicate(values)\n\n\nFilter out duplicates from the given tuple. Note that this method is not type stable or allocation-free!\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.deduplicate_vars-Tuple{Tuple{Vararg{Terrarium.AbstractVariable}}}","page":"API Reference","title":"Terrarium.deduplicate_vars","text":"deduplicate_vars(vars::Tuple{Vararg{AbstractVariable}})\n\nType-stable equivalent of deduplicate for tuples of AbstractVariables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.default_dt","page":"API Reference","title":"Terrarium.default_dt","text":"default_dt(timestepper::AbstractTimeStepper)\n\nGet the current timestep size for the time stepper.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.density_soc-Tuple{Any, Any, Any, Any, Any, ConstantSoilCarbonDensity}","page":"API Reference","title":"Terrarium.density_soc","text":"density_soc(i, j, k, grid, fields, bgc)\n\n\nCalculate the organic solid fraction based on the prescribed SOC and natural porosity/density of the organic material.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.emissivity-Tuple{Any, Any, Any, Any, Terrarium.AbstractAlbedo}","page":"API Reference","title":"Terrarium.emissivity","text":"emissivity(i, j, grid, fields, ::AbstractAlbedo)\n\nReturn the current emissivity at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.energy_to_temperature-Union{Tuple{NF}, Tuple{FreeWater, NF, NF, NF}} where NF","page":"API Reference","title":"Terrarium.energy_to_temperature","text":"Calculate the inverse enthalpy function given the internal energy, latent heat content, and heat capacity under the free water freezing characteristic.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.explicit_step!-Tuple{Any, Terrarium.AbstractLandGrid, Terrarium.AbstractTimeStepper, Any}","page":"API Reference","title":"Terrarium.explicit_step!","text":"explicit_step!(state, grid, timestepper, Œît)\n\n\nEvaluate an explicit update u += ‚àÇu‚àÇt*Œît for all prognostic fields and their corresponding tendencies. By default, this is implemented as a simple Euler update u += dudt*Œît which can serve as a building block for more complex, multi-stage timesteppers. Where necessary, additional dispatches of explicit_step_kernel!(field, tendency, ::AbstractLandGrid, ::TimeStepper, Œît) can be defined to implement more specialized time-stepping schemes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.explicit_step!-Union{Tuple{LZ}, Tuple{LY}, Tuple{LX}, Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}, Oceananigans.Fields.AbstractField{LX, LY, LZ}, Terrarium.AbstractLandGrid, Terrarium.AbstractTimeStepper, Any, Vararg{Any}}} where {LX, LY, LZ}","page":"API Reference","title":"Terrarium.explicit_step!","text":"Accumulate tendency*Œît in the given prognostic field. This method can be overridden by specialized timestepping schemes as needed.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.fastiterate-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{NTuple{N, Any}}}} where {F, N}","page":"API Reference","title":"Terrarium.fastiterate","text":"fastiterate(f!::F, iters::NTuple{N,Any}...) where {F,N}\n\nSame as fastmap but simply invokes f! on each argument set without constructing a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.fastmap-Union{Tuple{F}, Tuple{F, Vararg{NamedTuple}}} where F","page":"API Reference","title":"Terrarium.fastmap","text":"fastmap(f::F, iter::NamedTuple...) where {F}\n\nSame as map for NamedTuples but with guaranteed type stability. fastmap is a @generated function which unrolls calls to f into a loop-free tuple construction expression. All named tuples must have the same keys but in no particular order. The returned NamedTuple \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.fastmap-Union{Tuple{N}, Tuple{F}, Tuple{F, Vararg{NTuple{N, Any}}}} where {F, N}","page":"API Reference","title":"Terrarium.fastmap","text":"fastmap(f::F, iter::NTuple{N,Any}...) where {F,N}\n\nSame as map for NTuples but with guaranteed type stability. fastmap is a @generated function which unrolls calls to f into a loop-free tuple construction expression.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.field_capacity","page":"API Reference","title":"Terrarium.field_capacity","text":"Compute the empirical field capacity of the soil.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.findfirst_z-NTuple{5, Any}","page":"API Reference","title":"Terrarium.findfirst_z","text":"findfirst_z(i, j, condition_func, z_nodes, field)\n\n2D kernel function that finds the first coordinate in z_nodes where condition_func(field[i, j, k]). This implementation performs a linear scan over the z-axis and thus has time complexity O(N_z).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.forcing-Tuple{Any, Any, Any, Any, Any, Any, Terrarium.AbstractEvapotranspiration, Terrarium.AbstractSoilHydrology}","page":"API Reference","title":"Terrarium.forcing","text":"forcing(i, j, k, grid, clock, fields, evtr::AbstractEvapotranspiration, ::AbstractSoilHydrology)\n\nCompute and return the evapotranspiration forcing for soil moisture at the given indices i, j, k. The ET forcing is just the surface_humidity_flux rescaled by the thickness of layer k.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.forcing-Tuple{Any, Any, Any, Any, Any, Any, Union{Oceananigans.Forcings.ContinuousForcing{LX, LY, LZ, P}, Oceananigans.Forcings.DiscreteForcing{P}} where {P, LX, LY, LZ}, Terrarium.AbstractProcess, Vararg{Any}}","page":"API Reference","title":"Terrarium.forcing","text":"forcing(i, j, k, grid, clock, fields, forcing::AbstractForcing, target::AbstractProcess, args...)\n\nReturn the value computed by the given Oceananigans forcing type, which should be an instance of either DiscreteForcing or ContinuousForcing. Note that target and additional args are only included for interface consistency and are not passed through to forcing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_albedo-Tuple{Terrarium.AbstractSurfaceEnergyBalance}","page":"API Reference","title":"Terrarium.get_albedo","text":"get_albedo(seb)\n\nReturn the albedo parameterization associated with the surface energy balance.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_biogeochemistry-Tuple{Terrarium.AbstractSoil}","page":"API Reference","title":"Terrarium.get_biogeochemistry","text":"get_biogeochemistry(soil)\n\nReturn the biogeochemistry scheme associated with soil.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_closure-Tuple{SoilHydrology}","page":"API Reference","title":"Terrarium.get_closure","text":"get_closure(::SoilHydrology) where {NF}\n\nReturn the saturation-pressure closure defined by the given hydrology process, or nothing if not defined for the given configuration.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_constants-Tuple{Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.get_constants","text":"get_constants(model::AbstractModel)::PhysicalConstants\n\nReturn the PhysicalConstants associated with the given model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_energy-Tuple{Terrarium.AbstractGround}","page":"API Reference","title":"Terrarium.get_energy","text":"get_energy(ground)\n\nReturn the energy balance scheme associated with ground.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_field-Union{Tuple{name}, Tuple{Any, Terrarium.AbstractVariable{name}}} where name","page":"API Reference","title":"Terrarium.get_field","text":"get_field(\n    state,\n    var::Terrarium.AbstractVariable{name}\n) -> Any\n\n\nRetrieves the Field from state matching the name of the given variable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_field_grid","page":"API Reference","title":"Terrarium.get_field_grid","text":"get_field_grid(grid::AbstractLandGrid)::Oceananigans.AbstractGrid\n\nReturns the underlying Oceananigans grid type for Fields defined on the given land grid.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.get_field_grid-Tuple{ColumnGrid}","page":"API Reference","title":"Terrarium.get_field_grid","text":"get_field_grid(grid)\n\nReturn the underlying Oceananigans grid stored in ColumnGrid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_fields-Tuple{Any, Tuple{Vararg{Terrarium.AbstractVariable}}}","page":"API Reference","title":"Terrarium.get_fields","text":"get_fields(\n    state,\n    vars::Tuple{Vararg{Terrarium.AbstractVariable}}\n) -> NamedTuple\n\n\nRetrieves all Fields from state matching the names of the given variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_fields-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Terrarium.get_fields","text":"get_fields(state, components; except)\n\n\nRetrieves all non-tendency Fields from state defined on the given components.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_fields-Tuple{Any, Vararg{Union{Symbol, Pair}}}","page":"API Reference","title":"Terrarium.get_fields","text":"get_fields(state, queries::Union{Symbol, Pair}...)\n\nRetrieves fields with names given in queries and returns them in a NamedTuple. Each argument in queries can either be a Symbol corresponding to a field/variable defined in the namespace of state or a Pair{Symbol, Tuple} where the key is the child namespace and the value is a tuple of queries from that namespace.\n\nwarning: Warning\nThis method relies on runtime dispatch and thus should not be used in performance-critical code. If you need to query fields for specific sets of variables or components, use one of the type-stable variants instead.\n\n# initialize model\nstate = initialize(model)\n# get the temperature and saturation_water_ice fields\nfields = get_fields(state, :temperature, :saturation_water_ice)\n# extract temperature as well as variables from a namespace\nnested_fields = get_fields(state, :temperature, :namespace => (:subvar1, :subvar2))\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_grid-Tuple{Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.get_grid","text":"get_grid(model::AbstractModel)::AbstractLandGrid\n\nReturn the spatial grid associated with the given model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_hydraulic_properties-Tuple{SoilHydrology}","page":"API Reference","title":"Terrarium.get_hydraulic_properties","text":"get_hydraulic_properties(hydrology::SoilHydrology)\n\nReturn the soil hydraulic properties defined by the given hydrology process.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_hydrology-Tuple{Terrarium.AbstractGround}","page":"API Reference","title":"Terrarium.get_hydrology","text":"get_hydrology(ground)\n\nReturn the hydrology scheme associated with ground.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_initializer-Tuple{Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.get_initializer","text":"get_initializer(model::AbstractModel)::AbstractInitializer\n\nReturn the initializer associated with the given model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_radiative_fluxes-Tuple{Terrarium.AbstractSurfaceEnergyBalance}","page":"API Reference","title":"Terrarium.get_radiative_fluxes","text":"get_radiative_fluxes(seb)\n\nReturn the radiative_fluxes component of the surface energy balance.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_skin_temperature-Tuple{Terrarium.AbstractSurfaceEnergyBalance}","page":"API Reference","title":"Terrarium.get_skin_temperature","text":"get_skin_temperature(seb)\n\nReturn the skin_temperature process from the surface energy balance.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_spacing-Tuple{Terrarium.AbstractVerticalSpacing}","page":"API Reference","title":"Terrarium.get_spacing","text":"get_spacing(spacing)\n\n\nReturn a Vector of vertical layer thicknesses according to the given discretization.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_stratigraphy-Tuple{Terrarium.AbstractGround}","page":"API Reference","title":"Terrarium.get_stratigraphy","text":"get_stratigraphy(ground)\n\nReturn the ground stratigraphy parameterization associated with ground.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_swrc","page":"API Reference","title":"Terrarium.get_swrc","text":"get_swrc(::AbstractUnsatK)\n\nReturn the soil water retention curve associated with the given unsaturated hydraulic conductivity scheme.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.get_swrc-Tuple{SoilHydrology}","page":"API Reference","title":"Terrarium.get_swrc","text":"get_swrc(hydrology::SoilHydrology)\n\nReturn the soil water retention curve from the hydraulic_properties associated with the given SoilHydrology configuration.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_turbulent_fluxes-Tuple{Terrarium.AbstractSurfaceEnergyBalance}","page":"API Reference","title":"Terrarium.get_turbulent_fluxes","text":"get_turbulent_fluxes(seb)\n\nReturn the turbulent_fluxes component of the surface energy balance.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.get_workspec-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, LZ}}, Tuple{LZ}, Tuple{LY}, Tuple{LX}} where {LX, LY, LZ}","page":"API Reference","title":"Terrarium.get_workspec","text":"Returns the appropriate workspec for the given AbstractField or based on the given field locations.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.ground_evaporation_resistance_factor","page":"API Reference","title":"Terrarium.ground_evaporation_resistance_factor","text":"ground_evaporation_resistance_factor(i, j, grid, fields, :AbstractGroundEvaporationResistanceFactor, args...)\n\nCompute the resistance factor against ground evaporation [-] based on the current state and implementation-specific process dependencies in args.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.ground_heat_flux-Tuple{Any, Any, Any, Any, Terrarium.AbstractSkinTemperature}","page":"API Reference","title":"Terrarium.ground_heat_flux","text":"ground_heat_flux(i, j, grid, fields, ::AbstractSkinTemperature)\n\nReturn the current ground heat flux at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.ground_precipitation","page":"API Reference","title":"Terrarium.ground_precipitation","text":"ground_precipitation(i, j, grid, fields, ::AbstractCanopyInterception)\n\nCompute or retrieve the current rate of precipitation reaching the ground [m/s].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.heat_capacity-Tuple{SoilThermalProperties, SoilVolume}","page":"API Reference","title":"Terrarium.heat_capacity","text":"heat_capacity(props, soil)\n\n\nCompute the bulk heat capacity of the given soil volume.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.hydraulic_conductivity","page":"API Reference","title":"Terrarium.hydraulic_conductivity","text":"Compute (variably saturated) hydraulic conductivity based on the given hydraulic properties, soil water retention curve (SWRC), and volumetric fractions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.hydraulic_conductivity-Tuple{Any, Any, Any, Any, Any, SoilHydrology, Terrarium.AbstractStratigraphy, Terrarium.AbstractSoilBiogeochemistry}","page":"API Reference","title":"Terrarium.hydraulic_conductivity","text":"hydraulic_conductivity(\n    i,\n    j,\n    k,\n    grid,\n    fields,\n    hydrology,\n    strat,\n    bgc\n)\n\n\nCompute the hydraulic conductivity at the center of the grid cell i, j, k.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize!","page":"API Reference","title":"Terrarium.initialize!","text":"initialize!(state, model::AbstractModel)\n\nInitialize all variables defined in state which are defined by model. This defaults to simply calling initialize!(state, model, get_initializer(model)).\n\ninitialize!(state, model::AbstractModel, initializer::AbstractInitializer)\n\nInitialize the model state variables using the corresponding initializer. This method only needs to be implemented if initialization routines are necessary in addition to direct field/variable initializers.\n\ninitialize!(state, grid, process::AbstractProcess, args...)\n\nInitialize all state variables associated with the given process on grid. Implementations of AbstractProcess may define additional args that correspond to different process coupling interfaces.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.initialize!-Tuple{ModelIntegrator}","page":"API Reference","title":"Terrarium.initialize!","text":"Resets the simulation clock and calls initialize!(state, model) on the underlying model which should reset all state variables to their values as defiend by the model initializer.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize!-Union{Tuple{names}, Tuple{Any, NamedTuple{names}}} where names","page":"API Reference","title":"Terrarium.initialize!","text":"initialize!(state, inits::NamedTuple{names}) -> Any\n\n\nInitialize the state with Field initializers (any valid argument to set!) in inits.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Tuple{Terrarium.AbstractTimeStepper, Any, Any}","page":"API Reference","title":"Terrarium.initialize","text":"initialize(::AbstractTimeStepper, model, state) where {NF}\n\nInitialize and return the time stepping state cache for the given time stepper.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Tuple{Terrarium.AbstractVariable, Terrarium.AbstractLandGrid, Clock, NamedTuple, NamedTuple}","page":"API Reference","title":"Terrarium.initialize","text":"initialize(var::AbstractVariable, grid::AbstractLandGrid, clock::Clock, boundary_conditions::NamedTuple, fields::NamedTuple)\n\nInitialize a Field on grid based on the given var metadata. The named tuple of boundary_conditions should follow the standard convention of (var1 = (; top, bottom, ...), var2 = (; top, bottom, ...)). If fields contains a Field matching the name of var, this field will be directly returned. Otherwise, the new Field is constructed using the given boundary_conditions with the other fields being made available to the constructor for auxiliary variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Union{Tuple{NF}, Tuple{Terrarium.AbstractModel{NF, Grid} where Grid<:(Terrarium.AbstractLandGrid{NF}), Terrarium.AbstractTimeStepper, Vararg{InputSource}}} where NF","page":"API Reference","title":"Terrarium.initialize","text":"Creates and initializes a ModelIntegrator for the given model with the given clock state. This method allocates all necessary Fields for the state variables and calls initialize!(::ModelIntegrator). Note that this method is not type stable and should not be called in an Enzyme autodiff call.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Union{Tuple{NF}, Tuple{Terrarium.AbstractProcess, Terrarium.AbstractLandGrid{NF}}} where NF","page":"API Reference","title":"Terrarium.initialize","text":"initialize(\n    process::AbstractProcess,\n    grid::AbstractLandGrid{NF};\n    clock = Clock(time=zero(NF)),\n    input_variables = (),\n    boundary_conditions = (;),\n    initializers = (;),\n    fields = (;)\n) where {NF}\n\nInitialize a StateVariables data structure containing Fields defined on the given grid for all variables defined by process. Any predefined boundary_conditions and fields will be passed through to initialize for each variable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Union{Tuple{NF}, Tuple{Terrarium.Variables, Terrarium.AbstractLandGrid{NF}}} where NF","page":"API Reference","title":"Terrarium.initialize","text":"initialize(\n    vars::Variables,\n    grid::AbstractLandGrid{NF};\n    clock::Clock = Clock(time=0.0),\n    boundary_conditions = (;),\n    initializers = (;),\n    fields = (;)\n) where {NF}\n\nInitialize a StateVariables data structure containing Fields defined on the given grid for all variables in vars. Any predefined boundary_conditions and fields will be passed through to initialize for each variable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Union{Tuple{Terrarium.AbstractModel{NF, Grid} where Grid<:(Terrarium.AbstractLandGrid{NF})}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.initialize","text":"initialize(\n    process::AbstractProcess,\n    grid::AbstractLandGrid{NF};\n    clock = Clock(time=zero(NF)),\n    input_variables = (),\n    boundary_conditions = (;),\n    initializers = (;),\n    fields = (;)\n) where {NF}\n\nInitialize a StateVariables data structure containing Fields for all variables defined by model, initialized on its associated grid. Any predefined boundary_conditions and fields will be passed through to initialize for each variable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.initialize-Union{Tuple{names}, Tuple{NamedTuple{names, <:Tuple{Vararg{Terrarium.AbstractVariable}}}, Terrarium.AbstractLandGrid, Clock, NamedTuple, NamedTuple}} where names","page":"API Reference","title":"Terrarium.initialize","text":"initialize(\n    vars::NamedTuple{names, <:Tuple{Vararg{AbstractVariable}}},\n    grid::AbstractLandGrid,\n    clock::Clock,\n    boundary_conditions::NamedTuple,\n    fields::NamedTuple\n) where {names}\n\nInitialize Fields on grid for each of the variables in the given named tuple vars. Any predefined boundary_conditions and fields will be passed through to initialize for each variable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.input-Tuple{Symbol, Terrarium.VarDims}","page":"API Reference","title":"Terrarium.input","text":"input(name, dims; default, units, domain, desc)\n\n\nConvenience constructor method for InputVariable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.input_fields-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Terrarium.input_fields","text":"input_fields(state, components)\n\n\nRetrieves all Fields from state corresponding to input variables defined on the given components.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.input_variables-Tuple{Any}","page":"API Reference","title":"Terrarium.input_variables","text":"Helper method that selects only input variables declared on obj.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.invclosure!-Tuple{Any, Terrarium.AbstractModel}","page":"API Reference","title":"Terrarium.invclosure!","text":"invclosure!(state, model::AbstractModel)\n\nApply the inverse of all closure relations defined for the given model.\n\ninvclosure!(state, grid, [closure,] process, args...)\n\nApply the closure for process with the given grid and additional implementation-specific args. If closure is not specified, it is automatically inferred from first(closures(process)).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.invclosure!-Union{Tuple{NF}, Tuple{Any, Any, SoilSaturationPressureClosure, SoilHydrology{NF, RichardsEq, SaturationClosure, SoilHydraulics} where {SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}, Terrarium.AbstractSoil, Vararg{Any}}} where NF","page":"API Reference","title":"Terrarium.invclosure!","text":"invclosure!(\n    state,\n    grid,\n    closure::SoilSaturationPressureClosure,\n    hydrology::SoilHydrology{NF, RichardsEq, SaturationClosure, SoilHydraulics} where {SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})},\n    soil::Terrarium.AbstractSoil,\n    args...\n)\n\n\nComputes saturation_water_ice from the current pressure_head state.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.is_adaptive","page":"API Reference","title":"Terrarium.is_adaptive","text":"is_adaptive(timestepper::AbstractTimeStepper)\n\nReturn true if the given time stepper is adaptive, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.is_initialized","page":"API Reference","title":"Terrarium.is_initialized","text":"is_initialized(timestepper::AbstractTimeStepper)\n\nReturn true if the timestepper is initialized, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.latent_heat_flux-Tuple{Any, Any, Any, Any, Terrarium.AbstractTurbulentFluxes}","page":"API Reference","title":"Terrarium.latent_heat_flux","text":"latent_heat_flux(i, j, grid, fields, ::AbstractTurbulentFluxes)\n\nReturn the current latent heat flux at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.liquid_water_fraction-Union{Tuple{NF}, Tuple{FreeWater, NF, NF, NF}} where NF","page":"API Reference","title":"Terrarium.liquid_water_fraction","text":"Calculate the unfrozen water content from the given internal energy, latent heat content, and saturation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.longwave_down-Union{Tuple{PR}, Tuple{NF}, Tuple{Any, Any, Any, Any, Terrarium.AbstractAtmosphere{NF, PR, var\"#s147\", HM, AD} where {var\"#s147\"<:LongShortWaveRadiation, HM<:Terrarium.AbstractHumidity, AD<:Terrarium.AbstractAerodynamics{NF}}}} where {NF, PR}","page":"API Reference","title":"Terrarium.longwave_down","text":"longwave_down(i, j, grid, fields, ::AbstractAtmosphere{NF, PR, <:LongShortWaveRadiation})\n\nRetrieve or compute the incoming/downwelling longwave radiation at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.longwave_up-Tuple{Any, Any, Any, Any, Terrarium.AbstractRadiativeFluxes}","page":"API Reference","title":"Terrarium.longwave_up","text":"longwave_up(i, j, grid, fields, ::AbstractRadiativeFluxes)\n\nReturn the current outgoing (upwelling) longwave radiation at the given indices i, j.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.merge_boundary_conditions-Tuple{Vararg{NamedTuple{names, BCs} where {names, BCs<:Tuple{Vararg{Union{Oceananigans.BoundaryConditions.FieldBoundaryConditions, NamedTuple{locs, <:Tuple{Vararg{Oceananigans.BoundaryConditions.BoundaryCondition}}}} where locs}}}}}","page":"API Reference","title":"Terrarium.merge_boundary_conditions","text":"merge_boundary_conditions(bcs::FieldBCs...)\n\nRecursively merge an arbitrary number of field/variable boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.merge_recursive-Tuple{NamedTuple, NamedTuple, Vararg{Any}}","page":"API Reference","title":"Terrarium.merge_recursive","text":"merge_recursive(nt1::NamedTuple, nt2::NamedTuple)\n\nRecursively merge two nested named tuples. This implementation is loosely based on the one in NamedTupleTools authored by Jeffrey Sarnoff.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.min_z·µÉ·µÉ·∂†-NTuple{5, Any}","page":"API Reference","title":"Terrarium.min_z·µÉ·µÉ·∂†","text":"min_z·µÉ·µÉ·∂†(i, j, k, grid, x)\nmin_z·µÉ·µÉ·∂†(i, j, k, grid, f, args...)\n\nComputes the field or function at the vertical (z-axis) face by taking the min of the two adjacent vertical layers.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.mineral_porosity","page":"API Reference","title":"Terrarium.mineral_porosity","text":"mineral_porosity(::AbstractSoilPorosity, texture::SoilTexture)\n\nCompute or retrieve the natural porosity of the mineral soil constitutents, i.e. excluding organic material.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.namespace-Tuple{Symbol, Terrarium.Variables}","page":"API Reference","title":"Terrarium.namespace","text":"namespace(name, vars)\n\n\nConvenience constructor method for variable Namespaces.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.nancheck!","page":"API Reference","title":"Terrarium.nancheck!","text":"nancheck!(field)\nnancheck!(field, name)\n\n\nCheck whether the given field has any NaN values using Diagnostics.hasnan and raise an error if NaNs are detected.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.ntdiff-Union{Tuple{excluded}, Tuple{NamedTuple, NamedTuple{excluded}}} where excluded","page":"API Reference","title":"Terrarium.ntdiff","text":"ntdiff(\n    nt::NamedTuple,\n    other::NamedTuple{excluded}\n) -> NamedTuple\n\n\nFilters out all entries from nt that exist in other; like setdiff but for NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.num_layers-Tuple{Terrarium.AbstractLandGrid}","page":"API Reference","title":"Terrarium.num_layers","text":"Return the number of vertical layers defined by the given grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.num_layers-Tuple{Terrarium.AbstractVerticalSpacing}","page":"API Reference","title":"Terrarium.num_layers","text":"num_layers(spacing)\n\n\nReturn the number of vertical layers defined by this discretization.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.organic_porosity","page":"API Reference","title":"Terrarium.organic_porosity","text":"organic_porosity(::AbstractSoilPorosity, texture::SoilTexture)\n\nCompute or retrieve the natural porosity of the organic soil constitutents, i.e. excluding mineral material.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.partial_pressure_CO2-Union{Tuple{NF}, Tuple{NF, NF}} where NF","page":"API Reference","title":"Terrarium.partial_pressure_CO2","text":"partial_pressure_CO2(pres, conc_co2)\n\n\nCompute partial pressure of CO2 from surface pressure and CO2 concentration in Pa.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.partial_pressure_O2-Tuple{NF} where NF","page":"API Reference","title":"Terrarium.partial_pressure_O2","text":"partial_pressure_O2(pres)\n\n\nCompute partial pressure of oxygen from surface pressure in Pa.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.piecewise_linear-Tuple{Vararg{Pair{<:Unitful.Quantity{NF, ùêã, U} where {NF, U<:Unitful.Units}}}}","page":"API Reference","title":"Terrarium.piecewise_linear","text":"piecewise_linear(knots; extrapolation)\n\n\nReturn a function f(z) that linearly interpolates between the given knots.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.porosity-Tuple{Any, Any, Any, Any, Any, HomogeneousStratigraphy, Terrarium.AbstractSoilBiogeochemistry}","page":"API Reference","title":"Terrarium.porosity","text":"porosity(\n    i,\n    j,\n    k,\n    grid,\n    fields,\n    strat::HomogeneousStratigraphy,\n    bgc::Terrarium.AbstractSoilBiogeochemistry\n) -> Any\n\n\nCompute the porosity of the soil volume at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.processes-Tuple{Union{Terrarium.AbstractCoupledProcesses, Terrarium.AbstractModel}}","page":"API Reference","title":"Terrarium.processes","text":"processes(obj::Union{AbstractCoupledProcesses, AbstractModel})\n\nReturn a tuple of AbstractProceses contained in the given model or coupled processes type. Note that this is a type-stable, @generated function that is compiled for each argument type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.prognostic-Tuple{Symbol, Terrarium.VarDims}","page":"API Reference","title":"Terrarium.prognostic","text":"prognostic(name, dims; units, closure, domain, desc)\n\n\nConvenience constructors for PrognosticVariable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.prognostic_fields-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Terrarium.prognostic_fields","text":"prognostic_fields(state, components)\n\n\nRetrieves all Fields from state corresponding to prognostic variables defined on the given components.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.prognostic_variables-Tuple{Any}","page":"API Reference","title":"Terrarium.prognostic_variables","text":"Helper method that selects only prognostic variables declared on obj.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.psychrometric_constant-Tuple{PhysicalConstants, Any}","page":"API Reference","title":"Terrarium.psychrometric_constant","text":"psychrometric_constant(c::PhysicalConstants, p)\n\nCalcualte the psychrometric constant at the given atmospheric pressure p.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.rainfall-Union{Tuple{NF}, Tuple{Any, Any, Any, Any, Terrarium.AbstractAtmosphere{NF, var\"#s147\", IR, HM, AD} where {var\"#s147\"<:RainSnow, IR<:Terrarium.AbstractIncomingRadiation, HM<:Terrarium.AbstractHumidity, AD<:Terrarium.AbstractAerodynamics{NF}}}} where NF","page":"API Reference","title":"Terrarium.rainfall","text":"rainfall(i, j, grid, fields, ::AbstractAtmosphere{NF, <:RainSnow})\n\nRetrieve or compute the liquid precipitation (rainfall) at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.relative_to_specific_humidity-Tuple{Any, Any, Any}","page":"API Reference","title":"Terrarium.relative_to_specific_humidity","text":"relative_to_specific_humidity(r_h, pr, Tair)\n\nDerives specific humidity from measured relative humidity, air pressure, and air temperature.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.reset_tendencies!-Tuple{StateVariables}","page":"API Reference","title":"Terrarium.reset_tendencies!","text":"Reset all tendencies in state to zero.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.root_density","page":"API Reference","title":"Terrarium.root_density","text":"root_density(::AbstractRootDistribution, z, args...)\n\nCompute the continuous density function of the given root distirbution as a function of depth z. Note that this function must be integrated and normalized over the root zone in order to obtain the cumulative root fraction in each soil layer.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.root_density-Union{Tuple{NF}, Tuple{StaticExponentialRootDistribution{NF}, Any}} where NF","page":"API Reference","title":"Terrarium.root_density","text":"root_density(\n    rd::StaticExponentialRootDistribution{NF},\n    z\n) -> Any\n\n\nCompute the continuous density function of the root distirbution as a function of depth z.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.root_fraction-Union{Tuple{NF}, Tuple{StaticExponentialRootDistribution{NF}, Terrarium.AbstractColumnGrid, Any, Any}} where NF","page":"API Reference","title":"Terrarium.root_fraction","text":"Returns a FunctionField that lazily computes the static root distribution on a 1D column grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.safediv-Union{Tuple{NF}, Tuple{NF, NF}} where NF","page":"API Reference","title":"Terrarium.safediv","text":"safediv(x, y)\n\n\nEvaluates x / (y + eps(NF)) if and only if y != zero(y); returns Inf otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.saturated_hydraulic_conductivity","page":"API Reference","title":"Terrarium.saturated_hydraulic_conductivity","text":"Compute hydraulic conductivity at saturation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.saturation_canopy_water","page":"API Reference","title":"Terrarium.saturation_canopy_water","text":"saturation_canopy_water(i, j, grid, fields, ::AbstractCanopyInterception)\n\nCompute or retrieve the current canopy water saturation fraction [-].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.saturation_vapor_pressure-NTuple{4, Any}","page":"API Reference","title":"Terrarium.saturation_vapor_pressure","text":"saturation_vapor_pressure(T, a‚ÇÅ, a‚ÇÇ, a‚ÇÉ)\n\nAugust-Roche-Magnus equation for saturation vapor pressure at temperature T with empirical coefficients a‚ÇÅ, a‚ÇÇ, and a‚ÇÉ.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.saturation_vapor_pressure-Tuple{NF} where NF","page":"API Reference","title":"Terrarium.saturation_vapor_pressure","text":"saturation_vapor_pressure(T, Ts=T)\n\nSaturation vapor pressure at the given temperature T, accounting for both frozen (T < 0¬∞C) and unfrozen conditions.\n\nCoefficients taken from Alduchov and Eskridge (1997).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.seconds_per_day-Union{Tuple{Type{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.seconds_per_day","text":"Return the number of seconds per day in the given number format.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.seconds_per_hour-Union{Tuple{Type{NF}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.seconds_per_hour","text":"Return the number of seconds per hour in the given number format.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.sensible_heat_flux-Tuple{Any, Any, Any, Any, Terrarium.AbstractTurbulentFluxes}","page":"API Reference","title":"Terrarium.sensible_heat_flux","text":"sensible_heat_flux(i, j, grid, fields, ::AbstractTurbulentFluxes)\n\nReturn the current sensible heat flux at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.shortwave_down-Union{Tuple{PR}, Tuple{NF}, Tuple{Any, Any, Any, Any, Terrarium.AbstractAtmosphere{NF, PR, var\"#s147\", HM, AD} where {var\"#s147\"<:LongShortWaveRadiation, HM<:Terrarium.AbstractHumidity, AD<:Terrarium.AbstractAerodynamics{NF}}}} where {NF, PR}","page":"API Reference","title":"Terrarium.shortwave_down","text":"shortwave_down(i, j, grid, fields, ::AbstractAtmosphere{NF, PR, <:LongShortWaveRadiation})\n\nRetrieve or compute the incoming/downwelling shortwave radiation at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.shortwave_up-Tuple{Any, Any, Any, Any, Terrarium.AbstractRadiativeFluxes}","page":"API Reference","title":"Terrarium.shortwave_up","text":"shortwave_up(i, j, grid, fields, ::AbstractRadiativeFluxes)\n\nReturn the current outgoing (upwelling) shortwave radiation at the surface.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.skin_temperature-Tuple{Any, Any, Any, Any, Terrarium.AbstractSkinTemperature}","page":"API Reference","title":"Terrarium.skin_temperature","text":"skin_temperature(i, j, grid, fields, ::AbstractSkinTemperature)\n\nReturn the current skin temperature at the given indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.snowfall-Union{Tuple{NF}, Tuple{Any, Any, Any, Any, Terrarium.AbstractAtmosphere{NF, var\"#s147\", IR, HM, AD} where {var\"#s147\"<:RainSnow, IR<:Terrarium.AbstractIncomingRadiation, HM<:Terrarium.AbstractHumidity, AD<:Terrarium.AbstractAerodynamics{NF}}}} where NF","page":"API Reference","title":"Terrarium.snowfall","text":"snowfall(i, j, grid, fields, ::AbstractAtmosphere{NF, <:RainSnow})\n\nRetrieve or compute the frozen precipitation (snowfall) at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.soil_matrix","page":"API Reference","title":"Terrarium.soil_matrix","text":"soil_matrix(i, j, k, grid, fields, ::AbstractStratigraphy, args...)\n\nReturn the solid matrix of the soil at index i, j, k for the given stratigraphy parameterization.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.soil_matrix-Tuple{Any, Any, Any, Any, Any, Terrarium.AbstractStratigraphy, Terrarium.AbstractSoilBiogeochemistry}","page":"API Reference","title":"Terrarium.soil_matrix","text":"soil_matrix(\n    i,\n    j,\n    k,\n    grid,\n    fields,\n    strat::Terrarium.AbstractStratigraphy,\n    bgc::Terrarium.AbstractSoilBiogeochemistry\n) -> MineralOrganic\n\n\nCompute and return the soil solid matrix at index i, j, k on grid. The default implementation assumes a simple MineralOrganic parameterization of the solid material.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.soil_moisture_limiting_factor-Tuple{FieldCapacityLimitedPAW, Any, Any, Any}","page":"API Reference","title":"Terrarium.soil_moisture_limiting_factor","text":"soil_moisture_limiting_factor(\n    _::FieldCapacityLimitedPAW,\n    grid,\n    clock,\n    fields\n) -> Field{LX, LY, LZ, O, G, I, D, T, B, Oceananigans.Fields.FieldStatus{Float64}} where {LX, LY, LZ, O, G, I, D, T, B}\n\n\nField constructor for the soil moisture limiting factor. Returns a derived Field that calculates the integral of W(z) * r(z) where W is the water availability coefficient and r is the root fraction.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.soil_texture","page":"API Reference","title":"Terrarium.soil_texture","text":"soil_texture(i, j, k, grid, fields, ::AbstractStratigraphy, args...)\n\nReturn the texture of the soil at index i, j, k for the given stratigraphy parameterization.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.soil_volume","page":"API Reference","title":"Terrarium.soil_volume","text":"soil_volume(i, j, k, grid, fields, ::AbstractStratigraphy, args...)\n\nReturn a description of the full material composition of the soil volume at index i, j, k for the given stratigraphy parameterization.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.soil_volume-Tuple{Any, Any, Any, Any, Any, Terrarium.AbstractStratigraphy, Terrarium.AbstractSoilHydrology, Terrarium.AbstractSoilBiogeochemistry}","page":"API Reference","title":"Terrarium.soil_volume","text":"soil_volume(i, j, k, grid, fields, strat, hydrology, bgc)\n\n\nConstruct a SoilVolume object summarizing the material composition of the soil volume at the given indices i, j, k on grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.specific_humidity-Union{Tuple{IR}, Tuple{PR}, Tuple{NF}, Tuple{Any, Any, Any, Any, Terrarium.AbstractAtmosphere{NF, PR, IR, var\"#s147\", AD} where {var\"#s147\"<:Terrarium.SpecificHumidity, AD<:Terrarium.AbstractAerodynamics{NF}}}} where {NF, PR, IR}","page":"API Reference","title":"Terrarium.specific_humidity","text":"specific_humidity(i, j, grid, fields, ::PrescribedAtmosphere{PR, IR, <:SpecificHumidity})\n\nRetrieve or compute the specific_humidity at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.stefan_boltzmann-Tuple{PhysicalConstants, Any, Any}","page":"API Reference","title":"Terrarium.stefan_boltzmann","text":"stefan_boltzmann(c::PhysicalConstants, T, œµ)\n\nStefan-Boltzmann law M = epsilon sigma T^4 where T is the surface temperature in Kelvin and œµ is the emissivity.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.surface_humidity_flux","page":"API Reference","title":"Terrarium.surface_humidity_flux","text":"surface_humidity_flux(i, j, grid, fields, ::AbstractEvapotranspiration)\n\nCompute the surface humidity flux [m/s] at cell i, j based on the current state.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.surface_net_radiation-Tuple{Any, Any, Any, Any, Terrarium.AbstractRadiativeFluxes}","page":"API Reference","title":"Terrarium.surface_net_radiation","text":"surface_net_radiation(i, j, grid, fields, ::AbstractRadiativeFluxes)\n\nReturn the current surface net radiation at the given indices i, j.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.tendency-Tuple{Terrarium.Variable}","page":"API Reference","title":"Terrarium.tendency","text":"tendency(var)\n\n\nCreates an AuxiliaryVariable for the tendency of a prognostic variable with the given name, dimensions, and physical units. This constructor is primarily used internally by other constructors and does not usually need to be called by implementations of variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.tendency_fields-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Terrarium.tendency_fields","text":"tendency_fields(state, components)\n\n\nRetrieves all Fields from state corresponding to tendencies defined on the given components.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.timestep!","page":"API Reference","title":"Terrarium.timestep!","text":"timestep!(integrator::ModelIntegrator, timestepper::AbstractTimeStepper, Œît)\n\nAdvance prognostic variables of the integrator model by one time step based on the current state, or by Œît units of time.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.timestep!-Tuple{Any, Terrarium.AbstractModel, Terrarium.AbstractTimeStepper, Any}","page":"API Reference","title":"Terrarium.timestep!","text":"timestep!(state, model::AbstractModel, timestepper::AbstractTimeStepper, Œît)\n\nApply any necessary corrections or model-specific time stepping logic after applying timestepper to the prognostic state variables defined by model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.timestep!-Tuple{ModelIntegrator}","page":"API Reference","title":"Terrarium.timestep!","text":"timestep!(integrator; finalize)\n\n\nAdvance the model forward by one timestep with optional timestep size Œît. If finalize = true, compute_auxiliary! is called after the time step in order to update the values of auxiliary/diagnostic variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.tuplejoin-Tuple{}","page":"API Reference","title":"Terrarium.tuplejoin","text":"tuplejoin()\n\n\nConcatenate one or more tuples together.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.update_inputs!-Tuple{Any, InputSource, Clock}","page":"API Reference","title":"Terrarium.update_inputs!","text":"update_inputs!(fields, _, _)\n\n\nUpdates the values of input variables stored in fields from the given input source. Default implementation simply returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.update_inputs!-Tuple{StateVariables, InputSources}","page":"API Reference","title":"Terrarium.update_inputs!","text":"Update input variables from the given input sources.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.vapor_pressure_to_specific_humidity-Tuple{Any, Any, Any}","page":"API Reference","title":"Terrarium.vapor_pressure_to_specific_humidity","text":"vapor_pressure_to_specific_humidity(e, p, Œµ)\n\nConvert the vapor pressure e to specific humidity at the given pressure p based on the molecular weight ratio Œµ.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.var","page":"API Reference","title":"Terrarium.var","text":"var(name, dims)\nvar(name, dims, units)\n\n\nConvenience constructor for Variable.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.vardims-Tuple{Terrarium.AbstractVariable}","page":"API Reference","title":"Terrarium.vardims","text":"vardims(var)\n\n\nRetrieve the grid dimensions on which this variable is defined.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.vardims-Union{Tuple{Oceananigans.Fields.AbstractField{LX, LY, Nothing}}, Tuple{LY}, Tuple{LX}} where {LX, LY}","page":"API Reference","title":"Terrarium.vardims","text":"vardims(_)\n\n\nInfer the appropriate VarDims from the given Field.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.variables","page":"API Reference","title":"Terrarium.variables","text":"variables(model::AbstractModel)\n\nReturn a Tuple of AbstractVariables (i.e. PrognosticVariable, AuxiliaryVariable, etc.) defined by the model or process.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.variables-Tuple{InputSource}","page":"API Reference","title":"Terrarium.variables","text":"variables(_)\n\n\nReturns a tuple of Symbols corresponding to variable names supported by this InputSource.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.variables-Tuple{SoilEnergyTemperatureClosure}","page":"API Reference","title":"Terrarium.variables","text":"Defines temperature as the closure variable for SoilEnergyTemperatureClosure.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.variables-Tuple{Vararg{Union{Terrarium.AbstractVariable, Terrarium.Namespace}}}","page":"API Reference","title":"Terrarium.variables","text":"Alias for Variables(vars...)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.variables-Union{Tuple{SoilHydrology{NF, VerticalFlow, SaturationClosure, SoilHydraulics} where {VerticalFlow<:Terrarium.AbstractVerticalFlow, SaturationClosure<:Terrarium.AbstractSoilWaterClosure, SoilHydraulics<:(Terrarium.AbstractSoilHydraulics{NF})}}, Tuple{NF}} where NF","page":"API Reference","title":"Terrarium.variables","text":"State variables for SoilHydrology processes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.varname-Union{Tuple{Terrarium.AbstractVariable{name}}, Tuple{name}} where name","page":"API Reference","title":"Terrarium.varname","text":"varname(_)\n\n\nRetrieve the name of the given variable or closure. For closure relations, varname should return the name of the variable returned by the closure relation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.varunits-Tuple{Terrarium.AbstractVariable}","page":"API Reference","title":"Terrarium.varunits","text":"varunits(var)\n\n\nRetrieve the physical units for the given variable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.volumetric_fractions-Tuple{SoilVolume}","page":"API Reference","title":"Terrarium.volumetric_fractions","text":"volumetric_fractions(soil::SoilVolume) -> NamedTuple\n\n\nCalculates the volumetric fractions of all constituents in the given soil volume and returns them as a named tuple of the form (; water, ice, air, solids...), where solids correspodns to the volumetric fractions defined by the solid phase soil.solid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.volumetric_fractions-Union{Tuple{NF}, Tuple{MineralOrganic{NF}, NF}} where NF","page":"API Reference","title":"Terrarium.volumetric_fractions","text":"volumetric_fractions(\n    solid::MineralOrganic{NF},\n    solid_frac\n) -> NamedTuple{(:organic, :mineral), <:Tuple{Any, Any}}\n\n\nCompute the volumetric fractions of the solid phase scaled by the overall solid fraction of the soil solid_frac.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.wilting_point","page":"API Reference","title":"Terrarium.wilting_point","text":"Compute the empirical wilting point of the soil.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Terrarium.windspeed-Tuple{Any, Any, Any, Any, PrescribedAtmosphere}","page":"API Reference","title":"Terrarium.windspeed","text":"windspeed(i, j, grid, fields, ::PrescribedAtmosphere)\n\nRetrieve or compute the windspeed at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Terrarium.AbstractForcing","page":"API Reference","title":"Terrarium.AbstractForcing","text":"Type alias for a UnionAll over DiscreteForcing and ContinuousForcing types from Oceananigans.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.FieldBC","page":"API Reference","title":"Terrarium.FieldBC","text":"Alias for union type of FieldBoundaryConditions or a named tuple of BoundaryConditions with keys corresponding to boundary locations (i.e. top, bottom, etc.)\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Terrarium.Optional","page":"API Reference","title":"Terrarium.Optional","text":"Alias for Union{Nothing, T} indicating that an argument or field of type T is optional and can be replaced with nothing.\n\n\n\n\n\n","category":"type"},{"location":"notebooks/examples_overview/#Examples","page":"Overview","title":"Examples","text":"In this section you'll find a collection of examples that demonstrate the use of Terrarium.jl. All of these are also available as Pluto notebooks in the examples/notebooks directory of the repository. There you'll also find further notebooks that are not included in the documentation, demonstrating e.g. differentiating Terrarium.jl models. Additional example scripts are available in the examples/scripts directory.","category":"section"},{"location":"overview/mathematical_formulation/#Mathematical-formulation","page":"Mathematical formulation","title":"Mathematical formulation","text":"Unlike many other land models, Terrarium.jl strictly follows a philosophy of dynamical modeling via discretized differential equations. This means that all physical processes in the model must be able to be written in terms of a set of continuous-time equations of the form:\n\nfracpartial u(xt)partial t = G(u(xt)) + F(xt)\n\nwhere u(xt) is a field describing the prognostic state of the system, t is time, F is a focing term, and G is a (differentiable) function which computes the tendencies, i.e. the change in the prognostic state at the current time, t.\n\nIn many areas of science and engineering, this approach to modeling is fairly standard. It can be contrasted, however, with discrete-time dynamical modeling where state changes are computed according to a series of discrete update rules, mathbfD, with some fixed time resolution,\n\nmathbfu_t+1 = mathbfD(mathbfu_t)\n\nThe continuous-time formulation has three key advantages over the discrete approach:\n\nFaithfulness to realistic physical processes. Within the context of Earth system modeling, we are primarily interested in processes that operate continuously in time, not in discrete steps. Although the physics of land models may lack a well-defined fluid ‚Äúdynamical core‚Äù like those found in atmosphere and ocean models, they are still ultimately centered around hydrological, thermodynamic, and biological processes that have continuous-time dynamics. As such, we believe that it is generally preferable to build models that follow this structure.\nFlexibility in timestepping and error control. Discrete-time formulations of dynamical systems necessarily require strong assumptions about the time-discretization of the system which often amount to a form of forward Euler with a fixed timestep size. Re-adjustment of the timestep in the discrete dynamical operator mathbfD is sometimes achieved by simply rescaling rate parameters. However, this rescaling makes the strong assumption that the dynamics of the system scale linearly with the timescale and ignores potential feedback mechanisms and scale-dependent interactions in the dynamics. Continuous-time formulations relax this assumption and permit a much broader range of timestepping strategies that can account for nonlinearity and are thus, in our view, better suited to the simulation of coupled physical processes.\nHeterogeneous temporal resolution. Data assimilation and parameter estimation problems often necessitate the comparison of model outputs with observational time series data. These data often come at differing temporal resolutions and have irregular sample spacing due to, e.g. missing values. This can pose a problem for discrete-time models which must either (i) rescale the timestep to match the data, which has significant physical implications, or (ii) resort to temporal interpolation of the model outputs which is likely to violate the underlying physical conservation laws. Continuous-time systems do not have this problem since the timestep can always be adapted to obtain output at any set of time points.\n\nNote that one common problem in continuous-time dynamical modeling is the representation of discontinuous or instantaneous events/disruptions to the system. Such events can, however,  be handled through the use of callback functions based on the (discretized) state mathbfu. These cases should nonetheless be considered the exception rather than the rule.","category":"section"},{"location":"overview/mathematical_formulation/#Practical-implications","page":"Mathematical formulation","title":"Practical implications","text":"While the above modeling philosophy has many advantages, it also places some practical restrictions on how we code the model physics. The most important constraints are:\n\nPrognostic (i.e. time-integrated) state variables must be clearly and coherently distinguished from all other auxiliary variables derived from the prognostic state.\nPrognostic variables of the system should only be updated by a timestepper, callback, or closure opreation, and should not be otherwise modified by the physical processes within a timestep. Note that this precludes the implementation of some traditional land model process formulations, such as the so-called ‚Äúbucket schemes‚Äù for soil hydrology which rely on non-physical, instantaneous routing of water between soil layers.\nFor physical coherence, tendencies must be computed only based on the current state of the system. Similarly, all non-prognostic (auxiliary) variables should be derived only from the prognostic state and/or forcings within each timestep and are not allowed to depend on non-prognostic values from previous timesteps, except in special cases where previous values are used only for computational efficiency (e.g. iterative solvers).\n\nThese restrictions can potentially be relaxed in some cases through the use of callbacks and/or nested time-stepping schemes, but the goal should always be to adhere to them as much as possible to maximize efficiency and minimize potential sources of error.","category":"section"},{"location":"physics/vegetation/#Vegetation","page":"Vegetation","title":"Vegetation","text":"warning: Warning\nThis page is a work in progress. If you have any questions or notice any errors, please raise an issue.\n\nComing soon!","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"We gladly welcome any and all contributions to Terrarium.jl. Building a new land model is a huge undertaking that no single developer or scientist can hope to achieve alone. Collaboration always has been and always will be key to building good geoscientific models. Terrarium is no exception to this, and its success will depend on the contributions of the broader community.\n\nThere are multiple ways in which you could consider contributing to the project:\n\nIf you have a question or an idea, raise an issue or start a discussion on the GitHub repository.\nIf you want to try implementing something, clone the repository and make a pull request. Please take note of our Software development practices below.\nIf you're not able to directly contribute yet but would like to support our work, consider sharing the GitHub repository (or this documentation) with others who you think might be interested.\n\nRegardless of how you choose to contribute, we thank you for your participation, and we look forward to working with you!","category":"section"},{"location":"contributing/#Software-development-practices","page":"Contributing","title":"Software development practices","text":"","category":"section"},{"location":"contributing/#Automated-testing-and-continuous-integration","page":"Contributing","title":"Automated testing and continuous integration","text":"Terrarium.jl adheres to software development standards for automated testing via continuous integration. We write unit tests for every function of our model. In some cases this might appear trivial, but we still want to achieve a near complete coverage of our code in the tests. The majority of the tests should cover the smallest possible units over different input arguments and types (if applicable). Unit tests should typically call the tested functions in a way that is representative for their use in the model, but try to reduce the computational complexity (e.g. by choosing very low dimensional inputs) to keep the overall CI time manageable. Additionally, we have some tests that ensure top-level functionality and stability of the model as well. Every additional proposed feature in a Pull Request has to come with unit tests. Tests verifying differentiability and GPU compatibility will also be requried.","category":"section"},{"location":"contributing/#Kernel-programming","page":"Contributing","title":"Kernel programming","text":"Terrarium.jl is a device-agnostic model that runs on CPUs and GPUs by using KernelAbstractions.jl. This means that most computations need to be implemented within kernel functions that follow KernelAbstractions‚Äô syntax. Each thread in the CPU or GPU will then compute the discretized equations for a single grid point.\n\nFor writing kernels we follow a strategy closely inspired by Oceaninanigans.jl: we want to fuse kernels as much as possible. Kernel fusion means that in practice we write very ‚Äúlarge‚Äù kernels that fuse as many operations as possible together in one kernel. Kernel fusion leads to more efficient GPU computations, especially by reducing memory demand (Wang et. al 2000). In order to still keep our code well structured and modular, our approach relies on implementing most processes as inlined functions that can be called from a GPU kernel. We have not yet found any significant limitations to this approach.\n\nHow this looks in action in Terrarium.jl you can already see in the prototype code, e.g. for the SoilEnergyBalance: There compute_tendencies! is the mandatory function for the model component, it launches exactly one kernel compute_energy_tendency!, which includes several @inline function to compute individual contributions to the energy balance such as compute_energy_tendency, compute_thermal_conductivity and the diffusive_heat_flux.\n\nIt's also worth checking out the Simulation tips provided in the documentation for Oceananigans.","category":"section"},{"location":"contributing/#Automatic-Differentiation-with-Enzyme","page":"Contributing","title":"Automatic Differentiation with Enzyme","text":"For AD, we rely primarily on reverse mode differentiation via Enzyme.jl. In contrast to many other AD systems, Enzyme doesn‚Äôt put particularly strong restrictions on coding style. For example, Array mutations are not only allowed, they are even encouraged!\n\nThere is one thing however, that is crucial for Enzyme to work: type stability. The code absolutely has to be type stable, even in parts that are performance non-critical. Every occurrence of type instability may break differentiability with Enzyme. If this happens, we recommend first quickly checking for type instability of core function calls using @code_warntype and @inferred in unit tests. Then, if the issue is not yet apparent, debug the code using Cthulhu.jl. Cthulhu is an awesome tool to interactively inspect your code for type instabilities and it is extremely easy to run: just preempt the function that you are trying to differentiate with @descend after loading the Cthulhu package.\n\nEnzyme does, however, have some disadvantages; it is still not fully mature and bugs do occur. As of the time of writing (August 2025), this is especially the case for Julia 1.11. We currently recommend staying on Julia 1.10.10 (LTS) for the time being. Other cryptic Enzyme error messages have become rarer with time, but they do still occasionally happen. In these cases, we, along with our AD team led by Valentin in the DELTA-ESM project, are happy to offer support to the best of our abilities.","category":"section"},{"location":"contributing/#Code-style","page":"Contributing","title":"Code style","text":"We use Runic.jl for automatted code formatting. If you submit a PR you probably have seen a comment from our CI that the code is not formatted according to the Runic style. To use runic, you have to run the install Runic install script and then you can choose to either format directly from the command line with runic --inplace . (don't forget the . at the end!), or configure it in your editor of choice or use a Git hook. All details are described in Runic's readme. We recommend setting up Runic as a Git hook to automatically format your code on commit. For that purpose, we provide the Git hook in the .githooks directory of the repository. You can copy the hook from there to your local git hooks directory and make it executable to use like so: \n\ncp .githooks/pre-commit .git/hooks/pre-commit\nchmod +x .git/hooks/pre-commit","category":"section"},{"location":"notebooks/example_model_notebook/","page":"Model Interface","title":"Model Interface","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"04b13d225139b9c162644bb62814e492a42c6a261204a5685fba8a8b3a2c4c52\"\n    julia_version = \"1.11.9\"\n-->\n\n<div class=\"markdown\"><h1 id=\"A-super-basic-example-model-with-Terrarium\">A super basic example model with Terrarium</h1><p>In this example we will set up an embarrassingly simple example to demonstrate Terrarium's model interface. Our model will have 1-dimensional exponential dynamics with a constant offset</p><p class=\"tex\">$$\\frac{du}{dt} = \\alpha u + c + F(t)$$</p><p>for an arbitrary prognostic variable <span class=\"tex\">\\(u\\)</span>. For the sake of this demonstration we will treat the offset <span class=\"tex\">\\(c\\)</span> as an auxiliary/diagnostic variable even though it is constant in time. <span class=\"tex\">\\(F(t)\\)</span> is an external forcing that we apply. </p><p>We begin by defining our model <code>struct</code> that subtypes <code>Terrarium.AbstractModel</code>: </p></div>\n\n\n\n\n<pre class='language-julia'><code class='language-julia'>using Terrarium</code></pre>\n\n\n\n<pre class=\"code-output documenter-example-output\" id=\"var-Random\">TaskLocalRNG()</pre>\n\n\n<div class=\"markdown\"><p>A \"model\" in Terrarium is a subtype of <code>Terrarium.AbstractModel</code> and is a <code>struct</code> type constisting of </p><ul><li><p><code>grid</code> which defines the discretization of the spatial domain</p></li><li><p><code>initializer</code> which is responsible for initializing state variables</p></li><li><p>further fields that define processes, dynamics and submodels </p></li></ul><p>When we follow the advised naming notations of <code>grid</code> and <code>initializer</code> we inherit default methods from <code>Terrarium.AbstractModel</code> such as <code>get_grid</code> and <code>get_initializer</code>. For more complex models we might need to implement custom overrides of <code>initialize!(state, ::Model, ::Initializer)</code> to initialize model states. </p><h2 id=\"What-is-a-&quot;grid&quot;?\">What is a \"grid\"?</h2><p>The <code>grid</code> defines the spatial discretization. Our grids are based on those of <a href=\"https://github.com/CliMA/Oceananigans.jl\">Oceananigans.jl</a> (and <a href=\"https://github.com/SpeedyWeather/SpeedyWeather.jl\">SpeedyWeather.jl</a>/<a href=\"https://github.com/SpeedyWeather/SpeedyWeather.jl/tree/main/RingGrids\">RingGrids.jl</a>) in order to take advantage of their capabilities for device-agnostic parallelization.</p><p>Terrarium currently provides two grid types: </p><ul><li><p><code>ColumnGrid</code> is a set of laterally independent vertical columns with dimensions <span class=\"tex\">\\((x, y, z)\\)</span> where <span class=\"tex\">\\(x\\)</span> is the column dimension, <span class=\"tex\">\\(y=1\\)</span> is constant, and <span class=\"tex\">\\(z\\)</span> is the vertical axis, </p></li><li><p><code>ColumnRingGrid</code> represents a global (spherical) grid of independent, vertical columns where the spatial discretization in the horizontal direction is defined by a <code>RingGrids.AbstractGrid</code>. </p></li></ul><p>In both cases we need to specificy the vertical discretizataion via an <code>UniformSpacing</code>, <code>ExponentialSpacing</code> or <code>PrescribedSpacing</code>.</p><h2 id=\"Initializer-and-Boundary-Conditions\">Initializer and Boundary Conditions</h2><p>For our basic example here the default initializer (which does nothing) will suffice, and we won't have to define a custom one.</p><p>Boundary conditions are specified by passing Oceananigans <code>BoundaryCondition</code> types to <code>initialize</code>. In the case of a linear ODE, however, no boundary conditions are required.</p><h2 id=\"What&#39;s-our-grid?\">What's our <code>grid</code>?</h2><p>For our current example, we are defining a simple linear ODE without any spatial dynamics, so we can get away with just a single column with one vertical layer. We can define it like so:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>grid = ColumnGrid(CPU(), Float64, UniformSpacing(N = 1))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grid\">ColumnGrid{Float64} on Oceananigans.Architectures.CPU() with\n1√ó1√ó1 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0)  regularly spaced with Œîx=1.0\n‚îú‚îÄ‚îÄ Flat y                   \n‚îî‚îÄ‚îÄ Bounded  z ‚àà [-0.1, 0.0] variably spaced with min(Œîz)=0.1, max(Œîz)=0.1</pre>\n\n\n<div class=\"markdown\"><h2 id=\"Defining-the-model\">Defining the model</h2><p>We start by defining a <code>struct</code> for our model that inherits from <code>AbstractModel</code> and consists of three properties: the spatial <code>grid</code>, an <code>initializer</code>, and a single <code>AbstractProcess</code> defining the dynamics, which we will also implement below.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>@kwdef struct LinearDynamics{NF} &lt;: Terrarium.AbstractProcess{NF}\n    \"Exponential growth rate\"\n    alpha::NF = 0.01\n\n    \"Constant offset for exponential growth\"\n    c::NF = 0.1\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>@kwdef struct ExpModel{NF, Grid &lt;: Terrarium.AbstractLandGrid{NF}, Dyn, Init} &lt;: Terrarium.AbstractModel{NF, Grid}\n    \"Spatial grid on which state variables are discretized\"\n    grid::Grid\n\n    \"Linear dynamics resulting in exponential growth/decay\"\n    dynamics::Dyn = LinearDynamics()\n\n    \"Model initializer\"\n    initializer::Init = DefaultInitializer(eltype(grid))\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h2 id=\"Defining-the-model-behaviour\">Defining the model behaviour</h2><p>Now, we want to define our intended model behaviour. For this, we need to define the following methods: </p><ul><li><p><code>variables(::Model)</code> returns a tuple of variable metadata declaring the state variables. Variables must be one of three types: <code>prognostic</code>, <code>auxiliary</code> (sometimes referred to as ‚Äúdiagnostic‚Äù), or <code>input</code>. Prognostic variables fully characterize the state of the system at any given timestep and are updated according to their tendencies (i.e. <span class=\"tex\">\\(u\\)</span> in our example). Tendencies are automatically allocated for each prognostic variable declared by the model. In this example we will treat the offset <span class=\"tex\">\\(c\\)</span> as an auxiliary variable, though we could also just include it as a constant in the tendency computations.</p></li><li><p><code>compute_auxiliary!(state, ::Model)</code> computes the values of all auxiliary variables (if necessary) assuming that the prognostic variables of the system in state are available for the current timestep.</p></li><li><p><code>compute_tendencies!(state, ::Model)</code> computes the tendencies based on the current values of the prognostic and auxiliary variables stored in state.</p></li></ul><p>So, let's define those: </p></div>\n\n<pre class='language-julia'><code class='language-julia'>Terrarium.variables(::ExpModel) = (\n    Terrarium.prognostic(:u, Terrarium.XY()),\n    Terrarium.auxiliary(:c, Terrarium.XY()),\n    Terrarium.input(:F, Terrarium.XY()),\n)</code></pre>\n\n\n\n<div class=\"markdown\"><p>Here, we defined our three variables with their names as a <code>Symbol</code> and whether they are 2D variables (<code>XY</code>) on the spatial grid or 3D variables (<code>XYZ</code>) that also vary along the vertical z-axis. Here we are considering only a simple scalar model so we choose 2D (<code>XY</code>), bearing in mind that all points in the X and Y dimensions of <code>ColumnGrid</code> are independent of each other.</p><p>We also need to define <code>compute_auxiliary!</code> and <code>compute_tendencies!</code> as discussed above. We will use here a pattern which is commonly employed within Terrarium: we unpack the process from the model and forward the method calls to more specialzied ones defined for the <code>LinearDynamics</code> process.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function Terrarium.compute_auxiliary!(state, model::ExpModel)\n    compute_auxiliary!(state, model, model.dynamics)\n    return nothing\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>function Terrarium.compute_tendencies!(state, model::ExpModel)\n    compute_tendencies!(state, model, model.dynamics)\n    return nothing\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Note that, when implementing models within the Terrarium module itself, the <code>Terrarium.</code> qualifier in the definition is not needed.</p><h2 id=\"Implementing-the-dynamics\">Implementing the dynamics</h2><p>Next, we define the functions that compute the actual dynamics. In order to do this, we need to know a little about how the variables we just defined are handled in our <code>StateVariables</code>. The <code>StateVariables</code> hold all prognostic and auxiliary variables, their tendencies and closures and additional inputs and forcings in seperate <code>NamedTuples</code>. Note that Terrarium also defines shortcuts such that, e.g. in our example, both <code>state.prognostic.u</code> and <code>state.u</code> would work.</p><p>With that in mind, let's define the methods:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function Terrarium.compute_auxiliary!(\n        state,\n        model::ExpModel,\n        dynamics::LinearDynamics\n    )\n    # set auxiliary variable for offset c\n    return state.auxiliary.c .= dynamics.c\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'># du/dt = u + c\nfunction Terrarium.compute_tendencies!(\n        state,\n        model::ExpModel,\n        dynamics::LinearDynamics\n    )\n    # define the dynamics; we'll use some special characters to make the equation nicer to look at :)\n    return let u = state.prognostic.u,\n            ‚àÇu‚àÇt = state.tendencies.u,\n            Œ± = dynamics.alpha,\n            # note again that here we could also just use dynamics.c instead of defining an auxiliary variable!\n            c = state.auxiliary.c\n        F = state.inputs.F\n        # Write into tendency variable ‚àÇu‚àÇt\n        ‚àÇu‚àÇt .= Œ± * u + c + F\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>These example compute functions are really the simplest possible, for more complex operations, we would need to define them via <code>KernelAbstractions</code> kernels. We will not go into further details on that in this notebook.</p><p>However, now we have everything our model needs and we can finally use it! </p><h2 id=\"Running-our-model\">Running our model</h2><p>First, we will define our initial conditions.</p><p>User-specified <code>Field</code> initializers passed to <code>initialize</code> can be provided in any form supported by <code>Oceananigans.set!</code>, including constants, arrays, and functions of the form <code>(x,z) -&gt; val</code>: </p></div>\n\n<pre class='language-julia'><code class='language-julia'>initializers = (u = 1.0,)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-initializers\">(u = 1.0,)</pre>\n\n\n<div class=\"markdown\"><p>Then, we define our forcing. For that, our time-dependent forcing is loaded in from a <code>Oceananigans.FieldTimeSeries</code>. If you want to load the forcing from e.g. a netCDF file you can use the <code>RasterInputSource</code> that is based on <a href=\"https://github.com/rafaqz/Rasters.jl\">Rasters.jl</a>. In the concrete case, we'll just generate a random forcing: </p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    t_F = 0:1:300\n    F = FieldTimeSeries(grid, XY(), t_F)\n    F.data .= randn(size(F))\n    input = InputSource(; F)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-F\">FieldTimeSeriesInputSource{Float64, XY{Center, Center}, (:F,), Tuple{FieldTimeSeries{Center, Center, Nothing, Oceananigans.OutputReaders.Clamp, Oceananigans.OutputReaders.InMemory{Nothing}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, CPU}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing, Nothing, @NamedTuple{}}}}(XY{Center, Center}(Center(), Center()), (F = 1√ó1√ó1√ó301 FieldTimeSeries{Oceananigans.OutputReaders.InMemory} located at (Center, Center, ‚ãÖ) on Oceananigans.Architectures.CPU\n‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ indices: (:, :, :)\n‚îú‚îÄ‚îÄ time_indexing: Clamp()\n‚îú‚îÄ‚îÄ backend: InMemory()\n‚îî‚îÄ‚îÄ data: 3√ó1√ó1√ó301 OffsetArray(::Array{Float64, 4}, 0:2, 1:1, 1:1, 1:301) with eltype Float64 with indices 0:2√ó1:1√ó1:1√ó1:301\n    ‚îî‚îÄ‚îÄ max=2.67689, min=-2.19504, mean=0.0912836,))</pre>\n\n\n<div class=\"markdown\"><p>Here we constructed a 2D (<code>XY()</code>) time series on our <code>grid</code> at times <code>t_F</code> with random normal distributed data and definted our <code>InputSource</code> for our model based on it. </p></div>\n\n\n<div class=\"markdown\"><p>Then, we construct our model from the chosen <code>grid</code></p></div>\n\n<pre class='language-julia'><code class='language-julia'>model = ExpModel(grid)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-model\">ExpModel{Float64} on Oceananigans.Architectures.CPU()\n‚îú‚îÄ‚îÄ grid:  ColumnGrid{Float64, Oceananigans.Architectures.CPU} with dimensions (1, 1, 1)\n‚îú‚îÄ‚îÄ dynamics:  Main.var\"workspace#5\".LinearDynamics{Float64}\n‚îú‚îÄ‚îÄ initializer:  Terrarium.DefaultInitializer{Float64}\n</pre>\n\n\n<div class=\"markdown\"><p>We now can initialize our model, i.e. we run all pre-computation, and initialize a numerical integrator for our model by passing it to <code>initialize</code> along with a suitable timestepper and our input/forcing data, which we here choose to be the second-order Heun method with a timestep of 1 second.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>integrator = initialize(model, Heun(Œît = 1.0), input; initializers)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-integrator\">Integrator of Main.var\"workspace#5\".ExpModel{Float64, Terrarium.ColumnGrid{Float64, Oceananigans.Architectures.CPU, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}}, Main.var\"workspace#5\".LinearDynamics{Float64}, Terrarium.DefaultInitializer{Float64}} with Terrarium.Heun{Float64, Terrarium.StateVariables{Float64, (:u,), (), (:c,), (:F,), (), Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{}, Oceananigans.TimeSteppers.Clock{Float64, Float64, Int64, Int64}}}\n‚îú‚îÄ‚îÄ Current time: 0.0\n‚îú‚îÄ‚îÄ StateVariables{Float64}(clock = Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Œît=Inf days), prognostic = (:u,), auxiliary = (:c,), inputs = (:F,), namespaces = ())\n</pre>\n\n\n<div class=\"markdown\"><p>We can advance our model by one step via the <code>timestep!</code> method:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>timestep!(integrator)</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>integrator.state.u</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash351687\">1√ó1√ó1 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing} reduced over dims = (3,) on Oceananigans.Grids.RectilinearGrid on CPU\n‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions\n‚îÇ   ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: Nothing\n‚îî‚îÄ‚îÄ data: 3√ó1√ó1 OffsetArray(::Array{Float64, 3}, 0:2, 1:1, 1:1) with eltype Float64 with indices 0:2√ó1:1√ó1:1\n    ‚îî‚îÄ‚îÄ max=1.17236, min=1.17236, mean=1.17236</pre>\n\n\n<div class=\"markdown\"><p>or we can use <code>run!</code> for a fixed number of <code>steps</code> or over a desired <code>Dates.Period</code>:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>run!(integrator, period = Hour(1))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash506645\">Integrator of Main.var\"workspace#5\".ExpModel{Float64, Terrarium.ColumnGrid{Float64, Oceananigans.Architectures.CPU, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}}, Main.var\"workspace#5\".LinearDynamics{Float64}, Terrarium.DefaultInitializer{Float64}} with Terrarium.Heun{Float64, Terrarium.StateVariables{Float64, (:u,), (), (:c,), (:F,), (), Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{}, Oceananigans.TimeSteppers.Clock{Float64, Float64, Int64, Int64}}}\n‚îú‚îÄ‚îÄ Current time: 3601.0\n‚îú‚îÄ‚îÄ StateVariables{Float64}(clock = Clock{Float64, Float64}(time=1.000 hours, iteration=3601, last_Œît=1 second), prognostic = (:u,), auxiliary = (:c,), inputs = (:F,), namespaces = ())\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>integrator.state.u</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash351687\">1√ó1√ó1 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing} reduced over dims = (3,) on Oceananigans.Grids.RectilinearGrid on CPU\n‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions\n‚îÇ   ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: Nothing\n‚îî‚îÄ‚îÄ data: 3√ó1√ó1 OffsetArray(::Array{Float64, 3}, 0:2, 1:1, 1:1) with eltype Float64 with indices 0:2√ó1:1√ó1:1\n    ‚îî‚îÄ‚îÄ max=8.30198e16, min=8.30198e16, mean=8.30198e16</pre>\n\n\n<div class=\"markdown\"><p>As you can see, in just 1 hour of simulated time, our state variable already grew from <code>1</code> to <code>4e16</code>! If that's not exponential growth, we don't know what is ;) </p></div>\n\n\n<div class=\"markdown\"><p>But wait there's more! What if we want to actually save the results?</p><p>The <code>integrator</code> data structure implements the Oceananigans model interface, so we can also use it to set up a <code>Simulation</code>:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>sim = Simulation(integrator; stop_time = 300.0, Œît = 1.0)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-sim\">Simulation of Terrarium.ModelIntegrator{Float64, Oceananigans.Architectures.CPU, Terrarium.ColumnGrid{Float64, Oceananigans.Architectures.CPU, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}}, Terrarium.Heun{Float64, Terrarium.StateVariables{Float64, (:u,), (), (:c,), (:F,), (), Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{}, Oceananigans.TimeSteppers.Clock{Float64, Float64, Int64, Int64}}}, Main.var\"workspace#5\".ExpModel{Float64, Terrarium.ColumnGrid{Float64, Oceananigans.Architectures.CPU, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}}, Main.var\"workspace#5\".LinearDynamics{Float64}, Terrarium.DefaultInitializer{Float64}}, Terrarium.StateVariables{Float64, (:u,), (), (:c,), (:F,), (), Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{Oceananigans.Fields.Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Nothing, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, @NamedTuple{bottom_and_top::Nothing, south_and_north::Nothing, west_and_east::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Oceananigans.Utils.OffsetStaticSize{(1:1, 1:1)}, typeof(Oceananigans.BoundaryConditions.cpu__fill_periodic_west_and_east_halo!)}}, @NamedTuple{bottom_and_top::Tuple{Nothing, Nothing}, south_and_north::Tuple{Nothing, Nothing}, west_and_east::Tuple{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}}}, Nothing, Nothing}}, Tuple{}, Oceananigans.TimeSteppers.Clock{Float64, Float64, Int64, Int64}}, @NamedTuple{u::Float64}, Terrarium.InputSources{Tuple{Terrarium.FieldTimeSeriesInputSource{Float64, Terrarium.XY{Oceananigans.Grids.Center, Oceananigans.Grids.Center}, (:F,), Tuple{Oceananigans.OutputReaders.FieldTimeSeries{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Nothing, Oceananigans.OutputReaders.Clamp, Oceananigans.OutputReaders.InMemory{Nothing}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, Oceananigans.Grids.RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded, Oceananigans.Grids.StaticVerticalDiscretization{OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Oceananigans.Architectures.CPU}, Float64, Oceananigans.BoundaryConditions.FieldBoundaryConditions{Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Oceananigans.BoundaryConditions.BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing, Nothing, @NamedTuple{}}}}}}}\n‚îú‚îÄ‚îÄ Next time step: 1 second\n‚îú‚îÄ‚îÄ run_wall_time: 0 seconds\n‚îú‚îÄ‚îÄ run_wall_time / iteration: 0 seconds\n‚îú‚îÄ‚îÄ stop_time: 5 minutes\n‚îú‚îÄ‚îÄ stop_iteration: Inf\n‚îú‚îÄ‚îÄ wall_time_limit: Inf\n‚îú‚îÄ‚îÄ minimum_relative_step: 0.0\n‚îú‚îÄ‚îÄ callbacks: OrderedDict with 3 entries:\n‚îÇ   ‚îú‚îÄ‚îÄ stop_time_exceeded =&gt; Callback of stop_time_exceeded on IterationInterval(1)\n‚îÇ   ‚îú‚îÄ‚îÄ stop_iteration_exceeded =&gt; Callback of stop_iteration_exceeded on IterationInterval(1)\n‚îÇ   ‚îî‚îÄ‚îÄ wall_time_limit_exceeded =&gt; Callback of wall_time_limit_exceeded on IterationInterval(1)\n‚îî‚îÄ‚îÄ output_writers: OrderedDict with no entries</pre>\n\n\n<div class=\"markdown\"><p>We can then add an output writer to the simulation and finally <code>run!</code> it!</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    # We need to import some types from Oceananigans here for output handling\n    using Oceananigans: TimeInterval, JLD2Writer\n    using Oceananigans.Units: seconds\n\n    # Reset the integrator to its initial state\n    Terrarium.initialize!(integrator)\n\n    output_dir = mkpath(tempname())\n    output_file = joinpath(output_dir, \"simulation.jld2\")\n    sim.output_writers[:snapshots] = JLD2Writer(\n        integrator,\n        (u = integrator.state.u,);\n        filename = output_file,\n        overwrite_existing = true,\n        including = [:grid],\n        schedule = TimeInterval(10seconds)\n    )\n\n    # Run the simulation\n    run!(sim)\n    @assert isfile(output_file) \"Output file does not exist!\"\n    display(\"Simulaton data saved to $(output_file)\")\nend</code></pre>\n\n\n\n\n\n\n<div class=\"markdown\"><p>Then load the output data and plot the results:</p></div>\n\n<pre class='language-julia'><code class='language-julia'># Load output into field time series\nfts = FieldTimeSeries(output_file, \"u\")</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-fts\">1√ó1√ó1√ó31 FieldTimeSeries{Oceananigans.OutputReaders.InMemory} located at (Center, Center, ‚ãÖ) of u at /tmp/jl_mFedK3anMJ/simulation.jld2\n‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 1√ó0√ó1 halo\n‚îú‚îÄ‚îÄ indices: (:, :, :)\n‚îú‚îÄ‚îÄ time_indexing: Linear()\n‚îú‚îÄ‚îÄ backend: InMemory()\n‚îú‚îÄ‚îÄ path: /tmp/jl_mFedK3anMJ/simulation.jld2\n‚îú‚îÄ‚îÄ name: u\n‚îî‚îÄ‚îÄ data: 3√ó1√ó1√ó31 OffsetArray(::Array{Float64, 4}, 0:2, 1:1, 1:1, 1:31) with eltype Float64 with indices 0:2√ó1:1√ó1:1√ó1:31\n    ‚îî‚îÄ‚îÄ max=466.867, min=1.0, mean=138.202</pre>\n\n<pre class='language-julia'><code class='language-julia'>plot(1:length(fts), [fts[i][1, 1, 1] for i in 1:length(fts)])</code></pre>\n<img height=\"450\" src=\"data:image/png;base64, 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eHAAAADglfzN8RNyzrHj8puFa/PIig1p7+rJ6GGteeek/XL8hL0DvDole9Bzzz2Xk046KR0dHanVapk6dWoOO+ywvPTSS5k7d25Wr16dv//7v8+yZcty0003ZXvLly/PqaeemtWrV6fP5MmTc9xxx2XevHlZsWJF5s6dm3e/+9156KGHss8++2R7d911V97//venp6cnTU1NOeGEEzJmzJjcd9992bhxY66//vps2LAhN910UwAAAGAgBpemvPfI0XnvkaMDvDZK9qBLLrkkHR0dGTZsWG677bacfPLJ6bd58+Z85CMfyS9+8YvcfPPNOf/883PmmWdmW5dccklWr16dPjfeeGMuuOCC9Lv66qvzhS98IYsWLcqVV16Za6+9Ntvq7OzMzJkz09PTk3322Sfz5s3LlClT0mfr1q0566yzcvvtt+fmm2/OBRdckBkzZgQAAACA11/JHrJ+/frMmjUrfT772c/m5JNPzrba2tpyww035Ne//nW2bNmSe+65J2eeeWb6LV68OLfeemv6XHbZZbnggguyrcsvvzyPPPJIbrnllnzve9/LlVdemeHDh6ffjTfemBUrVqTPjTfemClTpqTfoEGD8vOf/zzHHHNMlixZkq9//euZMWNGAAAAAHj9lewhCxYsSL8zzjgjf84+++yTo446Kg899FAef/zxbOu2225Lb29varVaLr300vw5H/3oR3PLLbeko6Mjv/nNb3L22Wen36xZs9Ln8MMPz/Tp07O9tra2nHPOObnmmmvywAMPZO3atRk1alQAAAAAeH2V7CHr1q3Lsccemz6TJk3KjvT29qZPKSXbmj17dvocccQRGTt2bP6cU089NW1tbdm8eXNmz56ds88+O/3mzJmTPu9617uyI2eccUauueaa1Ov1/Pa3v8373ve+AAAAAPD6KtlDzjjjjJxxxhnZmSVLluTJJ59Mn6lTp2ZbCxcuTJ+jjjoqO9La2ppjjjkm8+bNy6JFi9Jv9erVeemll9LnqKOOyo6ceOKJqdVq6e3tzaJFiwIAAADA66+kQjo7O7Np06asWrUqd999d7797W+nvb09kyZNyiWXXJJtLVu2LH0mTJiQnZkwYUL6LF26NP2WLVuWfhMmTMiOtLS0ZNSoUVmzZk2WLl0aAAAAAF5/JRXy+c9/Pt/61reyrfPOOy/f/OY3M3LkyPTr7e1Ne3t7+rS1tWVn2tra0mfTpk3pt3nz5vRra2vLzrS1tWXNmjXZtGlTBmrSpEnZFStXrsyrsXbt2nR1daVer6elpSUAb2arV69OT09ParVampubA/BmVa/Xs3r16jQ1NaWpqSkAb2Zbt27NmjVrMmjQoNTr9dC4Sipu7ty5ueOOO3LhhRem38svv5ze3t70aW1tzc60tramT3t7e/p1dHSkX2tra3amtbU1fdrb2zNQzz77bHZFd3d3Xo2enp709PSku7s7TU1NAXgz6+7uTr1eT3d3d3p7ewPwZlWv19PT05N6vZ7u7u4AvJl1d3enp6cnTU1N6e7uDo2rpEK++c1v5hvf+Eaef/75zJ8/P1/72tcye/bsXHTRRVmzZk2++MUvpk9ra2v6dXV1ZWc6OzvTp6WlJf0GDx6cfl1dXdmZzs7O9GlpaclAPfPMMxmISZMmpc+4cePyajQ3N6ezszOjR49Oa2trAN7Ment709PTk3HjxqW5uTkAb1b1ej31ej1NTU0ZN25cAN7Murq6UqvV0tLSkjFjxoTGVVIhTU1NaWpqygEHHJADDjgg73nPe3Lqqafm/vvvz9/93d/l4x//eEaOHJmmpqYMGTIkHR0d2bJlS3amvb09fdra2tJv6NCh6bdly5bsTHt7e/q0tbVloA455JDsilJKXo1SSnp6elJKSSklAG9mpZTUarWUUtLc3ByAN6t6vZ5SSpqamlJKCcCbWb1eTyklpZSUUkLjKqmwpqamXHbZZbn//vvT0dGR3/3ud5k+fXr6jB8/PosXL87KlSuzMytWrEifcePGpd/48ePTb+XKldmR7u7urFmzJn3GjRsXAAAAAF5/JXvIZz7zmSxYsCDveMc78pWvfCU7Mnny5PRbt25d+h122GFZvHhxFi5cmJ15+umn02fKlCnpN378+LS1tWXz5s1ZuHBhdmTx4sWp1+vpM2XKlAAAAADw+ivZQzo6OnLvvfdm1apV+cpXvpId+dOf/pR+hx56aPpNmzYtd9xxRx577LFs2rQpw4YNy/aefvrprFq1Kn2mTZuWbU2dOjV333135syZkx2ZM2dO+k2dOjUAAAAAvP5K9pATTjgh3//+9/PUU0/liSeeyNFHH50/5xe/+EX6NDU15eijj06/GTNm5Itf/GK2bt2an/70p/nUpz6V7f3oRz9Kn5aWlkyfPj3bmjFjRu6+++489NBDWbBgQaZMmZLt/fjHP06fE044IQcccEAAAAAAeP2V7CEzZszI5Zdfng0bNuRjH/tYbr311hxwwAHp19vbm+9///u54YYb0udjH/tY9tprr/Q74ogjctppp+XOO+/MFVdckenTp+fAAw9Mv0cffTTXXntt+sycOTMjRozItj784Q/niiuuyNq1a/PJT34yd911VwYPHpx+3/3udzN37tz0ueyyywIAAADAnlGyh4wdOzbXXHNNPvGJT+T3v/99pkyZkve85z2ZNGlSXnzxxTz88MN5/PHH0+fggw/Otddem+1/EGpjAAAgAElEQVR961vfygMPPJA1a9bk+OOPz4wZM3Lsscdm3rx5uf3229PR0ZGDDjooV111VbY3dOjQfPvb3865556b2bNn5+ijj86ZZ56ZUaNG5Z577sk999yTPu9973tzzjnnBAAAAIA9o2QPuuiii7J169Z8+ctfzosvvphf/vKX2VatVsuHP/zhXH311Wlra8v23vKWt+TOO+/Meeedl+eeey4/+MEPsq23vvWtufnmmzNy5Mj8OR/4wAeyadOmXHzxxVm8eHG+8Y1vZFvnnntubrjhhtRqtQAAAACwZ5TsQbVaLZ/+9Kdz3nnn5Y477sjixYvz3HPPZf/998/hhx+ek046KUceeWR25qSTTsqCBQsya9aszJs3L+vXr8/o0aNzyimn5LTTTkspJTszc+bMnH766bnpppsyf/78dHR0ZOLEiZkxY0ZOPPHEAAAAALBnlVTAfvvtlw996EN5tYYMGZLzzz8/559/fl6N0aNH5+KLLw4AAAAA1VMCAAAAABVWAgAAAAAVVgIAAAAAFVYCAAAAABVWAgAAAAAVVgIAAAAAFVYCAAAAABVWAgAAAAAVVgIAAAAAFVYCAAAAABVWAgAAAAAVVgIAAAAAFVYCAAAAABVWAgAAAAAVVgIAAAAAFVYCAAAAABVWAgAAAG9AL3VszaDmpgxtaQ7Q2EoAAADgDeLB517MN+57JncvXJtNnd3pM3HfIXn/MWPzuZMnZezwwQEaTwkAAAC8AfyPe57OV369MPXe3mxr6Ysd+eb9z+aff788v/jICXnHIfsFaCwlAAAA0OB+9PCyfOnOp7IzL2zpyhnffzj/8dl35KARewVoHCUAAADQwLp66vn87QsyEBte3por7l6UH5331gCNowQAAAAa2H2L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06dry5YtAgAr2759u9atWyfTD37wA2VmZqp///4yFRUVacGCBXrrrbd04MABPfXUU1q7dq2a27Ztm1asWCHT6NGjtWrVKg0ZMkQlJSXKyMjQokWLdPLkSU2fPl1btmwRAFhZWlqa8vPzZbfbtXDhQs2fP1+RkZEy7d27V1OnTlVubq4WL16s++67TyNGjFBzCxcuVHZ2tkwzZszQCy+8oBtvvFHHjh3Ts88+q3fffVd/+tOflJ6erieffFKwDkMICh988IF2794t05IlSzR9+nQFJCcn67333tOtt96qiooKvfTSS9q0aZMAIJi9//77+vOf/6y9e/fqs88+k9/vV1v98pe/lCkuLk5ZWVlyu90yxcbGauHChSouLlZGRoaysrJ06NAhJSQkCACsau7cuTJ17dpV77//vpxOpwK6d++uzMxM1dbWasOGDXrzzTe1YMEC9e/fXwG//OUvZYqLi1NWVpbcbrdMsbGxWrhwoYqLi5WRkaGsrCwdOnRICQkJAgArqqmp0auvvirTY489pkWLFqm5kSNHavPmzRoyZIgaGxu1ceNGjRgxQgGlpaVKT0+Xafz48Vq5cqXsdrtM/fv31zvvvKMxY8Zo3759Wrp0qWbOnKnw8HDBGgwhKGzYsEGmrl276umnn9alBgwYoEmTJmnt2rXaunWramtr5XA4BADBat26ddqwYYOu1qlTp5SdnS3T3Llz5Xa7dakFCxYoIyNDfr9fmzZtUkJCggDAik6fPq3c3FyZnnzySTmdTl3Oc889pw0bNsi0Z88e9e/fX6ZTp04pOztbprlz58rtdutSCxYsUEZGhvx+vzZt2qSEhAQBgBUdPXpUXq9XpmnTpulyBg0apEGDBunQoUM6cOCAmtu6datqampkevnll2W329Wcw+HQ7Nmz9dhjj+ns2bP69NNPlZKSIliDIQSFHTt2yDRu3DiFh4frciZMmKC1a9eqrq5On376qe655x4BQLCaOXOm7r33XgUcOXJES5cu1ZXs2LFDAampqbqcXr16adiwYdq/f7927typX/ziFwIAKzpy5IgCkpKS1JJbbrlFNptNfr9fR48eVcCOHTsUkJqaqsvp1auXhg0bpv3792vnzp36xS9+IQCwosOHDytgwIABaklMTIxMFRUVam7Hjh0y9e7dW0OHDtXljB8/XmFhYfL5fNq5c6dSUlIEazAE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\" style=\"object-fit: contain; height: auto;\" width=\"600\"/>\n\n\n<div class=\"markdown\"><p>Well that's it. We defined and ran a simple exponential model with external forcing following the Terrarium <code>AbstractModel</code> interface! Stay tuned for more!</p></div>\n\n<!-- PlutoStaticHTML.End -->","category":"section"},{"location":"#Terrarium.jl","page":"Home","title":"Terrarium.jl","text":"Terrarium.jl is a new and upcoming land model that aims to support hybrid physics- and data-driven land modeling across multiple spatial and temporal scales. We envision Terrarium to be part of a new generation of Earth system component models that combine modularity, interactivity, GPU-compability and auto-differentiability (AD) for seamless integration of process-based and data-driven model components in both global and regional scale simulations.\n\nTerrarium is being developed alongside SpeedyWeather.jl and Oceananigans.jl as the land component of a new, user-friendly, and fully GPU/AD-compatible Earth System Model in the Julia programming language.\n\nwarning: üößüöß Under construction üößüöß\nThis is an early prototype of our model and is not production-ready. Expect things to change rapidly and break often. If you share our vision for a new paradigm of Earth system modeling and would like to get involved in the project, don‚Äôt hesitate to reach out by creating an issue on GitHub issues or sending us an email. We are always happy to welcome new collaborators!","category":"section"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"Pages = [\n    \"overview/mathematical_formulation.md\",\n    \"overview/software_architecture.md\",\n    \"api_reference.md\",\n]\nDepth = 3","category":"section"},{"location":"overview/numerical_core/#Numerical-core","page":"Numerical core","title":"Numerical core","text":"Terrarium is based on the numerics and finite-volume method (FVM) operators provided by Oceananigans.jl. All state variables are realized as Oceananigans Fields defined over a particular choice of grid which discretizes physical space into a finite number of volumes or \"cells\". This page gives a brief overview of the basic concepts behind the numerical building blocks of Oceanangians and Terrarium.","category":"section"},{"location":"overview/numerical_core/#Grids","page":"Numerical core","title":"Grids","text":"Terrarium defines its own AbstractLandGrid types as wrappers around Oceananigans AbstractGrid types (note that these wrappers may be consolidated into full-fledged AbstractGrids in the future). At the moment, Terrarium grids are based primarily on the Oceanangians RectilinearGrid, which represents a rectangular volume divided orthogonally into smaller control volumes along orthogonal X, Y, and Z axes. There are currently two AbstractLandGrid implementations:\n\nColumnGrid which represents an unstructured collection of 1D vertical columns discretized along the Z axis with the X axis corresponding to a non-spatial index over each of those columns and the Y axis ignored (assigned a Flat grid \"topology\" in the underlying RectilinearGrid).\nColumnRingGrid which is the same as ColumnGrid but with columns ordered according to a user-specified RingGrid from RingGrids.jl. Under this configuration, each dimension along the X axis corresponds to a point in the RingGrid, allowing for direct translation between Terrarium and RingGrids Fields. This is primarily motivated by our goal to couple Terrarium with SpeedyWeather.jl.\n\nAll Terrarium AbstractLandGrid implementations are required to implement the following methods:\n\narchitecture(grid) (from Oceananigans) which returns the Architecture (e.g. CPU or GPU) on which the grid is defined,\nget_field_grid(grid) which returns the underlying Oceananigans grid.\n\nThe vertical Z-axis is currently limited to representing the subsurface (typically soil) domain, though we plan to expand this to include snow and canopy layers in the future.\n\n!!! info Ordering of vertical layers     Oceananigans follows a positive-upwards convention for the vertical axis. This also implies that the vertical layer at the first index of a 3D Terrarium field is actually the bottom-most layer in the ground/soil column; i.e. interior(temperature)[1,1,1] for a Field called temperature would correspond to the vertical layer at the bottom of the first grid cell (i.e. X = 1). To get the topmost layer, use instead interior(temperature)[1,1,end]. Note that here interior is a function from Oceananigans that retrieves a view of the Field excluding halo (boundary condition) cells.\n\nFor more information on how Oceananigans grids work, we recommend reading the corresponding page in the Oceananigans documentation.","category":"section"},{"location":"overview/numerical_core/#Fields","page":"Numerical core","title":"Fields","text":"Fields define Arrays of data that align with a grid. In Terrarium, Fields are used exclusively to represent state and input variables that vary in space (and time). All Fields have a corresponding location(field) = (LX, LY, LZ) which describes how the Field aligns with the underlying grid. Each of LX, LY, and LZ can take on values of either Center, Face, or nothing, where Center refers to the spatial centerpoint of the cell (representing the spatial average over that volume in the typical finite-volume sense) and Face corresponds to values defined at the interfaces such as fluxes or conductivities. A nothing location refers to a reduced quantity averaged or integrated over the corresponding axis.\n\nIn addition to holding data, Fields also can also store one or more associated boundary conditions as well as \"halo\" regions used to define them. Boundary conditions can either be Dirichlet-type (ValueBoundaryCondition), Neumann-type (GradientBoundaryCondition), or fluxes (FluxBoundaryCondition). Boundary conditions can be defined using functions, scalars, Arrays or other Fields.\n\nFields can also serve as the basis for building expression trees: e.g. writing C = A * B + 1 where A and B are both Fields results in a derived Field C that will lazily compute the expression when accessed. Similarly, Fields can be reduced over a grid axis using operations like Integral and Average, though these must be explciitly computed via compute!.\n\nFor a more detailed overview of Fields, we recommend checking out the corresponding page in the Oceananigans documentation.","category":"section"},{"location":"overview/numerical_core/#Parallel-programming-with-KernelAbstractions.jl","page":"Numerical core","title":"Parallel programming with KernelAbstractions.jl","text":"Like Oceananigans and SpeedyWeather, the numerical core of Terrarium is based on KernelAbstractions.jl which allows for device-agnostic parallel programming via computational kernels. The purpose of this design is to allow for highly efficient, scalable, and cross-architecture (e.g. CPU/GPU/TPU) parallelization of all numerical computations. Kernels are defined using the @kernel macro from KernelAbstractions:\n\n@kernel function square_kernel!(output, input, other_args...)\n    i, j, k = @index(Global, NTuple)\n    output[i, j, k] = input[i, j, k]^2\nend\n\nwhere input and output are here assumed to be 3D Arrays or Fields. Note that kernels can also accept any arbitrary number of arguments of any plain data type (including immutable structs) for which isbits(arg) is true.\n\nKernels represent self-contained programs that can be execute in parallel by large number of worker threads or processes. Intuitively, you can think of the kernel function as the body of a for loop that executes over all finite volumes defined on the grid. The @index macro extracts the index of the executing thread within the parallel kernel; Global here refers to the index across all workgroups (or \"blocks\" in CUDA language).\n\nTerrarium and Oceananigans kernels are typically launched over a grid (or some subset thereof) via launch!,\n\nlaunch!(architecture(grid), grid, :xyz, square_kernel!, output_field, input_field)\n\nwhere :xyz indicates the dimensions of the grid over which the kernel should be executed. For 2D (e.g. surface) computations, this would instead be :xy. In Terrarium, we typically use a slightly condensed variant of launch! for convenience:\n\nlaunch!(grid, XYZ, square_kernel!, output_field, input_field)\n\nwhich automatically passes grid as the second argument to the kernel. Note that, in order to make use of this convenience dispatch of launch!, the above kernel would need to be modified to have the signature square_kernel!(output, grid, input, other_args...). We generally find this convenient since it makes the kernel's dependence on the grid more explicit. However, it comes with a small amount of runtime overhead in cases where the grid is not needed. Note also the argument XYZ (or XY for 2D) corresponds to a VarDims type used to define Terrarium state variables; this syntax can be used interchangeably with the Oceananigans Symbol syntax.\n\nwarning: Warning\nThe kernel launching patterns used in Terrarium are still in an early stage of development and may change in the future.","category":"section"},{"location":"overview/numerical_core/#Numeric-types","page":"Numerical core","title":"Numeric types","text":"A common pattern that you may notice throughout the Terrarium codebase is the widespread use of the type argument NF. This stands for \"number format\" (in Oceananigans/ClimA it's usually called FT for \"floating-point type\") and is usually set to either double-precision Float64 or single-precision Float32, though lower precisions (or even non-Float types) are also theoretically possible. The widespread use of these type arguments is necessary to ensure (i) flexibility in the number format for all model parameters and state variables, and (ii) consistency throughout any given configuration of the model. We typically want to avoid the situation where some variables have type Float64 and some have Float32, for example, since this can reuslt in errors and severe degradation of performance when running on GPU. As such, we typically require all parameter and configuration structs to be defined following the pattern:\n\n@kwdef struct SomeParameters{NF}\n    a::NF = 1.0\n    b::NF = 2.0\nend\n\nwith a constructor that accepts the numeric type as the first argument, e.g.\n\nSomeParameters(::Type{NF}; kwargs...) where {NF} = SomeParameters{NF}(; kwargs...)\n\nor\n\nSomeParameters(::Type{NF}; a::NF = 1.0, b::NF = 2.0) where {NF} = SomeParameters(a, b)\n\nIn the latter case, the @kwdef macro on the struct definition may be omitted.","category":"section"}]
}
